################################################################################
## Copyright (C) 2022 Potsdam Institute for Climate Impact Research (PIK),    ##
## see COPYRIGHT file.                                                        ##
##                                                                            ##
## This file is part of LandInG and licensed under GNU AGPL Version 3 or      ##
## later. See LICENSE file or go to http://www.gnu.org/licenses/              ##
## Contact: https://github.com/PIK-LPJmL/LandInG/                             ##
################################################################################

################################################################################
## This script applies gapfilling to FAOSTAT production and landuse data,     ##
## aggregates gridded harvested areas from Monfreda to the country scale and  ##
## compares which crops are present in either dataset, matching crops even if ##
## their names are different.                                                 ##
## You need to run read_FAOSTAT.R before this script.                         ##
################################################################################

# Clean up memory
rm(list = ls(all = TRUE))

################################################################################
## Setup of variables valid across all scripts related to land use data       ##
## processing.                                                                ##
## - sets many directories and file names                                     ##
## - also loads several helper functions used by various land use processing  ##
##   scripts                                                                  ##
source("landuse_setup.R")
################################################################################


################################################################################
## Load GADM data and check if global                                         ##
## GADM is used to assign grid cells to administrative areas. The files       ##
## gadmborder_file and gadmlevel_file are generated by scripts in ../gadm so  ##
## make sure to run these first.                                              ##
cat(
    "Loading gridded GADM administrative unit data from",
    toString(sQuote(c(gadmborder_file, gadmlevel_file))), "\n"
)
gadmborder_raster <- raster(gadmborder_file)
gadmlevel_raster <- brick(gadmlevel_file)
gadmlevel_names <- read.csv(
  gadmlevel_names_file,
  stringsAsFactors = FALSE,
  comment.char = "#"
)
rows <- which(!is.na(gadmlevel_names$level0_ID))
cols <- c("level0_ID", "level0_code", "country")
gadm_country_names <- gadmlevel_names[rows, cols]

for (rastercheck in c("gadmlevel_raster", "gadmborder_raster")) {
  tmpraster <- get(rastercheck)
  if (matching_extent(
    extent(tmpraster),
    global_extent,
    xres(tmpraster),
    yres(tmpraster)
  )) {
    tmpraster <- setExtent(tmpraster, global_extent)
  }
  assign(rastercheck, tmpraster)
  if (!matching_extent(
    extent(gadm_raster),
    extent(tmpraster),
    xres(gadm_raster),
    yres(gadm_raster)
  )) {
    stop(
      sQuote(gadmlevel_file), " and ",
      sQuote(get(sub("_raster", "_file", rastercheck))),
      " have different spatial extent."
    )
  }
  if (any(res(gadm_raster) != res(tmpraster))) {
    stop(
      sQuote(gadmlevel_file), " and ",
      sQuote(get(sub("_raster", "_file", rastercheck))),
      " have different resolution."
    )
  }
  rm(tmpraster)
}
################################################################################


################################################################################
## Load some FAOSTAT definitions and do some checks before processing.        ##
# Check if datasets are absolute areas or fractions (units defined in
# landuse_setup.R)
hyde_is_fraction <- !ud.are.convertible(hyde_area_units, "m2")
monfreda_is_fraction <- !ud.are.convertible(monfreda_area_units, "m2")
fao_is_fraction <- !ud.are.convertible(fao_area_units, "m2")
ramankutty_is_fraction <- !ud.are.convertible(ramankutty_units, "m2")
# Load various FAOSTAT definitions (source files defined in landuse_setup.R)
cat(
  "FAOSTAT crop item definitions loaded from:",
  sQuote(fao_production_item_group_file), "\n"
)
fao_production_item_group_def <- fread(
  fao_production_item_group_file,
  na.strings = "...",
  # country code for Namibia is "NA", which would normally be converted into NA
  check.names = TRUE,
  data.table = FALSE,
  header = TRUE
)
# Changes in country definitions over time
cat(
  "FAO country definitions loaded from:",
  toString(
    sQuote(
      c(fao_production_country_file, fao_production_country_group_file,
        fao_landuse_country_file, fao_landuse_country_group_file)
    )
  ),
  "\n"
)
fao_production_country_def <- fread(
  fao_production_country_file,
  na.strings = "...",
  # country code for Namibia is "NA", which would normally be converted into NA
  check.names = TRUE,
  data.table = FALSE,
  header = TRUE
)
fao_production_country_group_def <- fread(
  fao_production_country_group_file,
  na.strings = "...",
  # country code for Namibia is "NA", which would normally be converted into NA
  check.names = TRUE,
  data.table = FALSE,
  header = TRUE
)
fao_landuse_country_def <- fread(
  fao_landuse_country_file,
  na.strings = "...",
  # country code for Namibia is "NA", which would normally be converted into NA
  check.names = TRUE,
  data.table = FALSE,
  header = TRUE
)
fao_landuse_country_group_def <- fread(
  fao_landuse_country_group_file,
  na.strings = "...",
  # country code for Namibia is "NA", which would normally be converted into NA
  check.names = TRUE,
  data.table = FALSE,
  header = TRUE
)

# FAO to GADM country mapping
cat("FAO to GADM mapping:", toString(sQuote(fao_gadm_mapping_file)), "\n")
for (filename in fao_gadm_mapping_file) {
  source(filename)
}
# Clean encoding
message("Converting special characters read from text files if necessary.")
for (table in c(
  "fao_production_country_def",
  "fao_production_item_group_def",
  "gadm_country_names",
  "gadmlevel_names",
  "crop_type_mapping",
  "fao_production_country_group_def",
  "fao_landuse_country_def",
  "fao_landuse_country_group_def"
)) {
  table_data <- get(table)
  for (c in colnames(table_data)) {
    if (typeof(table_data[, c]) == "character") {
      if (!all(stri_enc_isascii(table_data[, c]), na.rm = TRUE)) {
        # String has non-ASCII characters
        if (!all(stri_enc_isutf8(table_data[, c]), na.rm = TRUE)) {
          # String has non-UTF8 characters -> assume windows-1252 encoding and
          # convert to UTF-8
          message(
            "Converting column ", sQuote(c),
            " from windows-1252 to UTF-8 encoding in ",
            table
          )
          table_data[, c] <- stri_encode(
            table_data[, c],
            "windows-1252",
            "UTF-8"
          )
        }
        # Convert UTF-8 strings to ASCII strings, if necessary translating
        # special characters
        message(
          "Converting column ", sQuote(c),
          " from UTF-8 to ASCII encoding in ",
          table
        )
        table_data[, c] <- stri_encode(table_data[, c], "UTF-8", "UTF-8")
        table_data[, c] <- stri_trans_general(table_data[, c], "latin-ascii")
      }
    }
  }
  assign(table, table_data)
}
# Load preprocessed FAOSTAT data generated by read_FAOSTAT.R
cat(
  "Loading FAOSTAT data read by read_FAOSTAT.R from:",
  toString(sQuote(c(fao_production_RData, fao_landuse_RData))), "\n"
)
load(fao_production_RData)
load(fao_landuse_RData)

# Check consistency between names in RData files and definitions files
if (length(
  which(!production_countries$CODE %in% fao_production_country_def$Country.Code)
) > 0) {
  stop(
    "Countries in ",
    sQuote(fao_production_RData),
    " do not match countries in fao_production_country_def.\n",
    "This should normally be covered by read_FAOSTAT.R"
  )
}
index <- match(
  production_countries$CODE,
  fao_production_country_def$Country.Code
)
if (any(
  production_countries$NAME != fao_production_country_def$Country[index]
)) {
  stop(
    "Countries in ", sQuote(fao_production_RData),
    " do not match countries in fao_production_country_def.\n",
    "This should normally be covered by read_FAOSTAT.R"
  )
}
if (length(
  which(!landuse_countries$CODE %in% fao_landuse_country_def$Country.Code)
) > 0) {
  stop(
    "Countries in ", sQuote(fao_landuse_RData),
    " do not match countries in fao_landuse_country_def.\n",
    "This should normally be covered by read_FAOSTAT.R"
  )
}
index <- match(landuse_countries$CODE, fao_landuse_country_def$Country.Code)
if (any(landuse_countries$NAME != fao_landuse_country_def$Country[index])) {
  stop(
    "Countries in ", sQuote(fao_landuse_RData),
    " do not match countries in fao_production_country_def.\n",
    "This should normally be covered by read_FAOSTAT.R"
  )
}

missing <- which(
  !production_items$CODE %in% fao_production_item_group_def$Item.Code &
  !production_items$CODE %in% fao_production_item_group_def$Item.Group.Code
)
if (length(missing) > 0) {
  warning(
    "The following ", length(missing), " crops in production_data",
    " are missing fao_production_item_group_def: ",
    toString(production_items$NAME[missing]),
    call. = FALSE,
    immediate. = TRUE
  )
  if (any(
    production_array[, production_items$NAME[missing], "Area harvested", ] > 0,
    na.rm = TRUE
  )) {
    message("Some of them have harvested areas.")
  } else {
    message("However, none of them contain harvested areas.")
  }
}
index <- match(production_items$CODE, fao_production_item_group_def$Item.Code)
mismatch <- which(
  production_items$CODE %in% fao_production_item_group_def$Item.Code &
  production_items$NAME != fao_production_item_group_def$Item[index]
)
if (length(mismatch) > 0) {
  stop(
    length(mismatch), " crop names in production_array",
    "do not match names in fao_production_item_group_def.\n",
    "This should be covered by read_FAOSTAT.R"
  )
}
index <- match(
  production_items$CODE,
  fao_production_item_group_def$Item.Group.Code
)
mismatch <- which(
  production_items$CODE %in% fao_production_item_group_def$Item.Group.Code &
  production_items$NAME != fao_production_item_group_def$Item.Group[index]
)
if (length(mismatch) > 0) {
  stop(
    length(mismatch), " crop group names in production_array",
    " do not match names in fao_production_item_group_def.\n",
    "This should be covered by read_FAOSTAT.R"
  )
}
# Determine country groups
fao_groups <- list()
for (group_code in intersect(
  production_countries$CODE,
  fao_production_country_group_def$Country.Group.Code
)) {
  index <- which(
    fao_production_country_group_def$Country.Group.Code == group_code
  )
  group_country_codes <- fao_production_country_group_def$Country.Code[index]
  index <- match(group_country_codes, production_countries$CODE)
  index2 <- match(
    group_country_codes,
    fao_production_country_group_def$Country.Code
  )
  group_country_names <- ifelse(
    group_country_codes %in% production_countries$CODE,
    production_countries$NAME[index],
    fao_production_country_group_def$Country[index2]
  )
  index <- match(group_code, production_countries$CODE)
  fao_groups[[production_countries$NAME[index]]] <- group_country_names
}
################################################################################

################################################################################
## Fill gaps in FAOSTAT production timeseries                                 ##
## This uses fill_timeseries() defined in helper/fill_timeseries.R            ##
## First, extend production_array if landuse_array covers more years          ##
if (length(
  setdiff(dimnames(landuse_array)[[4]], dimnames(production_array)[[4]])
) > 0) {
  years <- as.character(
    sort(
      as.integer(
        union(dimnames(landuse_array)[[4]], dimnames(production_array)[[4]])
      )
    )
  )
  production_array_filled <- production_array[, , , years]
  dimnames(production_array_filled)[[4]] <- years
} else {
  production_array_filled <- production_array
}
# production_array_gapfilling logs which cells have been gapfilled
production_array_gapfilling <- array(
  FALSE,
  dim = dim(production_array_filled)[-3],
  dimnames = dimnames(production_array_filled)[-3]
)
# Informative print statements are logged to text file
logfile <- paste0(
  "gapfilling_FAOSTAT_country_level",
  ifelse(
    exists("fao_version_string") && nchar(fao_version_string) > 0,
    paste0("_", fao_version_string),
    ""
  ),
  ".txt"
)

logfile <- ifelse(
  nchar(landuse_dir) > 0,
  file.path(
    landuse_dir,
    "tmp",
    logfile
  ),
  file.path(
    "tmp",
    logfile
  )
)
cat(
  "Gapfilling FAOSTAT production timeseries. See", sQuote(logfile),
  "for details.\n"
)
sink(file = logfile)
# Only gap-fill countries, not country groups
for (country in setdiff(
  dimnames(production_array_filled)[[1]],
  names(fao_groups)
)) {
  cat("*** Gap-filling FAOSTAT production data for", sQuote(country), "***\n")
  if (country %in% dimnames(landuse_array)[[1]]) {
    cropland <- fill_timeseries(landuse_array[country, "Cropland", "Area", ])
    for (crop in 1:dim(production_array)[2]) {
      index <- match(
        dimnames(production_array)[[2]][crop],
        production_items$NAME
      )
      if (production_items$CODE[index] > 1000) {
        # Item codes > 1000 are for groups
        # Skip summed groups (such as Cereals,Total)
        next
      }
      years <- dimnames(production_array_filled)[[4]]
      production_array_filled[country, crop, "Area harvested", ] <-
        fill_timeseries(
          production_array_filled[country, crop, "Area harvested", ],
          cropland,
          dimnames(production_array)[[2]][crop]
        )
      index <- which(
        production_array_filled[country, crop, "Area harvested", ] !=
          production_array[country, crop, "Area harvested", years]
      )
      production_array_gapfilling[country, crop, index] <- TRUE
      index <- which(
        is.na(production_array[country, crop, "Area harvested", years]) &
        !is.na(production_array_filled[country, crop, "Area harvested", ])
      )
      production_array_gapfilling[country, crop, index] <- TRUE
    }
  }
}
sink()

# Update country groups based on gap-filled countries
for (country in intersect(
  dimnames(production_array_filled)[[1]],
  names(fao_groups)
)) {
  group_country_names <- intersect(
    dimnames(production_array_filled)[[1]],
    fao_groups[[country]]
  )
  index <- setdiff(
    dimnames(production_array_filled)[[2]],
    fao_production_item_group_def$Item.Group
  )
  production_array_filled[country, index, "Area harvested", ] <-
    ifelse(
      apply(
        production_array_filled[group_country_names, index, "Area harvested", ],
        c(2, 3),
        function(indata) all(is.na(indata))
      ),
      NA,
      apply(
        production_array_filled[group_country_names, index, "Area harvested", ],
        c(2, 3),
        sum,
        na.rm = TRUE
      )
    )
  # Set gapfilling to TRUE if any country in the country group is gap-filled
  production_array_gapfilling[country, index, ] <- apply(
    production_array_gapfilling[group_country_names, index, ],
    c(2, 3),
    any,
    na.rm = TRUE
  )
}
################################################################################

################################################################################
## Fix Cyprus in fao_production_country_def and production and landuse data.  ##
## At the time of development, FAOSTAT does not include Northern Cyprus.      ##
## If fix_cyprus == TRUE (which is set in landuse_setup.R) both parts of      ##
## Cyprus are added to FAOSTAT data. See also information about this flag in  ##
## landuse_setup.R.                                                           ##
if (fix_cyprus) {
  cat("**** Fix for Cyprus ****\n")
  # Check and update fao_production_country_def if necessary
  if (length(
    grep("Cyprus", fao_production_country_def$Country, ignore.case = TRUE)
  ) == 1) {
    # Only one Cyprus in fao_production_country_def
    if (length(
      grep("Cyprus", names(fao_gadm_country_mapping), ignore.case = TRUE)
    ) > 1) {
      # More than one Cyprus in fao_gadm_country_mapping
      # Set Cyprus in fao_production_country_def to end in 1974
      cat("Setting End.Year for 'Cyprus' to 1974\n")
      index <- which(fao_production_country_def$Country == "Cyprus")
      fao_production_country_def[index, "End.Year"] <- 1974
      # Determine Cyprus entries to add to fao_production_country_def
      index <- which(
        grepl("Cyprus", names(fao_gadm_country_mapping), ignore.case = TRUE) &
        names(fao_gadm_country_mapping) != "Cyprus"
      )
      add_countries <- names(fao_gadm_country_mapping)[index]
      # Add entries to fao_production_country_def with start year 1975
      for (country in add_countries) {
        fao_production_country_def <- rbind(
          fao_production_country_def,
          rep(NA, ncol(fao_production_country_def))
        )
        index <- nrow(fao_production_country_def)
        fao_production_country_def[index, "Country"] <- country
        fao_production_country_def[index, "Start.Year"] <- 1975
        fao_production_country_def[index, "ISO3.Code"] <-
          fao_gadm_country_mapping[[country]][1]
      }
      cat(
        "Setting Start.Year for new countries",
        toString(shQuote(add_countries)),
        "to 1975\n"
      )
    }
  }
  # Check and update production data if necessary
  if (length(
    grep("Cyprus", dimnames(production_array)[[1]], ignore.case = TRUE)
  ) < 2) {
    if (length(
      grep("Cyprus", names(fao_gadm_country_mapping), ignore.case = TRUE)
    ) > 1) {
      # One Cyprus in production_array, more than one in country mapping, add
      # to production_array
      cat(
        "Adding",
        toString(
          sQuote(
            setdiff(
              grep(
                "Cyprus",
                names(fao_gadm_country_mapping),
                value = TRUE,
                ignore.case = TRUE
              ),
              production_countries$NAME
            )
          )
        ),
        "to FAOSTAT production data\n"
      )
      # Expand production_array
      index <- match(
        c(dimnames(production_array)[[1]],
          setdiff(
            grep(
              "Cyprus",
              names(fao_gadm_country_mapping),
              value = TRUE,
              ignore.case = TRUE
            ),
            dimnames(production_array)[[1]]
          )
        ),
        dimnames(production_array)[[1]]
      )
      production_array <- production_array[index, , , ]
      # Add names for new entries to production_array
      index <- which(is.na(dimnames(production_array)[[1]]))
      dimnames(production_array)[[1]][index] <- setdiff(
        grep(
          "Cyprus",
          names(fao_gadm_country_mapping),
          value = TRUE,
          ignore.case = TRUE
        ),
        dimnames(production_array)[[1]]
      )
      # Expand production_array_filled
      index <- match(
        c(dimnames(production_array_filled)[[1]],
          setdiff(
            grep(
              "Cyprus",
              names(fao_gadm_country_mapping),
              value = TRUE,
              ignore.case = TRUE
            ),
            dimnames(production_array_filled)[[1]]
          )
        ),
        dimnames(production_array_filled)[[1]]
      )
      production_array_filled <- production_array_filled[index, , , ]
      # Add names for new entries in production_array_filled
      index <- which(is.na(dimnames(production_array_filled)[[1]]))
      dimnames(production_array_filled)[[1]][index] <- setdiff(
        grep(
          "Cyprus",
          names(fao_gadm_country_mapping),
          value = TRUE,
          ignore.case = TRUE
        ),
        dimnames(production_array_filled)[[1]]
      )
      # Expand production_array_gapfilling
      production_array_gapfilling <- abind(
        production_array_gapfilling,
        # Initialize new entries with FALSE
        array(FALSE,
              dim = c(
                nrow(production_array_filled) -
                  nrow(production_array_gapfilling),
                dim(production_array)[c(2, 4)]
              ),
              dimnames = list(
                setdiff(
                  dimnames(production_array_filled)[[1]],
                  dimnames(production_array_gapfilling)[[1]]
                ),
                NULL,
                NULL
              )
        ),
        along = 1
      )
      # Update data. Use "Cyprus" data after 1974 for Southern Cyprus. Assume
      # no data available for Northern Cyprus.
      index <- which(fao_production_country_def$Country == "Cyprus")
      if ("Cyprus_Southern" %in% dimnames(production_array)[[1]]) {
        years <- which(
          as.integer(dimnames(production_array)[[4]]) >
          fao_production_country_def$End.Year[index]
        )
        cat(
          "Assuming that FAOSTAT production data for 'Cyprus' refers to",
          "'Southern Cyprus' after",
          fao_production_country_def$End.Year[index], "\n"
        )
        production_array["Cyprus_Southern", , , years] <-
          production_array["Cyprus", , , years]
        # Set Cyprus to NA after 1974 to avoid any double accounting
        production_array["Cyprus", , , years] <- NA
      }
      # Same for production_array_filled and production_array_gapfilling
      if ("Cyprus_Southern" %in% dimnames(production_array_filled)[[1]]) {
        years <- which(
          as.integer(dimnames(production_array_filled)[[4]]) >
          fao_production_country_def$End.Year[index]
        )
        production_array_filled["Cyprus_Southern", , , years] <-
          production_array_filled["Cyprus", , , years]
        production_array_filled["Cyprus", , , years] <- NA
        years <- which(
          as.integer(dimnames(production_array_gapfilling)[[3]]) >
          fao_production_country_def$End.Year[index]
        )
        production_array_gapfilling["Cyprus_Southern", , years] <-
          production_array_gapfilling["Cyprus", , years]
        production_array_gapfilling["Cyprus", , years] <- FALSE
      }
    }
  }
  # Check and update landuse data if necessary
  if (length(
    grep("Cyprus", dimnames(landuse_array)[[1]], ignore.case = TRUE)
  ) < 2) {
    if (length(
      grep("Cyprus", names(fao_gadm_country_mapping), ignore.case = TRUE)
    ) > 1) {
      cat(
        "Adding",
        toString(
          sQuote(
            setdiff(
              grep(
                "Cyprus",
                names(fao_gadm_country_mapping),
                value = TRUE,
                ignore.case = TRUE
              ),
              landuse_countries$NAME
            )
          )
        ),
        "to FAOSTAT landuse data\n"
      )
      # Expand landuse_array
      save_dimnames <- dimnames(landuse_array)
      index <- match(
        c(
          dimnames(landuse_array)[[1]],
          setdiff(
            grep(
              "Cyprus",
              names(fao_gadm_country_mapping),
              value = TRUE,
              ignore.case = TRUE
            ),
            dimnames(landuse_array)[[1]]
          )
        ),
        dimnames(landuse_array)[[1]]
      )
      landuse_array <- landuse_array[index, , , ]
      index <- which(is.na(dimnames(landuse_array)[[1]]))
      dimnames(landuse_array)[[1]][index] <- setdiff(
        grep(
          "Cyprus",
          names(fao_gadm_country_mapping),
          value = TRUE,
          ignore.case = TRUE
        ),
        dimnames(landuse_array)[[1]]
      )
      save_dimnames[[1]] <- dimnames(landuse_array)[[1]]
      if (length(dim(landuse_array)) < length(save_dimnames)) {
        dim(landuse_array) <- sapply(save_dimnames, length)
        dimnames(landuse_array) <- save_dimnames
      }
      # Use "Cyprus" data after 1974 for Southern Cyprus.
      if ("Cyprus_Southern" %in% dimnames(landuse_array)[[1]]) {
        index <- which(fao_production_country_def$Country == "Cyprus")
        cat(
          "Assuming that FAOSTAT landuse data for 'Cyprus' refers to",
          "'Southern Cyprus' after",
          fao_production_country_def$End.Year[index], "\n"
        )
        years <- which(as.integer(dimnames(landuse_array)[[4]]) >
          fao_production_country_def$End.Year[index]
        )
        landuse_array["Cyprus_Southern", , , years] <-
          landuse_array["Cyprus", , , years]
        # Set Cyprus to NA after 1974 to avoid double accounting
        landuse_array["Cyprus", , , years] <- NA
      }
    }
  }
}
################################################################################

################################################################################
## Check and update country mapping                                           ##
# Country groups
cat("*** Filling country groups in FAOSTAT to GADM country mapping ***\n")
cat("Country groups derived from fao_production_country_group_def\n")
for (country in names(fao_groups)) {
  cat("Filling", sQuote(country), "in GADM country list\n")
  fao_gadm_country_mapping[[country]] <- unique(
    unlist(fao_gadm_country_mapping[fao_groups[[country]]])
  )
}
cat("*** Countries with more or less than one spatial unit in mapping: ***\n")
cat("++ GADM ++\n")
for (country in setdiff(
  names(which(sapply(fao_gadm_country_mapping, length) > 1)),
  names(fao_groups)
)) {
  index <- match(
    fao_gadm_country_mapping[[country]],
    gadm_country_names$level0_code
  )
  cat(
    "FAO country", sQuote(country), "consists of",
    length(fao_gadm_country_mapping[[country]]),
    "GADM units:",
    toString(sQuote(gadm_country_names$country[index])), "\n"
  )
}
# Check if all GADM codes are in fao_gadm_country_mapping. If not, you may want
# to update helper/fao_gadm_country_mapping.R
mismatch <- which(!gadm_country_names$level0_code %in%
  unlist(fao_gadm_country_mapping)
)
if (length(mismatch) > 0) {
  cat(
    "The following GADM units have no corresponding FAO country:",
    toString(sQuote(gadm_country_names$country[mismatch])), "\n"
  )
  if ("World" %in% names(fao_gadm_country_mapping)) {
    cat("Adding them to FAO country group 'World'\n")
    fao_gadm_country_mapping[["World"]] <- c(
      fao_gadm_country_mapping[["World"]],
      gadm_country_names$level0_code[mismatch]
    )
  }
}
# Remove potential duplicates in fao_gadm_country_mapping. There are currently
# some duplicates in fao_gadm_country_mapping.R because FAOSTAT renamed some
# countries recently and we keep old names for backwards compatibility.
for (country in intersect(
  intersect(
    setdiff(
      # Country names in fao_gadm_country_mapping missing in
      # fao_production_country_def
      names(fao_gadm_country_mapping),
      fao_production_country_def$Country
    ),
    setdiff(
      # Country name in fao_gadm_country_mapping missing in
      # production_array_filled
      names(fao_gadm_country_mapping),
      dimnames(production_array_filled)[[1]]
    )
  ),
  setdiff(
    # Country names in fao_gadm_country_mapping missing in landuse_array
    names(fao_gadm_country_mapping),
    dimnames(landuse_array)[[1]]
  )
)) {
  # Find any entries in fao_gadm_country_mapping that are identical to country
  duplicate <- which(
    sapply(
      fao_gadm_country_mapping[-match(country, names(fao_gadm_country_mapping))],
      identical,
      y = fao_gadm_country_mapping[[country]]
    )
  )
  if (length(duplicate) > 0) {
    cat(
      "Removing", sQuote(country),
      "from fao_gadm_country_mapping because it seems to be a duplicate of",
      toString(sQuote(names(duplicate))), "\n"
    )
    fao_gadm_country_mapping[[country]] <- NULL
    # Also remove from compound_countries
    compound_countries <- sapply(compound_countries, setdiff, y = country)
  }
}
# Now check again for duplicates (that are not in FAOSTAT)
for (country in names(fao_gadm_country_mapping)) {
  duplicate <- which(
    sapply(
      fao_gadm_country_mapping[-match(country, names(fao_gadm_country_mapping))],
      identical,
      y = fao_gadm_country_mapping[[country]]
    )
  )
  if (length(duplicate) > 0) {
    warning(
      sQuote(country), " seems to be a duplicate of ",
      toString(sQuote(names(duplicate))), " in fao_gadm_country_mapping",
      call. = FALSE,
      immediate. = TRUE
    )
  }
}
# Check that all countries in production data and landuse data have
# corresponding entry in fao_gadm_country_mapping.
mismatch <- setdiff(
  union(
    dimnames(production_array_filled)[[1]],
    dimnames(landuse_array)[[1]]
  ),
  names(fao_gadm_country_mapping)
)
if (length(mismatch) > 0) {
  stop(
    "The following FAOSTAT countries have no corresponding entry in ",
    "fao_gadm_country_mapping: ",
    toString(sQuote(mismatch))
  )
  # helper/fao_gadm_country_mapping.R needs to be updated to list all FAOSTAT
  # countries. This could just mean that FAOSTAT has renamed a country or
  # actually added new countries.
}
################################################################################

################################################################################
## Fill in compound countries in production data that split into smaller      ##
## countries at some point in time.                                           ##
cat("*** Process countries that cease to exist at some point in time ***\n")
# Index of countries with end year in fao_production_country_def
index <- which(!is.na(fao_production_country_def[, "End.Year"]))
# Matching country index in production_countries
index2 <- match(
  intersect(
    production_countries$CODE,
    fao_production_country_def[index, "Country.Code"]
  ),
  production_countries$CODE
)
for (country in production_countries$NAME[index2]) {
  # Check if country is included in compound_countries defined in
  # helper/fao_compound_countries.R
  if (country %in% names(compound_countries)) {
    # Check whether successor countries defined in compound_countries are
    # present in FAOSTAT production data
    clist <- intersect(
      compound_countries[[country]],
      dimnames(production_array)[[1]]
    )
    if (length(clist) > 1) {
      index <- which(fao_production_country_def[, "Country"] == country)
      cat(
        "Filling production_array for", sQuote(country),
        "with data from",
        toString(sQuote(compound_countries[[country]])),
        "after", fao_production_country_def[index, "End.Year"], "\n"
      )
      # Check whether all successor countries are in FAOSTAT
      if (length(clist) < length(compound_countries[[country]])) {
        cat(
          "Warning: Only", length(clist), "of",
          length(compound_countries[[country]]),
          "successor countries included in production_array\n"
        )
      }
      # Fill years after country's end with sum of successor countries
      after_country_years <- which(as.integer(dimnames(production_array)[[4]]) >
        fao_production_country_def[index, "End.Year"]
      )
      production_array[country, , , after_country_years] <- ifelse(
        apply(
          is.na(production_array[clist, , , after_country_years]),
          c(2, 3, 4),
          all
        ),
        # If all countries have NA values, set to NA
        NA,
        # Otherwise sum up values across countries
        apply(
          production_array[clist, , , after_country_years],
          c(2, 3, 4),
          sum,
          na.rm = TRUE
        )
      )
    } else {
      # Successor countries according to compound_countries not in FAOSTAT
      index <- which(fao_production_country_def$Country.Code ==
        production_countries$CODE[which(production_countries$NAME == country)]
      )
      cat(
        "Warning:", sQuote(country), "is listed as ceasing to exist in",
        fao_production_country_def[index, "End.Year"],
        "but only", length(clist), "of its",
        length(compound_countries[[country]]),
        "successor countries are part of production_array. Cannot fill.\n"
      )
    }
    # Do the same as above for production_array_filled
    clist <- intersect(
      compound_countries[[country]],
      dimnames(production_array_filled)[[1]]
    )
    if (length(clist) > 1) {
      index <- which(fao_production_country_def[, "Country"] == country)
      cat(
        "Filling production_array_filled for", sQuote(country),
        "with data from",
        toString(sQuote(compound_countries[[country]])),
        "after", fao_production_country_def[index, "End.Year"], "\n"
      )
      if (length(clist) < length(compound_countries[[country]])) {
        cat(
          "Warning: Only", length(clist), "of",
          length(compound_countries[[country]]),
          "successor countries included in production_array_filled\n"
        )
      }
      after_country_years <- which(
        as.integer(dimnames(production_array_filled)[[4]]) >
        fao_production_country_def[index, "End.Year"]
      )
      production_array_filled[country, , , after_country_years] <- ifelse(
        apply(
          is.na(production_array_filled[clist, , , after_country_years]),
          c(2, 3, 4),
          all
        ),
        # If all countries have NA values, set to NA
        NA,
        # Otherwise sum up values across countries
        apply(
          production_array_filled[clist, , , after_country_years],
          c(2, 3, 4),
          sum,
          na.rm = TRUE
        )
      )
      # Do the same as above for production_array_gapfilling
      after_country_years <- which(
        as.integer(dimnames(production_array_gapfilling)[[3]]) >
        fao_production_country_def[index, "End.Year"]
      )
      clist <- intersect(
        compound_countries[[country]],
        dimnames(production_array_gapfilling)[[1]]
      )
      production_array_gapfilling[country, , after_country_years] <- apply(
        production_array_gapfilling[clist, , after_country_years],
        c(2, 3),
        any
      )
      rm(after_country_years)
    } else {
      # Successor countries according to compound_countries missing in FAOSTAT
      index <- which(fao_production_country_def$Country.Code ==
        production_countries$CODE[which(production_countries$NAME == country)]
      )
      cat(
        "Warning:", sQuote(country), "is listed as ceasing to exist in",
        fao_production_country_def[index, "End.Year"],
        "but only", length(clist), "of its",
        length(compound_countries[[country]]),
        "successor countries are part of production_array_filled.",
        "Cannot fill.\n"
      )
    }
  } else {
    # FAOSTAT lists country as ceasing to exist but it is missing in
    # compound_countries. You may need to update compound_countries.
    index <- which(fao_production_country_def$Country.Code ==
      production_countries$CODE[which(production_countries$NAME == country)]
    )
    cat(
      "Warning:", sQuote(country),
      "is missing in compound_countries but is listed in FAOSTAT as ceasing",
      "to exist in", fao_production_country_def[index, "End.Year"], "\n"
    )
  }
}
# Fill in compound countries in landuse data that split into smaller countries
# at some point in time.
# Countries with end year in fao_landuse_country_def
index <- which(!is.na(fao_landuse_country_def[, "End.Year"]))
# Matching index in landuse_countries
index2 <- match(
  intersect(
    landuse_countries$CODE,
    fao_landuse_country_def[index, "Country.Code"]
  ),
  landuse_countries$CODE
)
for (country in landuse_countries$NAME[index2]) {
  if (country %in% names(compound_countries)) {
    clist <- intersect(
      compound_countries[[country]],
      dimnames(landuse_array)[[1]]
    )
    if (length(clist) > 1) {
      # (Some) successor countries are in landuse_array
      index <- which(fao_landuse_country_def[, "Country"] == country)
      cat(
        "Filling landuse data for", sQuote(country),
        "with data from", toString(sQuote(compound_countries[[country]])),
        "after", fao_landuse_country_def[index, "End.Year"], "\n"
      )
      # Check if all successor countries are in landuse_array
      if (length(clist) < length(compound_countries[[country]])) {
        cat(
          "Warning: Only", length(clist),
          "of", length(compound_countries[[country]]),
          "successor countries included in landuse_array.\n"
        )
      }
      # Fill years after country's end with sum of successor countries
      after_country_years <- which(as.integer(dimnames(landuse_array)[[4]]) >
        fao_landuse_country_def[index, "End.Year"]
      )
      landuse_array[country, , , after_country_years] <- ifelse(
        apply(
          is.na(landuse_array[clist, , , after_country_years]),
          c(2, 3), all),
          # If all countries have NA values, set to NA
          NA,
          # Otherwise sum up values across countries
          apply(
            landuse_array[clist, , , after_country_years],
            c(2, 3),
            sum,
            na.rm = TRUE
          )
      )
      rm(after_country_years)
    } else {
      # Successor countries are missing in landuse_array
      index <- which(fao_landuse_country_def$Country.Code ==
        landuse_countries$CODE[which(landuse_countries$NAME == country)]
      )
      cat(
        "Warning:", sQuote(country),
        "is listed as ceasing to exist in",
        fao_landuse_country_def[index, "End.Year"],
        "but only", length(clist), "of its",
        length(compound_countries[[country]]),
        "successor countries are part of landuse data. Cannot fill.\n"
      )
    }
  } else {
    # landuse_array has countries ceasing to exist that are missing in
    # compound_countries
    index <- which(fao_landuse_country_def$Country.Code ==
      landuse_countries$CODE[which(landuse_countries$NAME == country)]
    )
    cat(
      "Warning:", sQuote(country),
      "is missing in compound_countries but is listed as ceasing to exist in",
      fao_landuse_country_def[index, "End.Year"],
      "in FAOSTAT\n"
    )
  }
}
################################################################################

################################################################################
## Update FAOSTAT production groups (item groups which contain the sum of     ##
## several crops).                                                            ##
cat(
  "**** Updating group sums in FAOSTAT production data after",
  "gap-filling of harvested areas ****\n"
)
fao_production_item_group_def_usable <- character(0)
for (group in unique(fao_production_item_group_def$Item.Group)) {
  if (!group %in% dimnames(production_array_filled)[[2]]) {
    next
  }
  index <- which(fao_production_item_group_def$Item.Group == group)
  crops <- intersect(
    dimnames(production_array_filled)[[2]],
    fao_production_item_group_def$Item[index]
  )
  # Check that group entries are equal to crop sums in original data
  # Difference between group entry and sum of crops less than 1% and less than
  # 10 inconsistencies
  tmpcountries <- setdiff(dimnames(production_array)[[1]], names(fao_groups))
  group_sums <- apply(
    production_array[tmpcountries, crops, "Area harvested", ],
    c(1, 3),
    sum,
    na.rm = TRUE
  )
  group_data <- production_array[tmpcountries, group, "Area harvested", ]
  incon <- which(!is.na(group_data) &
    (group_data < 0.99 * group_sums | group_data > 1.01 * group_sums) &
    abs(group_data - group_sums) > 2
  )
  if (length(incon) > 10) {
    cat(
      "Entries for group", sQuote(group),
      "are inconsistent with sum of individual crops in", length(incon),
      "cases before gap filling. Not updating group sums in gap-filled data.",
      "Use group entries with care.\n"
    )
  } else {
    production_array_filled[tmpcountries, group, "Area harvested", ] <- ifelse(
      apply(
        production_array_filled[tmpcountries, crops, "Area harvested", ],
        c(1, 3),
        function(indata) return(any(!is.na(indata)))
      ),
      apply(
        production_array_filled[tmpcountries, crops, "Area harvested", ],
        c(1, 3),
        sum,
        na.rm = TRUE
      ),
      NA
    )
    # Set gap-filling of group to TRUE if any crop in that group is gap-filled
    production_array_gapfilling[tmpcountries, group, ] <- apply(
      production_array_gapfilling[tmpcountries, crops, ],
      c(1, 3),
      any
    )
    cat("Group", sQuote(group), "updated\n")
    fao_production_item_group_def_usable <- c(
      fao_production_item_group_def_usable,
      group
    )
  }
  rm(tmpcountries)
}
################################################################################

################################################################################
## Load HYDE area and aggregate to GADM resolution if necessary               ##
hyde_area <- load_hyde_area(
  filename = hyde_area_file,
  fileunits = hyde_area_file_units,
  faounits = fao_area_units, # output area unit of function
  unitraster = gadm_raster, # output resolution of function
  gextent = global_extent
)
hyde_area_file_units <- hyde_area$unit
# Aggregation factor from native HYDE resolution to GADM resolution
hyde2gadm <- hyde_area$hyde2gadm
hyde_area <- hyde_area$area
################################################################################

################################################################################
## Load Ramankutty cropland                                                   ##
## This is the cropland dataset used in the creation of Monfreda.             ##
# Check matching extent and, if necessary, convert from fraction to absolute
# areas.
if (file.exists(ramankutty_cropland_file)) {
  cat("Loading Ramankutty cropland from", sQuote(ramankutty_cropland_file), "\n")
  ramankutty_cropland <- raster(ramankutty_cropland_file)
} else {
  stop(
    "Ramankutty cropland file does not exist.",
    "\nPlease check 'ramankutty_cropland_file' in landuse_setup.R"
  )
}
if (matching_extent(
  extent(ramankutty_cropland),
  global_extent,
  xres(ramankutty_cropland),
  yres(ramankutty_cropland)
)) {
  ramankutty_cropland <- setExtent(ramankutty_cropland, global_extent)
}
# Unit conversion of Ramankutty cropland to Monfreda area unit or fao_area_units
# if Monfreda area unit is also fractional
if (ramankutty_is_fraction) {
  # Fractional unit, multiply with area. Check HYDE area for compatibility
  if (matching_extent(
    extent(ramankutty_cropland),
    extent(hyde_area),
    xres(ramankutty_cropland),
    yres(ramankutty_cropland)
  )) {
    if (all(res(ramankutty_cropland) == res(hyde_area))) {
      cat(
        "Using hyde_area for ramankutty_cropland because they share the same",
        "extent and resolution\n"
      )
      # Convert to fao_area_units using HYDE area
      values(ramankutty_cropland) <- values(ramankutty_cropland) *
        ud.convert(1, ramankutty_units, "") * values(hyde_area)
      ramankutty_units <- hyde_area_file_units
    } else {
      # Ramankutty cropland has different resolution from HYDE area.
      # Generate cell area.
      cat(
        "Generating area for ramankutty_cropland based on raster",
        "characteristics because Ramankutty resolution differs from other",
        "gridded data. Using cellarea() function from helper_functions.R\n"
      )
      # Calculate cell areas for latitude coordinates
      ysize <- cellarea(
        yFromRow(ramankutty_cropland),
        xres(ramankutty_cropland),
        yres(ramankutty_cropland)
      )
      # Unit conversion from m2 returned by cellarea() to Monfreda area unit or
      # (if that is fractional) to FAOSTAT area unit
      target_unit <- ifelse(
        monfreda_is_fraction,
        fao_area_units,
        monfreda_area_units
      )
      ysize <- ud.convert(ysize, "m2", target_unit)
      # Expand to full grid
      gridsize <- rep(ysize, each = ncol(ramankutty_cropland))

      values(ramankutty_cropland) <- values(ramankutty_cropland) *
        ud.convert(1, ramankutty_units, "") * gridsize
      ramankutty_units <- target_unit
      rm(gridsize, ysize)
    }
  } else {
    # Ramankutty cropland has different spatial extent from HYDE area.
    # Generate cell area.
    cat(
      "Generating area for ramankutty_cropland based on raster",
      "characteristics because Ramankutty resolution differs from other",
      "gridded data. Using cellarea() function from helper_functions.R\n"
    )
    # Calculate cell areas for latitude coordinates
    ysize <- cellarea(
      yFromRow(ramankutty_cropland),
      xres(ramankutty_cropland),
      yres(ramankutty_cropland)
    )
    # Unit conversion from m2 returned by cellarea() to Monfreda area unit or
    # (if that is fractional) to FAOSTAT area unit
    target_unit <- ifelse(
      monfreda_is_fraction,
      fao_area_units,
      monfreda_area_units
    )
    ysize <- ud.convert(ysize, "m2", target_unit)
    # Expand to full grid
    gridsize <- rep(ysize, each = ncol(ramankutty_cropland))

    values(ramankutty_cropland) <- values(ramankutty_cropland) *
      ud.convert(1, ramankutty_units, "") * gridsize
    ramankutty_units <- target_unit
    rm(gridsize, ysize)
  }
} else {
  # Unit conversion from Ramankutty area unit to Monfreda area unit or
  # (if that is fractional) to FAOSTAT area unit
  target_unit <- ifelse(
    monfreda_is_fraction,
    fao_area_units,
    monfreda_area_units
  )
  values(ramankutty_cropland) <- values(ramankutty_cropland) *
    ud.convert(1, ramankutty_units, target_unit)
  ramankutty_units <- target_unit
}
ramankutty_is_fraction <- !ud.are.convertible(ramankutty_units, "m2")
################################################################################

################################################################################
## Aggregate Monfreda to FAO countries using GADM country mask                ##
## The resulting array has the dimensions country, crop, reference year(s)    ##
## Since grid-to-country aggregation takes quite long, results are stored in  ##
## RData file monfreda_gadm_sums_RData and not calculated again if that file  ##
## exists. Note that different versions of FAOSTAT may include different      ##
## countries so this depends on the FAOSTAT version used.                     ##
cat(
  "*** Aggregating Monfreda harvested areas to country sums using GADM",
  "country mask ***\n"
)
# Determine filenames of Monfreda source files
monfreda_filenames <- character(length(monfreda_names))
names(monfreda_filenames) <- monfreda_names
for (crop in monfreda_names) {
  tmpnames <- file.path(
    dir(
      file.path(monfreda_base, monfreda_datadir[monfreda_format]),
      pattern = paste0("^", crop, "_HarvAreaYield"),
      full.names = TRUE
    ),
    paste0(
      crop, "_",
      monfreda_file_var[[monfreda_format]][1],
      ".", monfreda_file_ext[monfreda_format]
    )
  )
  if (length(which(file.exists(tmpnames))) != 1) {
    stop(
      "Cannot determine filename for crop ", sQuote(crop), ".\n",
      "Tested filename(s): ", toString(tmpnames)
    )
  }
  monfreda_filenames[crop] <- tmpnames[which(file.exists(tmpnames))]
  rm(tmpnames)
}
# Check that extent and resolution match (including the need to aggregate
# Monfreda data)
monfreda_raster <- raster(monfreda_filenames[1])
if (matching_extent(
  extent(monfreda_raster),
  global_extent,
  xres(monfreda_raster),
  yres(monfreda_raster)
)) {
  monfreda_raster <- setExtent(monfreda_raster, global_extent)
}
# Determine aggregation factor
if (any(res(monfreda_raster) < res(gadm_raster))) {
  monfreda2gadm <- round(res(monfreda_raster) / res(gadm_raster), 4)
  if (max(monfreda2gadm %% 1) != 0) {
    stop(
      "GADM resolution ",
      toString(round(res(gadm_raster), 5)),
      " is not compatible with Monfreda resolution ",
      toString(round(res(monfreda_raster), 5))
    )
  }
  # Generate area raster corresponding to Monfreda source resolution
  cat(
    "Generating monfreda_area based on raster characteristics because",
    "Monfreda resolution differs from other gridded data. Using cellarea()",
    "function from lpjml_format_helper_functions.R\n"
  )
  monfreda_area <- raster(monfreda_raster)
  # Calculate cell areas for latitude coordinates
  ysize <- cellarea(
    yFromRow(monfreda_area),
    xres(monfreda_area),
    yres(monfreda_area)
  )
  # Unit conversion from m2 returned by cellarea() to Monfreda area unit or
  # (if that is fractional) to FAOSTAT area unit
  target_unit <- ifelse(
    monfreda_is_fraction,
    fao_area_units,
    monfreda_area_units
  )
  ysize <- ud.convert(ysize, "m2", target_unit)
  # Expand to full grid
  gridsize <- rep(ysize, each = ncol(monfreda_area))

  values(monfreda_area) <- gridsize
  monfreda_area_file_units <- target_unit
  rm(gridsize, ysize)
} else if (any(res(monfreda_raster) > res(gadm_raster))) {
  # Monfreda has coarser resolution than GADM. Generated landuse dataset cannot
  # be finer than any of the source datasets.
  stop(
    "GADM resolution ", toString(round(res(gadm_raster), 5)),
    " is too fine for Monfreda resolution ",
    toString(round(res(monfreda_raster), 5)), ".\n",
    "You need to create a gridded GADM mask at the Monfreda resolution."
  )
} else {
  # Monfreda has same resolution as GADM. Use HYDE area which has been
  # aggregated to GADM resolution above.
  monfreda2gadm <- c(1, 1)
  cat("Using HYDE area for Monfreda because they share the same resolution\n")
  # Unit conversion from HYDE area unit to Monfreda area unit or
  # (if that is fractional) to FAOSTAT area unit
  target_unit <- ifelse(
    monfreda_is_fraction,
    fao_area_units,
    monfreda_area_units
  )
  monfreda_area <- hyde_area * ud.convert(1, hyde_area_file_units, target_unit)
  monfreda_area_file_units <- target_unit
}
# monfreda_gadm_production_array contains harvested areas aggregated to
# countries.
# monfreda_gadm_quality_array contains information that is used to detect
# artefacts that result from a mismatch between GADM used here and the mask used
# to create the Monfreda dataset.
monfreda_gadm_production_array <- array(
  dim = c(
    length(fao_gadm_country_mapping),
    length(monfreda_names),
    length(monfreda_refyear)
  ),
  dimnames = list(
    names(fao_gadm_country_mapping),
    monfreda_names,
    format(monfreda_refyear, scientific = FALSE)
  )
)
monfreda_gadm_quality_array <- array(
  dim = c(dim(monfreda_gadm_production_array), 3),
  dimnames = c(
    dimnames(monfreda_gadm_production_array),
    list(c("flag_max", "fcropland", "fborder"))
  )
)
if (file.exists(monfreda_gadm_sums_RData)) {
  # Since aggregation to countries takes quite long results are saved and
  # reused if this script is run again. Delete file monfreda_gadm_sums_RData
  # if you want to force it to be calculated again.
  cat(
    "Reloading preprocessed Monfreda harvested area sums from",
    sQuote(monfreda_gadm_sums_RData), "\n"
  )
  load(monfreda_gadm_sums_RData)
} else {
  if (exists("monfreda_harvest_sum")) {
    rm(monfreda_harvest_sum)
  }
  if (exists("kapok_monfreda_filedata")) {
    rm(kapok_monfreda_filedata)
  }
  cat("Associating GADM grid cells with FAO countries\n")
  fao_gadm_country_cells <- list()
  # Extract country IDs from gadmlevel_raster
  tmpcodes <- values(subset(gadmlevel_raster, 1))
  for (country in names(fao_gadm_country_mapping)) {
    # Find ISO code(s) in gadm_country_names
    index <- match(
      fao_gadm_country_mapping[[country]],
      gadm_country_names$level0_code
    )
    # Find IDs used in gadmlevel_raster matching ISO codes
    ccodes <- gadm_country_names[index, "level0_ID"]
    # Find cell indices with matching ID
    fao_gadm_country_cells[[country]] <- which(tmpcodes %in% ccodes)
  }
  rm(tmpcodes)
  # GADM border data: Has for each cell the number of countries in it.
  # Duplicate data so that it is available for all monfreda_refyear or at least
  # two years.
  gadmborder_data <- array(
    rep(values(gadmborder_raster), max(length(monfreda_refyear), 2)),
    dim = c(ncell(gadmborder_raster), max(length(monfreda_refyear), 2))
  )
  cat(
    "Aggregating Monfreda harvested areas for",
    length(monfreda_names), "crops to",
    length(fao_gadm_country_cells),
    "FAO countries and country groups\n"
  )
  for (crop in monfreda_names) {
    if (which(monfreda_names == crop) %% 10 == 0) {
      # Status prompt every 10 crops
      cat(which(monfreda_names == crop), "of", length(monfreda_names), "\n")
    }
    if (!file.exists(monfreda_filenames[crop])) {
      warning(
        "Missing input file ",
        sQuote(monfreda_filenames[crop]),
        " for Monfreda crop ", sQuote(crop),
        call. = FALSE,
        immediate. = TRUE
      )
      next
    }
    if (!exists("monfreda_area")) {
      warning(
          "No cell area available for Monfreda. Deriving using ",
          "cellarea() function from lpjml_format_helper_functions.R",
          call. = FALSE,
          immediate. = TRUE
      )
      monfreda_area <- raster(monfreda_filenames[crop])
      # Calculate cell areas for latitude coordinates
      ysize <- cellarea(
        yFromRow(monfreda_area),
        xres(monfreda_area),
        yres(monfreda_area)
      )
      # Unit conversion from m2 returned by cellarea() to Monfreda area unit or
      # (if that is fractional) to FAOSTAT area unit
      target_unit <- ifelse(
        monfreda_is_fraction,
        fao_area_units,
        monfreda_area_units
      )
      ysize <- ud.convert(ysize, "m2", target_unit)
      # Expand to full grid
      gridsize <- rep(ysize, each = ncol(monfreda_area))
      values(monfreda_area) <- gridsize
      monfreda_area_file_units <- target_unit
      rm(gridsize, ysize)
    }
    # Function get_crop_monfreda() is defined in helper/get_crop_monfreda.R
    # This function aggregates Monfreda data to GADM resolution if necessary.
    loaded_fields <- get_crop_monfreda(
      filename = monfreda_filenames[crop],
      crop = crop,
      unit_raster = gadm_raster,
      fact = monfreda2gadm,
      area_raster = monfreda_area,
      area_units = monfreda_area_units
    )
    monfreda_filedata <- loaded_fields[["filedata"]]
    monfreda_qualitydata <- loaded_fields[["qualitydata"]]
    rm(loaded_fields)
    # If necessary, aggregate also Ramankutty cropland to GADM resolution
    if (!exists("ramankutty_gadm_cropland")) {
      target_unit <- ifelse(
        monfreda_is_fraction,
        monfreda_area_file_units,
        monfreda_area_units
      )
      if (max(monfreda2gadm) > 1) {
        # Aggregate Ramankutty cropland to GADM resolution and convert unit
        ramankutty_gadm_cropland <- aggregate(
          ramankutty_cropland,
          fact = monfreda2gadm,
          fun = sum
        ) * ud.convert(1, ramankutty_units, target_unit)
      } else {
        # Convert only unit
        ramankutty_gadm_cropland <- ramankutty_cropland *
          ud.convert(1, ramankutty_units, target_unit)
      }
    }
    # Filter very small values
    monfreda_filedata[which(monfreda_filedata < monfreda_cutoff)] <- 0
    # Kapok fix:
    # Monfreda has harvested areas for kapokfiber and kapokseed which are both
    # harvested from Kapok fruit (found in FAOSTAT)
    # Do not add them twice to monfreda_harvest_sum IF harvested areas are
    # identical (which they seem to be in the current version of Monfreda)
    skip_sum <-  FALSE
    if (grepl("kapok", crop)) {
      if (exists("kapok_monfreda_filedata")) {
        skip_sum <- identical(kapok_monfreda_filedata, monfreda_filedata)
      } else {
        kapok_monfreda_filedata <- monfreda_filedata
      }
    }
    if (skip_sum) {
      cat(
        "Not adding", sQuote(crop),
        "to monfreda_harvest_sum because it is identical to",
        sQuote(setdiff(grep("kapok", monfreda_names, value = TRUE), crop)), "\n"
      )
    }
    if (!exists("monfreda_harvest_sum")) {
      monfreda_harvest_sum <- monfreda_filedata
    } else if (!skip_sum) {
      monfreda_harvest_sum <- ifelse(
        is.na(monfreda_harvest_sum),
        # Set to monfreda_filedata if sum is still NA
        monfreda_filedata,
        ifelse(
          is.na(monfreda_filedata),
          # Keep old sum if monfreda_filedata is NA
          monfreda_harvest_sum,
          # Otherwise add values to sum
          monfreda_harvest_sum + monfreda_filedata
        )
      )
    }
    if (length(dim(monfreda_filedata)) == 2) {
      # Append dummy year to be able to use apply function and dissolve
      # separate lon and lat dimensions.
      dim(monfreda_filedata) <- c(
        ncol(monfreda_filedata) * nrow(monfreda_filedata),
        1
      )
      monfreda_filedata <- abind(
        monfreda_filedata,
        monfreda_filedata,
        along = 2
      )
      dim(monfreda_qualitydata) <- c(
        ncol(monfreda_qualitydata) * nrow(monfreda_qualitydata),
        1
      )
      monfreda_qualitydata <- abind(
        monfreda_qualitydata,
        monfreda_qualitydata, along = 2
      )
    } else {
      # Dissolve separate lon and lat dimensions.
      dim(monfreda_filedata) <- c(
        ncol(monfreda_filedata) * nrow(monfreda_filedata),
        dim(monfreda_filedata)[3]
      )
      dim(monfreda_qualitydata) <- c(
        ncol(monfreda_qualitydata) * nrow(monfreda_qualitydata),
        dim(monfreda_qualitydata)[3]
      )
    }
    # Collect some statistics used to detect possible artefacts due to
    # mismatches in country masks.
    # "flag_max" is the highest data quality flag found in the country.
    # "fcropland" is the fraction of cropland cells in the country that the crop
    # is present in.
    # "fborder" is the fraction of cells where the crop is present that are also
    # border cells (contain parts of more than one country)
    for (country in dimnames(monfreda_gadm_production_array)[[1]]) {
      if (is.null(fao_gadm_country_cells[[country]])) {
        # FAOSTAT country has no assigned GADM units, therefore no assigned
        # cells
        next
      }
      cropland_country_cells <- which(
        ramankutty_gadm_cropland[fao_gadm_country_cells[[country]]] > 0
      )
      # years is used below to remove dummy year that may have been added above
      years <- 1:ifelse(
        length(monfreda_refyear) > 1,
        dim(monfreda_qualitydata)[2],
        1
      )
      if (length(fao_gadm_country_cells[[country]]) > 1) {
        monfreda_gadm_production_array[country, crop, ] <- apply(
          monfreda_filedata[fao_gadm_country_cells[[country]], ],
          2,
          sum,
          na.rm = TRUE
        )[years]
        # Last part in [] removes dummy year that may have been added above
        # Index of Ramankutty cropland cells in GADM raster
        index <- fao_gadm_country_cells[[country]][cropland_country_cells]
        if (length(cropland_country_cells) > 1) {
          monfreda_gadm_quality_array[country, crop, , "flag_max"] <- apply(
            monfreda_qualitydata[index, ],
            2,
            max,
            names = FALSE,
            na.rm = TRUE
          )[years]
          # Last part in [] removes dummy year that may have been added above
          monfreda_gadm_quality_array[country, crop, , "fcropland"] <- apply(
            monfreda_filedata[index, ],
            2,
            function(indata) return(length(which(indata > 0)))
          )[years] / length(cropland_country_cells)
          monfreda_gadm_quality_array[country, crop, , "fborder"] <- (
            apply(# Count border cells with crop
              monfreda_filedata[fao_gadm_country_cells[[country]], ] > 0 &
              gadmborder_data[fao_gadm_country_cells[[country]], ] > 1,
              2,
              sum,
              na.rm = TRUE
            ) / apply(# Count all cells with crop
              monfreda_filedata[fao_gadm_country_cells[[country]], ] > 0,
              2,
              sum,
              na.rm = TRUE
            )
          )[years]
          # Last part in [] removes dummy year that may have been added above
        } else {
          monfreda_gadm_quality_array[country, crop, , "flag_max"] <-
            monfreda_qualitydata[index, ][years]
          # Last part in [] removes dummy year that may have been added above
          monfreda_gadm_quality_array[country, crop, , "fcropland"] <- -1
          monfreda_gadm_quality_array[country, crop, , "fborder"] <- as.integer(
            gadmborder_data[fao_gadm_country_cells[[country]], ] > 1
          )[years]
          # Last part in [] removes dummy year that may have been added above
        }
      } else if (length(fao_gadm_country_cells[[country]]) > 0) {
        monfreda_gadm_production_array[country, crop, ] <-
          monfreda_filedata[fao_gadm_country_cells[[country]], ][years]
        # Last part in [] removes dummy year that may have been added above
        monfreda_gadm_quality_array[country, crop, , "flag_max"] <-
          monfreda_qualitydata[fao_gadm_country_cells[[country]], ][years]
        # Last part in [] removes dummy year that may have been added above
        monfreda_gadm_quality_array[country, crop, , "fcropland"] <- -1
        monfreda_gadm_quality_array[country, crop, , "fborder"] <- as.integer(
          gadmborder_data[fao_gadm_country_cells[[country]], ] > 1
        )[years]
        # Last part in [] removes dummy year that may have been added above
      }
    }
  }
  # Save to RData file
  save(
    monfreda_gadm_production_array,
    monfreda_gadm_quality_array,
    ramankutty_gadm_cropland,
    monfreda_harvest_sum,
    fao_gadm_country_cells,
    monfreda_area,
    file = monfreda_gadm_sums_RData
  )
  cat(
    "Saving aggregated harvested areas to", sQuote(monfreda_gadm_sums_RData),
    "\n"
  )
}
################################################################################

################################################################################
## Match FAOSTAT harvested areas with Monfreda harvested areas at the country ##
## scale.                                                                     ##
## fao_monfreda_production_array extracts information from                    ##
## production_array_filled for the Monfreda reference years and combines it   ##
## with monfreda_gadm_production_array. Entries in Monfreda and FAOSTAT that  ##
## refer to the same crop (even if named differently) are linked together     ##
## using information in crop_type_mapping. The result is a list of crops that ##
## are found in either one or both datasets.                                  ##
## fao_monfreda_use_pattern lists for each crop and country whether to use    ##
## the Monfreda spatial pattern, i.e. whether the crop is present in Monfreda ##
## and not deemed an artefact due to mismatches in country masks.             ##
# Monfreda crops not in FAOSTAT
index <- which(
  is.na(crop_type_mapping$FAO.item.code) |
  !crop_type_mapping$FAO.item.code %in% production_items$CODE
)
fao_monfreda_production_array <- array(
  dim = c(
    length(union(names(fao_gadm_country_mapping), production_countries$NAME)),
    nrow(production_items) + length(index),
    length(monfreda_refyear),
    5
  ),
  dimnames = list(
    union(names(fao_gadm_country_mapping), production_countries$NAME),
    c(production_items$NAME, crop_type_mapping$Monfreda[index]),
    as.character(monfreda_refyear),
    c(
      "Monfreda_GADM",
      "FAOSTAT",
      "Monfreda_GADM_flag_max",
      "Monfreda_GADM_fcropland",
      "Monfreda_GADM_fborder"
    )
  )
)
# fao_monfreda_use_pattern resembles fao_monfreda_production_array except for
# last dimension
rem_dim <- length(dim(fao_monfreda_production_array))
fao_monfreda_use_pattern <- array(
  FALSE,
  dim = dim(fao_monfreda_production_array)[-rem_dim],
  dimnames = dimnames(fao_monfreda_production_array)[-rem_dim]
)
# Fill in FAOSTAT harvested areas first
index1 <- intersect(
  dimnames(production_array_filled)[[1]],
  dimnames(fao_monfreda_production_array)[[1]]
)
index2 <- intersect(
  dimnames(production_array_filled)[[2]],
  dimnames(fao_monfreda_production_array)[[2]]
)
index3 <- intersect(
  dimnames(production_array_filled)[[4]],
  dimnames(fao_monfreda_production_array)[[3]]
)
fao_monfreda_production_array[index1, index2, index3, "FAOSTAT"] <-
  production_array_filled[index1, index2, "Area harvested", index3]
if (length(index3) == 1 && length(dimnames(production_array_filled)[[4]]) > 1) {
  # Only one Monfreda year; see if FAOSTAT is > 0 in different year for cases
  # where it is 0 or NA in Monfreda reference year
  # This is only used to decide whether FAOSTAT has data for the crop at all.
  # Data is restored to actual values for the reference year later in the script
  fao_monfreda_production_array[index1, index2, , "FAOSTAT"] <- ifelse(
    fao_monfreda_production_array[index1, index2, , "FAOSTAT"] == 0 |
    is.na(fao_monfreda_production_array[index1, index2, , "FAOSTAT"]),
    # If FAOSTAT value for reference year empty
    ifelse(
      apply(
        production_array_filled[index1, index2, "Area harvested", ],
        c(1, 2),
        function(x, na.rm) any(x > 0, na.rm = na.rm),
        na.rm = TRUE
      ),
      # If any other year in FAOSTAT > 0 set to minimum value that's not zero
      apply(
        production_array_filled[index1, index2, "Area harvested", ],
        c(1, 2),
        function(indata, na.rm) {
          ifelse(
            all(is.na(indata)),
            NA,
            ifelse(
              any(indata > 0, na.rm = na.rm),
              min(indata[which(indata > 0)]),
              NA
            )
          )
        },
        na.rm = TRUE
      ),
      # Otherwise keep original value
      fao_monfreda_production_array[index1, index2, , "FAOSTAT"]
    ),
    # Otherwise keep original value
    fao_monfreda_production_array[index1, index2, , "FAOSTAT"]
  )
}

# Fill in Monfreda harvested areas aggregated to GADM units
# First crops with matching crop in FAOSTAT
# Country list
mindex1 <- intersect(
  dimnames(monfreda_gadm_production_array)[[1]],
  dimnames(fao_monfreda_production_array)[[1]]
)
# Year list
mindex3 <- intersect(
  dimnames(monfreda_gadm_production_array)[[3]],
  dimnames(fao_monfreda_production_array)[[3]]
)
# croplist1: FAOSTAT names as in production_items$NAME
index <- na.omit(match(crop_type_mapping$FAO.item.code, production_items$CODE))
croplist1 <- production_items$NAME[index]

# croplist2: Index in Monfreda crop list
index <- which(
  !is.na(crop_type_mapping$FAO.item.code) &
  crop_type_mapping$FAO.item.code %in% production_items$CODE
)
croplist2 <- match(
  dimnames(monfreda_gadm_production_array)[[2]],
  crop_type_mapping$Monfreda.et.al.2008.crop
)[index]

fao_monfreda_production_array[mindex1, croplist1, mindex3, "Monfreda_GADM"] <-
  monfreda_gadm_production_array[mindex1, croplist2, mindex3]
# Second crops without FAOSTAT match
# Monfreda crops not in FAOSTAT
index <- which(is.na(crop_type_mapping$FAO.item.code) |
  !crop_type_mapping$FAO.item.code %in% production_items$CODE
)
croplist3 <- crop_type_mapping$Monfreda[index]
fao_monfreda_production_array[mindex1, croplist3, mindex3, "Monfreda_GADM"] <-
  monfreda_gadm_production_array[mindex1, croplist3, mindex3]
# Flags
# Country list
mindex1 <- intersect(
  dimnames(monfreda_gadm_quality_array)[[1]],
  dimnames(fao_monfreda_production_array)[[1]]
)
# Year list
mindex3 <- intersect(
  dimnames(monfreda_gadm_quality_array)[[3]],
  dimnames(fao_monfreda_production_array)[[3]]
)

# croplist2: Index in Monfreda crop list
index <- which(
  !is.na(crop_type_mapping$FAO.item.code) &
  crop_type_mapping$FAO.item.code %in% production_items$CODE
)
croplist2 <- match(
  dimnames(monfreda_gadm_quality_array)[[2]],
  crop_type_mapping$Monfreda.et.al.2008.crop
)[index]
# Flag names in fao_monfreda_production_array
flaglist1 <- c(
  "Monfreda_GADM_flag_max",
  "Monfreda_GADM_fcropland",
  "Monfreda_GADM_fborder"
)
# Flag names in monfreda_gadm_quality_array
flaglist2 <- c("flag_max", "fcropland", "fborder")
fao_monfreda_production_array[mindex1, croplist1, mindex3, flaglist1] <-
  monfreda_gadm_quality_array[mindex1, croplist2, mindex3, flaglist2]
fao_monfreda_production_array[mindex1, croplist3, mindex3, flaglist1] <-
  monfreda_gadm_quality_array[mindex1, croplist3, mindex3, flaglist2]
rm(mindex1, mindex3, croplist1, croplist2, croplist3, flaglist1, flaglist2)

# Kapok fix
# Assign "kapokfiber" & "kapokseed" from Monfreda to "Kapok fruit" in FAOSTAT
vector_identical <- function(indata) {
  return(length(unique(c(indata))) == 1)
}
# Dimensions to keep in apply() when summing crops
if (length(monfreda_refyear) > 1) {
  crop_sum_dims <- c(1, 3)
} else {
  crop_sum_dims <- 1
}
kapok_fix <- FALSE
# FAOSTAT Kapok * crops according to production_items also included in Monfreda
index <- which(
  production_items$CODE %in% crop_type_mapping$FAO.item.code &
  grepl("kapok", production_items$NAME, ignore.case = TRUE)
)
fao_monfreda_kapok <- production_items$NAME[index]
# Kapok * crops in Monfreda data which are listed with FAO item code
all_monfreda_kapok <- which(!is.na(crop_type_mapping$FAO.item.code) &
  grepl("kapok", crop_type_mapping$Monfreda, ignore.case = TRUE)
)
if (length(fao_monfreda_kapok) < length(all_monfreda_kapok)) {
  # It seems that some Kapok crops from Monfreda that have a FAO item code
  # according to crop_type_mapping are missing in production_items. Try if they
  # are included in fao_production_item_group_def. Otherwise, they have been
  # added to fao_monfreda_production_array using their Monfreda names.
  index <- which(grepl("kapok", crop_type_mapping$Monfreda, ignore.case = TRUE))
  fao_group_kapok <-  which(fao_production_item_group_def$Item.Code %in%
    crop_type_mapping$FAO.item.code[index]
  )
  # Combine Monfreda names and FAOSTAT names
  fao_monfreda_kapok <- c(
    fao_monfreda_kapok,
    crop_type_mapping$Monfreda[all_monfreda_kapok],
    fao_production_item_group_def$Item[fao_group_kapok]
  )
  fao_monfreda_kapok <- intersect(
    dimnames(fao_monfreda_production_array)[[2]],
    fao_monfreda_kapok
  )
  if (any(!crop_type_mapping$FAO.item.code[all_monfreda_kapok] %in%
    fao_production_item_group_def$Item.Code
  )) {
    warning(
      "crop_type_mapping lists ",
      length(all_monfreda_kapok), " FAOSTAT Kapok crops (",
      toString(
        paste(
          crop_type_mapping$FAO.item.name[all_monfreda_kapok],
          crop_type_mapping$FAO.item.code[all_monfreda_kapok],
          sep = ": "
        )
      ),
      ") of which ",
      length(
        which(!crop_type_mapping$FAO.item.code[all_monfreda_kapok] %in%
          fao_production_item_group_def$Item.Code
        )
      ),
      " are missing in FAOSTAT production data.",
      call. = FALSE,
      immediate. = TRUE
    )
  }
}
# FAOSTAT Kapok * crops not included in Monfreda
index <- which(!production_items$CODE %in% crop_type_mapping$FAO.item.code &
  grepl("kapok", production_items$NAME, ignore.case = TRUE)
)
non_monfreda_kapok <- production_items$NAME[index]
# Reassign kapok areas (presumably kapokfiber and kapokseed) if there is exactly
# one FAOSTAT kapok crop not included in Monfreda (presumably Kapok fruit)
if (length(non_monfreda_kapok) == 1 && length(fao_monfreda_kapok) >= 1) {
  # Check that FAOSTAT has no harvested areas for Kapok * crops included
  # in Monfreda; do not reassign areas for crops for which FAOSTAT has areas
  if (all(
    is.na(fao_monfreda_production_array[, fao_monfreda_kapok, , "FAOSTAT"])
  )) {
    # Check that harvested areas of Monfreda crops (kapokfiber and kapokseed)
    # are identical
    if (all(
      apply(
        fao_monfreda_production_array[, fao_monfreda_kapok, , "Monfreda_GADM"],
        crop_sum_dims,
        vector_identical
      )
    )) {
      mindex <- which(
        grepl("kapok", crop_type_mapping$Monfreda, ignore.case = TRUE) &
        crop_type_mapping$FAO.item.code != production_items$CODE[index]
      )
      cat(
        "Re-assigning Monfreda crop(s)",
        toString(sQuote(crop_type_mapping$Monfreda[mindex])), "to FAOSTAT crop",
        sQuote(non_monfreda_kapok), "\n"
      )
      # Copy values for all "Monfreda_*" columns in data array from first
      # fao_monfreda_kapok crop (since they are identical) to non_monfreda_kapok
      datacols <- grep("Monfreda", dimnames(fao_monfreda_production_array)[[4]])
      fao_monfreda_production_array[, non_monfreda_kapok, , datacols] <-
        fao_monfreda_production_array[, fao_monfreda_kapok[1], , datacols]
      # Reset original Monfreda crop area
      fao_monfreda_production_array[, fao_monfreda_kapok, , "Monfreda_GADM"] <- 0
      kapok_fix <- TRUE
    }
  }
}
rm(fao_monfreda_kapok, non_monfreda_kapok)

# Add Monfreda data for FAOSTAT crop groups by summing up the relevant crops
for (group in intersect(
  unique(fao_production_item_group_def$Item.Group),
  dimnames(fao_monfreda_production_array)[[2]]
)) {
  if (!group %in% fao_production_item_group_def_usable) {
    # Test above showed that group areas do not match summed areas of individual
    # crops belonging to that group
    next
  }
  index <- which(fao_production_item_group_def$Item.Group == group)
  crops <- intersect(
    fao_production_item_group_def$Item[index],
    dimnames(fao_monfreda_production_array)[[2]]
  )
  if (length(crops) > 1) {
    # Sum crops in group
    fao_monfreda_production_array[, group, , "Monfreda_GADM"] <- apply(
      fao_monfreda_production_array[, crops, , "Monfreda_GADM"],
      crop_sum_dims,
      sum,
      na.rm = TRUE
    )
  } else if (length(crops) == 1) {
    # Use single crop for group
    fao_monfreda_production_array[, group, , "Monfreda_GADM"] <-
      fao_monfreda_production_array[, crops, , "Monfreda_GADM"]
  }
}

# Attempt to filter for artefacts that result from diffences in country masks
# used here and used for Monfreda dataset
cat(
  "Matching crops between Monfreda and FAOSTAT at the country scale.",
  "Attempting to filter artefacts of different country masks.\n"
)
tmpname <- paste0(
  "countrystats",
  ifelse(
    exists("fao_version_string") && nchar(fao_version_string) > 0,
    paste0("_", fao_version_string),
    ""
  ),
  ifelse(
    exists("gadm_version_string") && nchar(gadm_version_string) > 0,
    paste0("_", gadm_version_string),
    ""
  ),
  ".csv"
)
countrystats_filename <- ifelse(
  nchar(landuse_dir) > 0,
  file.path(
    landuse_dir,
    tmpname
  ),
  tmpname
)
cat("Country tables saved to", sQuote(countrystats_filename), "\n")
countrystats_file <- file(countrystats_filename, "w")
for (country in dimnames(fao_monfreda_production_array)[[1]]) {
  if (country %in% names(fao_groups)) {
    # Skip country groups
    next
  }
  index <- match(country, fao_production_country_def$Country)
  writeLines(
    dQuote(
      paste0(
        "*** ", country,
        ifelse(
          is.na(fao_production_country_def$Start.Year[index]),
          "",
          paste0(
            " (starts to exist in ",
            fao_production_country_def$Start.Year[index],
            ")"
          )
        ),
        ifelse(
          is.na(fao_production_country_def$End.Year[index]),
          "",
          paste0(
            " (ceases to exist in ",
            fao_production_country_def$End.Year[index],
            ")"
          )
        ),
        " ***"
      )
    ),
    con = countrystats_file
  )

  # Crops present in both datasets
  crops <- setdiff(
    which(fao_monfreda_production_array[country, , , "Monfreda_GADM"] > 0 &
      fao_monfreda_production_array[country, , , "FAOSTAT"] > 0
    ),
    # Exclude crop groups
    match(
      unique(fao_production_item_group_def$Item.Group),
      dimnames(fao_monfreda_production_array)[[2]]
    )
  )
  # Filter out crops only found along the border, probably artefacts of country
  # mask
  index <- which(
    fao_monfreda_production_array[country, crops, , "Monfreda_GADM_fborder"] <
    monfreda_threshold_border
  )
  crops_filtered <- crops[index]

  # Crop area in country must be at least 1 ha
  index <- which(
    fao_monfreda_production_array[country, crops_filtered, , "Monfreda_GADM"] >= 1
  )
  crops_filtered <- crops_filtered[index]

  # Filter based on flag_max (best source resolution) and fcropland
  # Based on flag_max this filter computes the fcropland of the smallest
  # country/state/county in "country"
  fcropland_threshold <- double(3)
  cropland_country_cells <- which(
    ramankutty_gadm_cropland[fao_gadm_country_cells[[country]]] > 0
  )
  for (clevel in 1:3) {
    # Find the fcropland of the smallest country/region/county in "country"
    # Allow 25% tolerance because GADM versions do not match
    fcropland_threshold[clevel] <- min(
      rle(
        sort(
          ifelse(
            ramankutty_gadm_cropland[fao_gadm_country_cells[[country]]] > 0,
            gadmlevel_raster[[clevel]][fao_gadm_country_cells[[country]]],
            NA
          )
        )
      )$lengths
    ) / length(cropland_country_cells) * 0.75
  }
  for (c in crops_filtered) {
    datacol <- "Monfreda_GADM_flag_max"
    clevel <- ifelse(
      fao_monfreda_production_array[country, c, , datacol] <= 0.25,
      1,
      ifelse(
        fao_monfreda_production_array[country, c, , datacol] <= 0.75,
        2,
        3
      )
    )
    if (all(
      fao_monfreda_production_array[country, c, , "Monfreda_GADM_fcropland"] <
        fcropland_threshold[clevel] &
      fao_monfreda_production_array[country, c, , "Monfreda_GADM_fcropland"] > 0
    )) {
      crops_filtered <- setdiff(crops_filtered, c)
    }
  }
  # Set fao_monfreda_use_pattern to TRUE for crops that have not been classified
  # as artefacts
  fao_monfreda_use_pattern[country, crops_filtered, ] <- TRUE

  # Provide extensive information on crops present in both or crops present in
  # only of the datasets to file countrystats_filename
  if (length(crops) > 0) {
    datacols <- c(
      "Monfreda_GADM",
      "FAOSTAT",
      "Monfreda_GADM_flag_max",
      "Monfreda_GADM_fcropland",
      "Monfreda_GADM_fborder"
    )
    datacols2 <- c("Monfreda_GADM", "FAOSTAT")
    dummy <- rep(NA, length(datacols) - length(datacols2))

    writeLines(
      dQuote(
        paste(
          length(crops), "crops present",
          "according to both Monfreda (GADM aggregation) and FAOSTAT"
        )
      ),
      con = countrystats_file
    )
    if (length(crops_filtered) > 1) {
      write.csv(
        rbind(
          fao_monfreda_production_array[country, crops_filtered, , datacols],
          sum = c(
            apply(
              fao_monfreda_production_array[country, crops_filtered, , datacols2],
              2,
              sum
            ),
            dummy
          )
        ),
        file = countrystats_file
      )
    } else {
      write.csv(
        cbind(
          dimnames(fao_monfreda_production_array)[[2]][crops],
          t(fao_monfreda_production_array[country, crops, datacols2, ])
        ),
        file = countrystats_file,
        row.names = FALSE
      )
    }
    if (length(crops_filtered) < length(crops)) {
      filtered <- setdiff(crops, crops_filtered)
      writeLines(
        dQuote(
          paste(
            "Of those, the following",
            length(filtered),
            "Monfreda crop patterns appear to be artefacts.",
            "FAOSTAT values will be assigned to new patterns."
          )
        ),
        con = countrystats_file
      )
      if (length(filtered) > 1) {
        write.csv(
          rbind(
            fao_monfreda_production_array[country, filtered, , datacols],
            sum = c(
              apply(
                fao_monfreda_production_array[country, filtered, , datacols2],
                2,
                sum,
                na.rm = TRUE
              ),
              dummy
            )
          ),
          file = countrystats_file
        )
      } else {
        write.csv(
          cbind(
            dimnames(fao_monfreda_production_array)[[2]][filtered],
            t(fao_monfreda_production_array[country, filtered, , datacols])
          ),
          file = countrystats_file,
          row.names = FALSE
        )
      }
    }
  }

  # Crops present only in FAOSTAT
  crops <- which(
    (
      is.na(fao_monfreda_production_array[country, , , "Monfreda_GADM"]) |
      fao_monfreda_production_array[country, , , "Monfreda_GADM"] == 0
    ) &
    fao_monfreda_production_array[country, , , "FAOSTAT"] > 0
  )
  # Remove crop groups
  index <- which(!dimnames(fao_monfreda_production_array)[[2]][crops] %in%
    unique(fao_production_item_group_def$Item.Group)
  )
  crops <- crops[index]
  if (length(crops) > 0) {
    datacols2 <- c("Monfreda_GADM", "FAOSTAT")
    writeLines(
      dQuote(
        paste(
          length(crops),
          "crops present according to FAOSTAT but missing in Monfreda"
        )
      ),
      con = countrystats_file
    )
    if (length(crops) > 1) {
      write.csv(
        rbind(
          fao_monfreda_production_array[country, crops, , datacols2],
          sum = apply(
            fao_monfreda_production_array[country, crops, , datacols2],
            2,
            sum,
            na.rm = TRUE
          )
        ),
        file = countrystats_file
      )
    } else {
      write.csv(
        cbind(
          dimnames(fao_monfreda_production_array)[[2]][crops],
          t(fao_monfreda_production_array[country, crops, , datacols2])
        ),
        file = countrystats_file,
        row.names = FALSE
      )
    }
  }

  # Crops present only in Monfreda
  crops <- which(
    (
      is.na(fao_monfreda_production_array[country, , , "FAOSTAT"]) |
      fao_monfreda_production_array[country, , , "FAOSTAT"] == 0
    ) &
    fao_monfreda_production_array[country, , , "Monfreda_GADM"] > 0
  )
  crops <- setdiff(
    crops,
    # Exclude crop groups
    match(
      unique(fao_production_item_group_def$Item.Group),
      dimnames(fao_monfreda_production_array)[[2]]
    )
  )
  # Filter out crops just found along the border, probably artefacts of country
  # mask
  index <- which(
    fao_monfreda_production_array[country, crops, , "Monfreda_GADM_fborder"] <
    monfreda_threshold_border
  )
  crops_filtered <- crops[index]

  # Crop area in country must be at least 1 ha
  index <- which(
    fao_monfreda_production_array[country, crops_filtered, , "Monfreda_GADM"] >= 1
  )
  crops_filtered <- crops_filtered[index]

  # Filter based on flag_max (best source resolution) and fcropland
  # Based on flag_max this filter computes the fcropland of the smallest
  # country/state/county in "country"
  for (c in crops_filtered) {
    datacol <- "Monfreda_GADM_flag_max"
    clevel <- ifelse(
      fao_monfreda_production_array[country, c, , datacol] <= 0.25,
      1,
      ifelse(
        fao_monfreda_production_array[country, c, , datacol] <= 0.75,
        2,
        3
      )
    )
    if (all(
      fao_monfreda_production_array[country, c, , "Monfreda_GADM_fcropland"] <
      fcropland_threshold[clevel] &
      fao_monfreda_production_array[country, c, , "Monfreda_GADM_fcropland"] > 0
    )) {
      crops_filtered <- setdiff(crops_filtered, c)
    }
  }
  # Set fao_monfreda_use_pattern to TRUE for crops that have not been classified
  # as artefacts
  fao_monfreda_use_pattern[country, crops_filtered, ] <- TRUE

  if (length(crops) > 0) {
    datacols <- c(
      "Monfreda_GADM",
      "Monfreda_GADM_flag_max",
      "Monfreda_GADM_fcropland",
      "Monfreda_GADM_fborder"
    )
    datacols2 <- c("Monfreda_GADM")
    dummy <- rep(NA, length(datacols) - length(datacols2))
    writeLines(
      dQuote(
        paste(
          length(crops),
          "crops present according to Monfreda but missing in FAOSTAT"
        )
      ),
      con = countrystats_file
    )
    if (length(crops_filtered) > 1) {
      write.csv(
        rbind(
          fao_monfreda_production_array[country, crops_filtered, , datacols],
          sum = c(
            sum(
              fao_monfreda_production_array[country, crops_filtered, , datacols2],
              na.rm = TRUE
            ),
            dummy
          )
        ),
        file = countrystats_file
      )
    } else {
      write.csv(
        cbind(
          dimnames(fao_monfreda_production_array)[[2]][crops_filtered],
          t(fao_monfreda_production_array[country, crops_filtered, , datacols])
        ),
        file = countrystats_file,
        row.names = FALSE
      )
    }
    if (length(crops_filtered) < length(crops)) {
      filtered <- setdiff(crops, crops_filtered)
      writeLines(
        dQuote(
          paste(
            "Of those, the following", length(filtered),
            "Monfreda crops appear to be artefacts and will be dropped."
          )
        ),
        con = countrystats_file
      )
      if (length(filtered) > 1) {
        write.csv(
          rbind(
            fao_monfreda_production_array[country, filtered, , datacols],
            sum = c(
              sum(
                fao_monfreda_production_array[country, filtered, , datacols2],
                na.rm = TRUE
              ),
              dummy
            )
          ),
          file = countrystats_file
        )
      } else {
        write.csv(
          cbind(
            dimnames(fao_monfreda_production_array)[[2]][filtered],
            t(fao_monfreda_production_array[country, filtered, , datacols])
          ),
          file = countrystats_file,
          row.names = FALSE
        )
      }
    }
  }
}
close(countrystats_file)

# Update Monfreda country sums based on filter operations above
# Remove all Monfreda values for countries/crops where fao_monfreda_use_pattern
# is FALSE
tmp_gadm <- fao_monfreda_production_array[, , , "Monfreda_GADM"]
index <- intersect(
  which(fao_monfreda_production_array[, , , "Monfreda_GADM"] > 0),
  which(fao_monfreda_use_pattern == FALSE)
)
tmp_gadm[index] <- 0
fao_monfreda_production_array[, , , "Monfreda_GADM"] <- tmp_gadm

# Count number of crops present in crop groups according to FAOSTAT and Monfreda
# and update group sums
fao_monfreda_production_group_members <- array(
  dim = c(
    dim(fao_monfreda_production_array)[1],
    length(fao_production_item_group_def_usable),
    length(monfreda_refyear),
    2
  ),
  dimnames = list(
    dimnames(fao_monfreda_production_array)[[1]],
    fao_production_item_group_def_usable,
    as.character(monfreda_refyear),
    c("Monfreda_GADM", "FAOSTAT")
  )
)
if (length(monfreda_refyear) > 1) {
  crop_sum_dims <- c(1, 3)
} else {
  crop_sum_dims <- c(1)
}
for (group in fao_production_item_group_def_usable) {
  if (!group %in% dimnames(fao_monfreda_production_array)[[2]]) {
    next
  }
  index <- which(fao_production_item_group_def$Item.Group == group)
  crops <- intersect(
    dimnames(fao_monfreda_production_array)[[2]],
    fao_production_item_group_def$Item[index]
  )
  # Countries without country groups
  clist <- setdiff(
    dimnames(fao_monfreda_production_array)[[1]],
    names(fao_groups)
  )
  fao_monfreda_production_array[clist, group, , "Monfreda_GADM"] <- apply(
    fao_monfreda_production_array[clist, crops, , "Monfreda_GADM"],
    crop_sum_dims,
    sum,
    na.rm = TRUE
  )
  fao_monfreda_production_group_members[clist, group, , "Monfreda_GADM"] <-
    apply(
      fao_monfreda_production_array[clist, crops, , "Monfreda_GADM"],
      crop_sum_dims,
      function(indata) return(length(which(indata > 0)))
    )
  fao_monfreda_production_group_members[clist, group, , "FAOSTAT"] <- apply(
    fao_monfreda_production_array[clist, crops, , "FAOSTAT"],
    crop_sum_dims,
    function(indata) return(length(which(!is.na(indata))))
  )
}
# Restore correct FAOSTAT values for reference year(s) -> these may have been
# replaced above by a non-zero value from a different year
fao_monfreda_production_array[index1, index2, index3, "FAOSTAT"] <-
  production_array_filled[index1, index2, "Area harvested", index3]
################################################################################


################################################################################
## Aggregate HYDE cropland to country scale for countries missing in FAOSTAT  ##
## (not all countries) and fill years included in landuse_array               ##
fill_countries <- union(
  setdiff(
    dimnames(fao_monfreda_production_array)[[1]],
    dimnames(landuse_array)[[1]]
  ),
  names(
    which(
      apply(
        landuse_array[, "Cropland", , ],
        1,
        function(indata) all(is.na(indata))
      )
    )
  )
)
if (length(fill_countries) > 0) {
  cat(
    "GADM has", length(fill_countries),
    "countries not included in FAOSTAT.",
    "Deriving country-scale cropland extent from HYDE\n"
  )
  hyde_raster <- raster(hyde_cropland_filename, level = 1)
  if (matching_extent(
    extent(hyde_raster),
    global_extent,
    xres(hyde_raster),
    yres(hyde_raster)
  )) {
    hyde_raster <- setExtent(hyde_raster, global_extent)
  }
  if (any(res(hyde_raster) < res(gadm_raster))) {
    hyde2gadm <- round(res(hyde_raster) / res(gadm_raster), 4)
    if (max(hyde2gadm %% 1) != 0) {
      stop(
        "HYDE resolution ",
        toString(round(res(hyde_raster), 5)),
        " is not an integer multiple of GADM resolution ",
        toString(round(res(gadm_raster), 5))
      )
    }
  } else if (any(res(hyde_raster) > res(gadm_raster))) {
    stop(
        "GADM resolution ",
        toString(round(res(gadm_raster), 5)),
        " is too fine for HYDE resolution ",
        toString(round(res(hyde_raster), 5)), ".\n",
        "You need to create a gridded GADM mask at the HYDE resolution."
    )
  } else {
    hyde2gadm <- c(1, 1)
  }

  cat(
    "HYDE", hyde_cropland_varname,
    "for", min(as.integer(dimnames(landuse_array)[[4]])), "to",
    min(max(as.integer(dimnames(landuse_array)[[4]])), max(hyde_period)),
    "loaded from", sQuote(hyde_cropland_filename), "\n"
  )
  hyde_croplandfile <- nc_open(hyde_cropland_filename)
  lats <- hyde_croplandfile$dim$lat$vals
  raster_lats <- yFromRow(hyde_raster)
  hyde_flip <- (lats[1] < lats[2]) != (raster_lats[1] < raster_lats[2])

  if (!matching_extent(
    extent(hyde_raster),
    extent(gadm_raster),
    xres(gadm_raster),
    yres(gadm_raster)
  )) {
    stop("Spatial extent of HYDE cropland does not match GADM extent")
  }
  if (ud.convert(1,
    hyde_area_units,
    hyde_croplandfile$var[[hyde_cropland_varname]]$units
  ) != 1) {
    warning(
      "Unit in file ", sQuote(hyde_cropland_filename),
      " [", hyde_croplandfile$var[[hyde_cropland_varname]]$units, "] ",
      "differs from defined hyde_area_units [", hyde_area_units, "].",
      call. = FALSE,
      immediate. = TRUE
    )
    # Update unit
    hyde_area_units <- hyde_croplandfile$var[[hyde_cropland_varname]]$units
    hyde_is_fraction <- !ud.are.convertible(hyde_area_units, "m2")
  }
  load_period <- c(
    max(min(as.integer(dimnames(landuse_array)[[4]])), min(hyde_period)),
    min(max(as.integer(dimnames(landuse_array)[[4]])), max(hyde_period))
  )

  start_year <- load_period[1] - min(hyde_period) + 1
  count_year <- load_period[2] - load_period[1] + 1
  hyde_cropland <- ncvar_get(
    nc = hyde_croplandfile,
    varid = hyde_cropland_varname,
    start = c(1, 1, start_year),
    count = c(-1, -1, count_year)
  )
  dimnames(hyde_cropland)[[3]] <- format(
    load_period[1]:load_period[2],
    scientific = FALSE
  )
  if (load_period[1] > min(as.integer(dimnames(landuse_array)[[4]]))) {
    # HYDE starts too late, extend at beginning
    hyde_cropland <- abind(
      array(
        dim = c(
          dim(hyde_cropland)[- 3],
          load_period[1] - min(as.integer(dimnames(landuse_array)[[4]]))
        ),
        dimnames <- list(NULL, NULL,
          format(
            seq(
              min(as.integer(dimnames(landuse_array)[[4]])),
              load_period[1] - 1
            ),
            scientific = FALSE
          )
        )
      ),
      hyde_cropland,
      along = 3
    )
  }
  if (max(as.integer(dimnames(landuse_array)[[4]])) > load_period[2]) {
    hyde_cropland <- abind(
      hyde_cropland,
      array(
        dim = c(
          dim(hyde_cropland)[-3],
          max(as.integer(dimnames(landuse_array)[[4]])) - load_period[2]
        ),
        dimnames = list(NULL, NULL,
          format(
            seq(
              load_period[2] + 1,
              max(as.integer(dimnames(landuse_array)[[4]]))
            ),
            scientific = FALSE
          )
        )
      ),
      along = 3
    )
  }
  hyde_cropland <- hyde_cropland[, , dimnames(landuse_array)[[4]]]
  if (hyde_flip) {
    gc()
    hyde_cropland <- hyde_cropland[, seq(hyde_croplandfile$dim$lat$len, 1), ]
    gc()
  }
  if (hyde_is_fraction) {
    # Need to reload HYDE area at native HYDE resolution, not GADM resolution
    hyde_area <- load_hyde_area(
      filename = hyde_area_file,
      fileunits = hyde_area_file_units,
      faounits = fao_area_units,
      unitraster = hyde_raster,
      gextent = global_extent
    )
    hyde_area_file_units <- hyde_area$unit
    hyde_area <- hyde_area$area
    hyde_cropland <- hyde_cropland * ud.convert(1, hyde_area_units, 1) *
      values(hyde_area) # Unit conversion to fractional (if. e.g. in %)
  } else {
    hyde_cropland <- hyde_cropland *
      ud.convert(1, hyde_area_units, fao_area_units)
  }
  if (max(hyde2gadm) > 1) {
    cat("Aggregating HYDE cropland to GADM resolution\n")
    # Aggregate to GADM resolution
    hyde_cropland <- aggregate_array(hyde_cropland, hyde2gadm, "sum", FALSE)
  }
  # Dissolve separate lon and lat dimensions
  if (length(dim(hyde_cropland)) == 2) {
    dim(hyde_cropland) <- c(ncol(hyde_cropland) * nrow(hyde_cropland), 1)
  } else {
    dim(hyde_cropland) <- c(
      ncol(hyde_cropland) * nrow(hyde_cropland),
      dim(hyde_cropland)[3]
    )
  }
  dimnames(hyde_cropland)[[2]] <- dimnames(landuse_array)[[4]]
  landuse_array_expanded <- landuse_array
  cat("Aggregating countries\n")
  for (country in fill_countries) {
    if (!country %in% dimnames(landuse_array_expanded)[[1]]) {
      # Add country to array
      landuse_array_expanded <- abind(
        landuse_array_expanded,
        array(
          dim = c(1, dim(landuse_array_expanded)[-1]),
          dimnames = c(list(country), dimnames(landuse_array_expanded)[-1])
        ),
        along = 1
      )
    }
    if (length(fao_gadm_country_cells[[country]]) > 1) {
      landuse_array_expanded[country, "Cropland", "Area", ] <- apply(
        hyde_cropland[fao_gadm_country_cells[[country]], ],
        2,
        sum,
        na.rm = TRUE
      )
    } else if (length(fao_gadm_country_cells[[country]]) == 1) {
      landuse_array_expanded[country, "Cropland", "Area", ] <-
        hyde_cropland[fao_gadm_country_cells[[country]], ]
    }
  }
  rm(hyde_raster)
  nc_close(hyde_croplandfile)
  rm(hyde_cropland)
  gc()
}
################################################################################


################################################################################
## Save results of this script for further processing in other scripts.       ##
cat(
  "Gap-filled FAOSTAT production data saved to",
  sQuote(fao_production_gapfilled_RData), "\n"
)
save(
  production_array_filled,
  production_array_gapfilling,
  production_countries,
  production_elements,
  production_items,
  file = fao_production_gapfilled_RData
)
##                                                                            ##
cat(
  "Combined gap-filled FAOSTAT and Monfreda country-level data saved to",
  sQuote(fao_monfreda_country_RData), "\n"
)
harvested_fraction_processed <- FALSE
save(
  fao_monfreda_production_array,
  fao_monfreda_production_group_members,
  fao_monfreda_use_pattern,
  production_array_filled,
  production_array_gapfilling,
  landuse_array_expanded,
  harvested_fraction_processed,
  file = fao_monfreda_country_RData
)
################################################################################
