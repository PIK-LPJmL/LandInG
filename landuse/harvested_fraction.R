################################################################################
## Copyright (C) 2022 Potsdam Institute for Climate Impact Research (PIK),    ##
## see COPYRIGHT file.                                                        ##
##                                                                            ##
## This file is part of LandInG and licensed under GNU AGPL Version 3 or      ##
## later. See LICENSE file or go to http://www.gnu.org/licenses/              ##
## Contact: https://github.com/PIK-LPJmL/LandInG/                             ##
################################################################################

################################################################################
## This script converts absolute gridded harvested areas from Monfreda into   ##
## cropping intensities by dividing them by cropland extent from Ramankutty.  ##
## Since HYDE cropland used in the toolbox differs from Ramankutty cropland a ##
## spatial gap-filling of cropping intensities is conducted to make all       ##
## cropland cells are covered.                                                ##
## Run country_level_data.R before this script.                               ##
################################################################################

# Clean up memory
rm(list = ls(all = TRUE))

################################################################################
## Setup of variables valid across all scripts related to land use data       ##
## processing.                                                                ##
## - sets many directories and file names                                     ##
## - also loads several helper functions used by various land use processing  ##
##   scripts                                                                  ##
source("landuse_setup.R")
################################################################################

################################################################################
## Crop re-assignment                                                         ##
## Some FAOSTAT crops have no direct corresponding crop in Monfreda but       ##
## another crop's pattern can be used, e.g. FAOSTAT has harvested areas for   ##
## Kapok fruit (and no harvested areas for the products Kapok fibre and Kapok ##
## seeds) while Monfreda has harvested areas for Kapok fibre and Kapok seeds. ##
## - Name of the list item: FAOSTAT crop that should use pattern(s) from a    ##
##   different crop
## - Value of the list item: FAOSTAT crop whose Monfreda pattern(s) should be ##
##   used instead (make sure that Monfreda has those crops)                   ##
fao_reassign <- list(
  "Kapok fruit" = "Kapok fibre",
  "Fruit, pome nes" = c("Apples", "Pears", "Quinces")
)
################################################################################


################################################################################
## Load results of country level processing from predecessor scripts.         ##
cat(
  "Loading results generated by country_level_data.R from:",
  toString(sQuote(c(fao_monfreda_country_RData, monfreda_gadm_sums_RData))),
  "\n"
)
# Monfreda gridded harvested areas aggregated to GADM countries
load(monfreda_gadm_sums_RData)
# Country sums of matching Monfreda and FAOSTAT crops; track variables added
# from RData file for later update
loaded_objects <- ls()
load(fao_monfreda_country_RData)
fao_monfreda_country_objects <- setdiff(
  setdiff(ls(), "loaded_objects"),
  loaded_objects
)
rm(loaded_objects)
################################################################################


################################################################################
## Load GADM data and check if global                                         ##
## GADM is used to assign grid cells to administrative areas. The file        ##
## gadmlevel_file is generated by scripts in ../gadm so make sure to run      ##
## these first.                                                               ##
cat(
  "Loading gridded GADM administrative unit data from",
  sQuote(gadmlevel_file), "\n"
)
gadmlevel_raster <- brick(gadmlevel_file)
gadmlevel_names <- read.csv(
  gadmlevel_names_file,
  stringsAsFactors = FALSE,
  comment.char = "#"
)
# Select country data from gadmlevel_names
index <- which(!is.na(gadmlevel_names$level0_ID))
cols <- c("level0_ID", "level0_code", "country")
gadm_country_names <- gadmlevel_names[index, cols]

for (rastercheck in c("gadmlevel_raster")) {
  tmpraster <- get(rastercheck)
  if (matching_extent(
    extent(tmpraster),
    global_extent,
    xres(tmpraster),
    yres(tmpraster)
  )) {
    tmpraster <- setExtent(tmpraster, global_extent)
  }
  assign(rastercheck, tmpraster)
}
################################################################################

################################################################################
## Load various FAOSTAT definitions and do some consistency checks.           ##
cat(
  "FAOSTAT crop item definitions loaded from",
  toString(sQuote(c(fao_production_item_file, fao_production_item_group_file))),
  "\n"
)
fao_production_item_def <- fread(
  fao_production_item_file,
  na.strings = "...",
  # country code for Namibia is "NA", which would normally be converted into NA
  check.names = TRUE,
  data.table = FALSE,
  header = TRUE
)
fao_production_item_group_def <- fread(
  fao_production_item_group_file,
  na.strings = "...",
  # country code for Namibia is "NA", which would normally be converted into NA
  check.names = TRUE,
  data.table = FALSE,
  header = TRUE
)
# Changes in country definitions over time
cat(
  "FAO country definitions loaded from:",
  toString(
    sQuote(c(fao_production_country_file, fao_production_country_group_file))
  ),
  "\n"
)
fao_production_country_def <- fread(
  fao_production_country_file,
  na.strings = "...",
  # country code for Namibia is "NA", which would normally be converted into NA
  check.names = TRUE,
  data.table = FALSE,
  header = TRUE
)
fao_production_country_group_def <- fread(
  fao_production_country_group_file,
  na.strings = "...",
  # country code for Namibia is "NA", which would normally be converted into NA
  check.names = TRUE,
  data.table = FALSE,
  header = TRUE
)
# FAOSTAT to GADM country mapping

cat("FAO to GADM mapping:", toString(sQuote(fao_gadm_mapping_file)), "\n")
for (filename in fao_gadm_mapping_file) {
  source(filename)
}
# Clean encoding
message("Converting special characters read from text files if necessary.")
for (table in c(
  "fao_production_country_def",
  "fao_production_item_group_def",
  "gadmlevel_names",
  "crop_type_mapping",
  "fao_production_country_group_def",
  "fao_production_item_def",
  "gadm_country_names"
)) {
  if (!exists(table))
    next
  table_data <- get(table)
  for (c in colnames(table_data)) {
    if (typeof(table_data[, c]) == "character") {
      if (!all(stri_enc_isascii(table_data[, c]), na.rm = TRUE)) {
        # String has non-ASCII characters
        if (!all(stri_enc_isutf8(table_data[, c]), na.rm = TRUE)) {
          # String has non-UTF8 characters -> assume windows-1252 encoding and
          # convert to UTF-8
          message(
            "Converting column ", sQuote(c),
            " from windows-1252 to UTF-8 encoding in ", table
          )
          table_data[, c] <- stri_encode(
            table_data[, c],
            "windows-1252",
            "UTF-8"
          )
        }
        # Convert UTF-8 strings to ASCII strings, if necessary translating
        # special characters
        message(
          "Converting column ", sQuote(c),
          " from UTF-8 to ASCII encoding in ", table
        )
        table_data[, c] <- stri_encode(table_data[, c], "UTF-8", "UTF-8")
        table_data[, c] <- stri_trans_general(table_data[, c], "latin-ascii")
      }
    }
  }
  assign(table, table_data)
}
# Check consistency between compound_countries and fao_production_country_def
index <- which(!is.na(fao_production_country_def$End.Year))
mismatch <- setdiff(
  names(compound_countries),
  fao_production_country_def$Country[index]
)
if (length(mismatch) > 0) {
  # compound_countries has countries not mentioned in
  # fao_production_country_def, remove
  for (c in mismatch) {
    compound_countries[[c]] <- NULL
  }
}
mismatch <- setdiff(
  fao_production_country_def$Country[index],
  names(compound_countries)
)
if (length(mismatch) > 0) {
  index <- which(fao_production_country_def$Country == country)
  for (country in mismatch) {
    warning(
      sQuote(country),
      " is missing in compound_countries but is listed as ceasing to exist in ",
      fao_production_country_def[index, "End.Year"],
      call. = FALSE,
      immediate. = TRUE
    )
  }
}
# Determine country groups
fao_groups <- list()
# Combine all FAOSTAT country definitions
# Names sometimes differ between different definition lists
cols <- c("Country.Group", "Country.Group.Code")
clist <- abind(
  fao_production_country_def[, c("Country", "Country.Code")],
  fao_production_country_group_def[, c("Country", "Country.Code")],
  fao_production_country_group_def[, cols],
  along = 1
)
# Find countries from fao_monfreda_production_array.
# match returns first occurrence in case of several occurrences
index1 <- match(dimnames(fao_monfreda_production_array)[[1]], clist[, 1])
for (group_code in intersect(
  clist[index1, 2],
  fao_production_country_group_def$Country.Group.Code
)) {
  # Find FAOSTAT indices of countries belonging to group in
  # fao_production_country_group_def
  index2 <- which(
    fao_production_country_group_def$Country.Group.Code == group_code
  )
  # FAOSTAT codes of countries belonging to group in
  # fao_production_country_group_def
  group_country_codes <- fao_production_country_group_def$Country.Code[index2]
  # Indices of countries in fao_production_country_group_def
  index3 <- match(
    group_country_codes,
    fao_production_country_group_def$Country.Code
  )
  # Country names in clist (first occurrence of group_country_codes in clist)
  group_country_names <- ifelse(
    group_country_codes %in% as.integer(clist[, 2]),
    clist[match(group_country_codes, as.integer(clist[, 2])), 1],
    fao_production_country_group_def$Country[index3]
  )
  # Find group_code in fao_production_country_group_def
  index4 <- match(
    group_code,
    fao_production_country_group_def$Country.Group.Code
  )
  # Group name of group_code according to
  # fao_production_country_group_def
  tmpname <- fao_production_country_group_def$Country.Group[index4]
  fao_groups[[tmpname]] <- group_country_names
}
cat("*** Filling country groups in FAOSTAT to GADM country mapping ***\n")
cat("Country groups derived from fao_production_country_group_def\n")
for (country in names(fao_groups)) {
  cat("Filling", country, "in GADM country list\n")
  fao_gadm_country_mapping[[country]] <- unique(
    unlist(fao_gadm_country_mapping[fao_groups[[country]]])
  )
}
# Countries in GADM without corresponding FAOSTAT countries
mismatch <- which(
  !gadm_country_names$level0_code %in% unlist(fao_gadm_country_mapping)
)
if (length(mismatch) > 0) {
  cat(
    "The following GADM units have no corresponding FAO country:",
    toString(sQuote(gadm_country_names$country[mismatch])), "\n"
  )
  if ("World" %in% names(fao_gadm_country_mapping)) {
    cat("Adding them to FAO country group 'World'\n")
    fao_gadm_country_mapping[["World"]] <- c(
      fao_gadm_country_mapping[["World"]],
      gadm_country_names$level0_code[mismatch]
    )
  }
}
# Remove potential duplicates in fao_gadm_country_mapping
# There are currently some duplicates in fao_gadm_country_mapping.R because
# FAOSTAT renamed some countries recently and we keep old names for backwards
# compatibility.
for (country in setdiff(
  names(fao_gadm_country_mapping),
  dimnames(fao_monfreda_production_array)[[1]]
)) {
  # Country from fao_gadm_country_mapping not found in
  # fao_monfreda_production_array
  # Look for entries in fao_gadm_country_mapping with same countries
  cindex <- match(country, names(fao_gadm_country_mapping))
  dupl <- which(
    sapply(
      fao_gadm_country_mapping[-cindex],
      identical,
      y = fao_gadm_country_mapping[[country]]
    )
  )
  if (length(dupl) > 0) {
    cat(
      "Removing", sQuote(country),
      "from fao_gadm_country_mapping because it seems to be a duplicate of",
      toString(sQuote(names(dupl))), "\n"
    )
    fao_gadm_country_mapping[[country]] <- NULL
    # Also remove from compound_countries
    compound_countries <- sapply(compound_countries, setdiff, y = country)
  }
}
# Now check again for duplicates
for (country in names(fao_gadm_country_mapping)) {
  cindex <- match(country, names(fao_gadm_country_mapping))
  dupl <- which(
    sapply(
      fao_gadm_country_mapping[-cindex],
      identical,
      y = fao_gadm_country_mapping[[country]]
    )
  )
  if (length(dupl) > 0) {
    warning(
      sQuote(country), " seems to be a duplicate of ",
      toString(sQuote(names(dupl))), " in fao_gadm_country_mapping\n",
      call. = FALSE,
      immediate. = TRUE
    )
  }
}
# Check consistency of crop names
# Check 1 (Monfreda names)
mismatch <- setdiff(monfreda_names, crop_type_mapping$Monfreda)
if (length(mismatch) > 0) {
  stop(
    "Monfreda crop(s) ",
    toString(sQuote(mismatch)),
    " are missing in crop_type_mapping.\n",
    "Please update ", sQuote(mapping_file)
  )
}
# Check 2 (Monfreda names)
mismatch <- setdiff(crop_type_mapping$Monfreda, monfreda_names)
if (length(mismatch) > 0) {
  stop(
    "crop_type_mapping contains ",
    length(mismatch), " crops not included in monfreda_names: ",
    toString(mismatch), "\n",
    "Please update ", sQuote(mapping_file)
  )
}
# Check 3 (names in fao_monfreda_production_array)
# Crops from fao_monfreda_production_array which are not individual FAOSTAT
# crops
tmpcrops <- setdiff(
  dimnames(fao_monfreda_production_array)[[2]],
  c(
    fao_production_item_group_def$Item,
    fao_production_item_def$Item
  )
)
if (length(tmpcrops) > 0) {
  # Check 4: Crops which are neither individual FAOSTAT crops nor FAOSTAT crop
  # group
  tmpcrops2 <- setdiff(
    tmpcrops,
    fao_production_item_group_def$Item.Group
  )
  if (length(tmpcrops2) > 0) {
    message(
      length(tmpcrops2),
      " crop names in fao_monfreda_production_array are not defined as either",
      " crops or crop groups in fao_production_item_group_def or",
      " fao_production_item_def"
    )
    # Check if these crops are Monfreda names
    if (length(setdiff(tmpcrops2, monfreda_names)) > 0) {
      # Abort if there are undefined crops
      stop(
        "The following crops in fao_monfreda_production_array are neither ",
        "defined as FAOSTAT crops/crop groups in ",
        "fao_production_item_group_def or ",
        "fao_production_item_def nor as Monfreda crops: ",
        toString(sQuote(setdiff(tmpcrops2, monfreda_names))), "\n",
        "Please check processing in predecessor scripts."
      )
    }
    index <- match(tmpcrops2, crop_type_mapping$Monfreda)
    mismatch <- which(! is.na(crop_type_mapping$FAO.item.code[index]))
    if (length(mismatch) == 0) {
      # These crops are Monfreda crops and should not have FAOSTAT item codes
      # according to mapping_file. All good.
      message(
        "They are Monfreda crops with no matching FAOSTAT crop according to ",
        "crop_type_mapping"
      )
    } else {
      # These are Monfreda crops but they should be included in FAOSTAT
      # according to mapping_file.
      warning(
        "Inconsistency between Monfreda and FAOSTAT lists: ",
        toString(sQuote(tmpcrops2[mismatch])),
        " has/have FAO item code according to crop_type_mapping but is/are",
        " missing in fao_production_item_group_def and",
        " fao_production_item_def.\nPlease check ", sQuote(mapping_file),
        call. = FALSE,
        immediate. = TRUE
      )
    }
  }
  rm(tmpcrops2)
}
rm(tmpcrops)
# Re-assignment rules
mismatch <- setdiff(
  names(fao_reassign),
  dimnames(fao_monfreda_production_array)[[2]]
)
if (length(mismatch) > 0) {
  warning(
    "There are re-assignment rules for crops ",
    toString(sQuote(mismatch)),
    " but the crops are not found in fao_monfreda_production_array.\n",
    "Please check if crop names have changed.",
    call. = FALSE,
    immediate. = TRUE
  )
}
# Check if datasets are absolute areas or fractions
hyde_is_fraction <- !ud.are.convertible(hyde_area_units, "m2")
monfreda_is_fraction <- !ud.are.convertible(monfreda_area_units, "m2")
fao_is_fraction <- !ud.are.convertible(fao_area_units, "m2")
ramankutty_is_fraction <- !ud.are.convertible(ramankutty_units, "m2")
################################################################################


################################################################################
## Load HYDE data                                                             ##
# HYDE area file is aggregated to the resolution of unitraster if necessary
hyde_area <- load_hyde_area(
  filename = hyde_area_file,
  fileunits = hyde_area_file_units,
  faounits = fao_area_units,
  unitraster = NULL # set to NULL to get native HYDE resolution
)
hyde_area_file_units <- hyde_area$unit
hyde_area <- hyde_area$area
if (matching_extent(
  extent(hyde_area),
  extent(ramankutty_gadm_cropland),
  xres(hyde_area),
  yres(hyde_area)
)) {
  hyde2gadm <- round(res(hyde_area) / res(ramankutty_gadm_cropland), 4)
  if (max(hyde2gadm %% 1) != 0) {
    stop(
      "Target resolution ", toString(round(res(ramankutty_gadm_cropland), 5)),
      " is not an integer multiple of HYDE resolution ",
      toString(round(res(hyde_area), 5)), "\n",
      "Cannot aggregate."
    )
  }
  if (min(hyde2gadm) < 1) {
    stop(
      "Target resolution ", toString(round(res(ramankutty_gadm_cropland), 5)),
      " is finer than HYDE resolution ",
      toString(round(res(hyde_area), 5)), "\n",
      "Output resolution cannot be finer than any gridded source data."
    )
  } else if (max(hyde2gadm) == 1) {
    hyde_target_area <- hyde_area
  } else {
    hyde_target_area <- aggregate(hyde_area, fact = hyde2gadm, fun = sum)
    if (cellStats(hyde_target_area, sum) != cellStats(hyde_area, sum)) {
      # Global area sum before and after aggregation do not match
      stop("Error aggregating hyde_area to target resolution")
    }
  }
} else {
  stop(
    "Spatial extent of ", sQuote(hyde_area_file),
    " does not match spatial extent of Ramankutty cropland/Monfreda",
    " harvested areas"
  )
}
# HYDE maximum cropland extent
# Maximum cropland is saved to file to reduce runtime if the script is run
# again for the same resolution and time period
if (!file.exists(hyde_max_cropland_filename)) {
  # Create file if it does not exist yet
  # This requires CDO tools to be installed and accessible. Syntax in
  # helper/create_hyde_timeseries_max.R is for Linux.
  create_hyde_timeseries_max(
    source = hyde_cropland_filename,
    target = hyde_max_cropland_filename,
    varname = hyde_cropland_varname,
    sourcearea = hyde_area,
    targetarea = hyde_target_area,
    targetraster = gadm_raster
  )
}
if (file.exists(hyde_max_cropland_filename)) {
  cat(
    "Loading maximum cropland extent from",
    sQuote(hyde_max_cropland_filename), "\n"
  )
  hyde_max_cropland <- raster(hyde_max_cropland_filename)
  zz <- nc_open(hyde_max_cropland_filename)
  unit <- zz$var[[hyde_cropland_varname]]$units
  if (ud.convert(1, hyde_area_units, unit) != 1) {
    warning(
      "Unit in file ", sQuote(hyde_max_cropland_filename), " [", unit, "] ",
      "differs from defined hyde_area_units [", hyde_area_units, "].",
      call. = FALSE,
      immediate. = TRUE
    )
    # update unit
    hyde_area_units <- unit
    hyde_is_fraction <- !ud.are.convertible(hyde_area_units, "m2")
  }
  nc_close(zz)
  if (hyde_is_fraction) {
    hyde_max_cropland <- hyde_max_cropland *
      ud.convert(1, hyde_area_units, "1") * hyde_target_area
  }
} else {
  stop(
    sQuote(hyde_max_cropland_filename),
    " does not exist and cannot be created automatically."
  )
}
################################################################################

################################################################################
## Convert Monfreda gridded harvested areas into cropping intensities.        ##
## This loops over the crop names in fao_monfreda_production_array (mostly    ##
## FAOSTAT crop names) and finds the corresponding Monfreda crop (or crops),  ##
## taking into account any crop re-assignments defined above.                 ##
##                                                                            ##
# Determine filenames
monfreda_filenames <- character(length(monfreda_names))
names(monfreda_filenames) <- monfreda_names
for (crop in monfreda_names) {
  tmpnames <- file.path(
    dir(
      file.path(monfreda_base, monfreda_datadir[monfreda_format]),
      pattern = paste0("^", crop, "_HarvAreaYield"),
      full.names = TRUE
    ),
    paste0(
      crop, "_", monfreda_file_var[[monfreda_format]][1],
      ".", monfreda_file_ext[monfreda_format]
    )
  )
  if (length(which(file.exists(tmpnames))) != 1) {
    stop(
      paste0(
        "Cannot determine filename for crop ", sQuote(crop), ".\n",
        "Tested filename(s): ", toString(tmpnames)
      )
    )
  }
  monfreda_filenames[crop] <- tmpnames[which(file.exists(tmpnames))]
  rm(tmpnames)
}
# Check that extent and resolution match (including the need to aggregate
# Monfreda data)
# Check which monfreda_filenames actually exist
index <- min(which(file.exists(monfreda_filenames)))
if (is.finite(index)) {
  # Derive extent and resolution of Monfreda files
  monfreda_raster <- raster(monfreda_filenames[1])
  if (matching_extent(
    extent(monfreda_raster),
    extent(global_extent),
    xres(monfreda_raster),
    yres(monfreda_raster)
  )) {
    monfreda_raster <- setExtent(monfreda_raster, global_extent)
  }
} else {
  stop("No matching Monfreda crop file found. Check settings in landuse_setup.R")
}
if (any(res(monfreda_raster) < res(gadm_raster))) {
  # Aggregation factor
  monfreda2gadm <- round(res(monfreda_raster) / res(gadm_raster), 4)
  if (max(monfreda2gadm %% 1) != 0) {
    stop(
      "GADM resolution ", toString(round(res(gadm_raster), 5)),
      " is not an integer multiple of ",
      "Monfreda resolution ", toString(round(res(monfreda_raster), 5)), "\n",
      "Cannot aggregate."
    )
  }
} else if (any(res(monfreda_raster) > res(gadm_raster))) {
  stop(
    "GADM resolution ", toString(round(res(gadm_raster), 5)),
    " is finer than Monfreda resolution ",
    toString(round(res(monfreda_raster), 5)), "\n",
    "Output resolution cannot be finer than any gridded source data."
  )
} else {
  monfreda2gadm <- c(1, 1)
}
rm(monfreda_raster)
# Cropping intensities are saved as a NetCDF in the resolution-specific
# working_dir
cat(
  "Generating", sQuote(harvested_fraction_filename),
  "which contains for each crop the harvested area expressed as a fraction",
  "of physical cropland.\n"
)
croplist <- intersect(
  dimnames(fao_monfreda_production_array)[[2]],
  fao_production_item_group_def$Item.Group
)
cat(
  "A total of", dim(fao_monfreda_production_array)[2], "crops of which",
  length(croplist), "are FAOSTAT groups\n"
)
# Check for cells with HYDE cropland but no Ramankutty cropland. These require
# gap-filling.
mismatch <- which(values(hyde_max_cropland) > 0 &
  (values(ramankutty_gadm_cropland) == 0 |
    is.na(values(ramankutty_gadm_cropland)))
)
cat(
  "As part of the process, a gap-filling is attempted for the",
  length(mismatch), "cells which feature cropland according to HYDE but have",
  "no cropland/harvested area information according to Ramankutty/Monfreda\n"
)
cat(
  "Gap-filling statistics saved to",
  sQuote(harvested_fraction_fill_statistics_RData), "\n"
)

if (!file.exists(harvested_fraction_filename)) {
  # Create harvested_fraction_filename if it does not exist yet
  # Define NetCDF dimensions
  londim <- ncdim_def(
    name = "lon",
    units = "degrees_east",
    vals = xFromCol(ramankutty_gadm_cropland),
    longname = "longitude"
  )
  latdim <- ncdim_def(
    name = "lat",
    units = "degrees_north",
    vals = yFromRow(ramankutty_gadm_cropland),
    longname = "latitude"
  )
  cropdim <- ncdim_def(
    name = "crop",
    units = "",
    vals = seq_len(dim(fao_monfreda_production_array)[2]),
    create_dimvar = FALSE
  )
  nchardim <- ncdim_def(
    name = "nchar",
    units = "",
    vals = seq_len(max(nchar(dimnames(fao_monfreda_production_array)[[2]]))),
    create_dimvar = FALSE
  )

  # Define NetCDF variables
  harvested_fraction_var <- ncvar_def(
    name = "harvested_fraction",
    units = "",
    dim = list(londim, latdim, cropdim),
    missval = -1e20,
    longname = "Harvested area share of total cropland in cell"
  )
  crop_var <- ncvar_def(
    name = "crop",
    units = "",
    dim = list(nchardim, cropdim),
    longname = "crop name",
    prec = "char"
  )
  harvested_fraction_file <- nc_create(
    filename = harvested_fraction_filename,
    vars = list(harvested_fraction_var, crop_var),
    force_v4 = TRUE
  )
  # Write crop names to file
  ncvar_put(
    nc = harvested_fraction_file,
    varid = "crop",
    vals = dimnames(fao_monfreda_production_array)[[2]]
  )
  # Write NAs to file to make sure crops are processed
  for (crop in seq_len(dim(fao_monfreda_production_array)[2])) {
    ncvar_put(
      nc = harvested_fraction_file,
      varid = "harvested_fraction",
      vals = rep(NA, londim$len * latdim$len),
      start = c(1, 1, crop),
      count = c(-1, -1, 1)
    )
  }
  nc_sync(harvested_fraction_file)
} else {
  # If harvested_fraction_file exists already try reusing it and only process
  # crops that have not been processed yet
  cat("Continuing previous script run\n")
  harvested_fraction_file <- nc_open(harvested_fraction_filename, write = TRUE)
  # Check that crop names match
  if (any(ncvar_get(harvested_fraction_file, "crop") !=
    dimnames(fao_monfreda_production_array)[[2]]
  )) {
    stop(
      "Crop names in ", sQuote(harvested_fraction_filename),
      " do not match names in fao_monfreda_production_array"
    )
  }
  # Check that spatial resolution matches
  if (harvested_fraction_file$dim$lon$len != ncol(ramankutty_gadm_cropland) ||
       harvested_fraction_file$dim$lat$len != nrow(ramankutty_gadm_cropland)
  ) {
    stop(
      "Dimensions in ", sQuote(harvested_fraction_filename),
      " do not match dimensions of ramankutty_gadm_cropland"
    )
  }
}
# Gap-fill statistics are saved to RData file. Reuse if it exists already.
if (file.exists(harvested_fraction_fill_statistics_RData)) {
  cat(
    "Loading gap-filling statistics from previous script run from",
    sQuote(harvested_fraction_fill_statistics_RData), "\n"
  )
  load(harvested_fraction_fill_statistics_RData)
} else {
  # Set up gap-fill statistics if they do not exist yet
  # This counts the number of districts which have been gap-filled with data
  # from the same district, same state or same country (or could not be gap-
  # filled at all)
  fill_statistics <- array(
    dim = c(dim(fao_monfreda_production_array)[1:2], 4),
    dimnames = list(
      dimnames(fao_monfreda_production_array)[[1]],
      dimnames(fao_monfreda_production_array)[[2]],
      c("country", "state", "district", "unsuccessful")
    )
  )
}
for (crop in 1:dim(fao_monfreda_production_array)[2]) {
  if (exists("monfreda_filedata")) {
    rm(monfreda_filedata)
  }
  # Crop name in fao_monfreda_production_array (usually FAOSTAT name)
  fao_crop <- dimnames(fao_monfreda_production_array)[[2]][crop]
  if (fao_crop %in% unique(fao_production_item_group_def$Item.Group)) {
    # FAOSTAT group crop, no need to gap-fill
    message("*** Skipping FAOSTAT group crop ", sQuote(fao_crop), " ***")
    next
  }
  # FAOSTAT item code corresponding to fao_crop
  codelist <- c(
    fao_production_item_group_def$Item.Code,
    fao_production_item_def$Item.Code
  )
  index <- match(
    fao_crop,
    c(
      fao_production_item_group_def$Item,
      fao_production_item_def$Item
    )
  )
  fao_item_code <- codelist[index]
  if (!is.na(fao_item_code) &&
    !fao_item_code %in% crop_type_mapping$FAO.item.code
  ) {
    # FAOSTAT crop that is not covered by Monfreda. No pattern to process.
    # Check if FAOSTAT crop may be listed in fao_reassign as using the pattern
    # of a different crop.
    if (!fao_crop %in% names(fao_reassign)) {
      # No pattern to process.
      message(
        "*** Skipping FAOSTAT crop ", sQuote(fao_crop),
        " because it is not included in Monfreda ***"
      )
      next
    }
  } else {
    cat("*** Processing", sQuote(fao_crop), "***\n")
  }
  # Load data field of gap-filled fraction from NetCDF.
  # This is empty after the file has been created for the first time.
  fao_monfreda_fraction <- ncvar_get(
    nc = harvested_fraction_file,
    varid = "harvested_fraction",
    start = c(1, 1, crop),
    count = c(-1, -1, 1)
  )
  if (fao_crop %in% names(fao_reassign)) {
    # Use pattern(s) from different crop(s)
    cat(
      "*** Using FAOSTAT crop(s)", toString(sQuote(fao_reassign[[fao_crop]])),
      "as a proxy for", sQuote(fao_crop), "***\n"
    )
    fao_crop <- fao_reassign[[fao_crop]]
    index <- match(
      fao_crop,
      c(
        fao_production_item_group_def$Item,
        fao_production_item_def$Item
      )
    )
    fao_item_code <- codelist[index]
  }
  # Find Monfreda crop matching fao_crop
  # If crop has a FAOSTAT item code use that to find Monfreda name, otherwise
  # search directly for Monfreda name
  index <- ifelse(
    is.na(fao_item_code),
    match(fao_crop, crop_type_mapping$Monfreda),
    match(fao_item_code, crop_type_mapping$FAO.item.code)
  )
  # Monfreda name of crop(s) to use
  monfreda_crop <- crop_type_mapping$Monfreda[index]
  if (anyNA(monfreda_crop)) {
    stop(
      "Could not determine Monfreda crop(s) for fao_crop ",
      toString(sQuote(fao_crop))
    )
  }
  # Load Monfreda harvested area pattern(s) for monfreda_crop
  # Function get_crop_monfreda() defined in helper/get_crop_monfreda.R
  if (length(monfreda_crop) > 1) {
    # More than one source crop
    for (c in monfreda_crop) {
      loaded_fields <- get_crop_monfreda(
        filename = monfreda_filenames[c],
        crop = c,
        unit_raster = ramankutty_gadm_cropland,
        fact = monfreda2gadm
      )
      if (exists("monfreda_filedata")) {
        # Append crop to monfreda_filedata if length of monfreda_crop > 1 and
        # this is not the first source crop
        monfreda_filedata <- abind(
          monfreda_filedata,
          loaded_fields[["filedata"]],
          along = 3
        )
      } else {
        # Set monfreda_filedata to data loaded from file
        monfreda_filedata <- loaded_fields[["filedata"]]
      }
      rm(loaded_fields)
    }
  } else {
    # Only one source crop
    loaded_fields <- get_crop_monfreda(
      filename = monfreda_filenames[monfreda_crop],
      crop = monfreda_crop,
      unit_raster = ramankutty_gadm_cropland,
      fact = monfreda2gadm
    )
    monfreda_filedata <- loaded_fields[["filedata"]]
    dim(monfreda_filedata) <- c(dim(monfreda_filedata), 1)
    rm(loaded_fields)
  }
  dimnames(monfreda_filedata) <- list(NULL, NULL, fao_crop)
  # Remove very small values from Monfreda source data.
  # Threshold monfreda_cutoff defined in landuse_setup.R
  monfreda_filedata[which(monfreda_filedata < monfreda_cutoff)] <- 0
  monfreda_fraction <- ifelse(
    rep(values(ramankutty_gadm_cropland), dim(monfreda_filedata)[3]) > 0,
    monfreda_filedata / values(ramankutty_gadm_cropland),
    NA
  )
  # Dissolve separate lon and lat dimensions
  dim(monfreda_fraction) <- c(
    nrow(monfreda_filedata) * ncol(monfreda_filedata),
    dim(monfreda_filedata)[3]
  )
  dimnames(monfreda_fraction) <- list(NULL, dimnames(monfreda_filedata)[[3]])

  # Gap-filling is done on a country-by-country basis
  for (country in dimnames(fao_monfreda_production_array)[[1]]) {
    country_cells <- fao_gadm_country_cells[[country]]
    if (is.null(country_cells)) {
      # No need to process countries with no associated cells
      next
    }
    if (country %in% names(fao_groups)) {
      # No need to process country groups
      next
    }
    if (country %in% names(compound_countries)) {
      # Countries that seize to exist at some point in time ->
      # run for parts instead of compound country
      next
    }
    # Remove pattern artefacts
    # Check if crop is listed in fao_monfreda_use_pattern.
    # Crop may been re-assigned or have more than one source crop,
    # check each one.
    for (c in dimnames(monfreda_fraction)[[2]]) {
      # Index refers to actual source
      index <- ifelse(
        (c == dimnames(fao_monfreda_production_array)[[2]][crop] |
          dim(monfreda_fraction)[2] > 1),
        c,
        dimnames(fao_monfreda_production_array)[[2]][crop]
      )
      if (!any(fao_monfreda_use_pattern[country, index, ])) {
        # Remove existing pattern in monfreda_fraction in country if
        # fao_monfreda_use_pattern is FALSE
        monfreda_fraction[country_cells, c] <- NA
        # Reset gap-filling statistics if fao_monfreda_use_pattern has changed
        # from previous script run
        fill_statistics[country, crop, ] <- NA
        # Reset gap-filled pattern if fao_monfreda_use_pattern has changed
        # from previous script run
        fao_monfreda_fraction[country_cells] <- NA
      }
    }
    # If combining several patterns, sum up fractions
    if (dim(monfreda_fraction)[2] > 1) {
      # Multiple source crops
      if (length(country_cells) > 1) {
        # Countries with more than one grid cell
        fao_monfreda_fraction[country_cells] <- ifelse(
          # Check in each cell if any monfreda_fraction is not NA
          apply(
            monfreda_fraction[country_cells, ],
            1,
            function(x) return(all(is.na(x)))
          ),
          # Keep original value of fao_monfreda_fraction (NA) if source pattern
          # is NA
          fao_monfreda_fraction[country_cells],
          # Otherwise sum up source crop patterns
          apply(monfreda_fraction[country_cells, ], 1,  sum, na.rm = TRUE)
        )
      } else {
        # Countries with only one grid cell
        fao_monfreda_fraction[country_cells] <- ifelse(
          # Check if any source crop has value
          all(is.na(monfreda_fraction[country_cells, ])),
          # Keep original value of fao_monfreda_fraction (NA) if source pattern
          # is NA
          fao_monfreda_fraction[country_cells],
          # Otherwise sum up source crop patterns
          sum(monfreda_fraction[country_cells, ], na.rm = TRUE)
        )
      }
    } else {
      # One single source crop
      fao_monfreda_fraction[country_cells] <- ifelse(
        # Check in each cell if monfreda_fraction is not NA
        is.na(monfreda_fraction[country_cells]),
        # Keep original value of fao_monfreda_fraction (NA) if source pattern
        # is NA
        fao_monfreda_fraction[country_cells],
        # Otherwise use source crop pattern
        monfreda_fraction[country_cells]
      )
    }
    # Spatial gap-filling
    if (all(is.na(fao_monfreda_fraction[country_cells]))) {
      # All cells are NA, no need to try gap-filling
      next
    }
    # Grid cells with HYDE cropland but without Ramankutty cropland in
    # country_cells
    index <- which(
      hyde_max_cropland[country_cells] > 0 &
      (is.na(ramankutty_gadm_cropland[country_cells]) |
        ramankutty_gadm_cropland[country_cells] == 0)
    )
    fill_cells <- country_cells[index]
    # Gap-fill statistics just for country
    fill_success <- fill_statistics[country, crop, ]
    if (all(is.na(fill_success))) {
      # First script run, initialize
      fill_success[] <- 0
      # Set "unsuccessful" counter to the total number of districts
      fill_success["unsuccessful"] <-
        length(unique(gadmlevel_raster[fill_cells][, 3]))
    }
    # No need to fill gaps which have already been filled in
    # fao_monfreda_fraction in previous script runs:
    # Filter with actual NA values
    fill_cells <- fill_cells[which(is.na(fao_monfreda_fraction[fill_cells]))]
    if (length(fill_cells) > 0) {
      # Get GADM administrative units level 0-2 for fill_cells
      # Gap-filling first tries level 2, then level 1, then level 0 until it is
      # successful.
      fill_gadmlevels <- gadmlevel_raster[fill_cells]
      # Matrix with cell index and corresponding GADM level 0-2 codes
      country_gadmlevels <- cbind(
        global = country_cells,
        gadmlevel_raster[country_cells]
      )
      cat(
        "Trying to fill in gaps in", length(unique(fill_gadmlevels[, 3])),
        "out of", length(unique(gadmlevel_raster[country_cells][, 3])),
        "districts of", country, "\n"
        # This counts all districts with missing cells no matter whether only
        # one cell is missing or all cells are missing.
      )
      # Loop over all districts that have at least one cell requiring gap-
      # filling.
      for (district in unique(fill_gadmlevels[, 3])) {
        fillvalue <- NA
        district_index <- which(country_gadmlevels[, 4] == district)
        district_cropland <-
          ramankutty_gadm_cropland[country_gadmlevels[district_index, "global"]]
        # Check if any cell in district has Ramankutty cropland (and therefore
        # should have a Monfreda pattern)
        if (max(district_cropland, na.rm = TRUE) > 0) {
          fillvalue <- sum(
            monfreda_fraction[country_gadmlevels[district_index, "global"]] *
              district_cropland,
            na.rm = TRUE
          ) / sum(district_cropland, na.rm = TRUE)
          # Increase counter for districts gap-filled with data from same
          # district
          fill_success["district"] <- fill_success["district"] + 1
          # Decrease counter for districts that could not be gap-filled
          fill_success["unsuccessful"] <- fill_success["unsuccessful"] - 1
        } else {
          # Try state level next
          state <- unique(
            fill_gadmlevels[which(fill_gadmlevels[, 3] == district), 2]
          )
          state_index <- which(country_gadmlevels[, 3] %in% state)
          state_cropland <-
            ramankutty_gadm_cropland[country_gadmlevels[state_index, "global"]]
          # Check if any cell in state has Ramankutty cropland (and therefore
          # should have a Monfreda pattern)
          if (max(state_cropland, na.rm = TRUE) > 0) {
            fillvalue <- sum(
              monfreda_fraction[country_gadmlevels[state_index, "global"]] *
                state_cropland,
              na.rm = TRUE
            ) / sum(state_cropland, na.rm = TRUE)
            # Increase counter for districts gap-filled with data from same
            # state
            fill_success["state"] <- fill_success["state"] + 1
            # Decrease counter for districts that could not be gap-filled
            fill_success["unsuccessful"] <- fill_success["unsuccessful"] - 1
          } else {
            # Try country level next
            ccode <- unique(
              fill_gadmlevels[which(fill_gadmlevels[, 2] %in% state), 1]
            )
            country_index <- which(country_gadmlevels[, 2] %in% ccode)
            cells <- country_gadmlevels[country_index, "global"]
            country_cropland <- ramankutty_gadm_cropland[cells]
            if (max(country_cropland, na.rm = TRUE) > 0) {
              fillvalue <- sum(
                monfreda_fraction[cells] * country_cropland,
                na.rm = TRUE
              ) / sum(country_cropland, na.rm = TRUE)
              # Increase counter for districts gap-filled with data from same
              # country
              fill_success["country"] <- fill_success["country"] + 1
              # Decrease counter for districts that could not be gap-filled
              fill_success["unsuccessful"] <- fill_success["unsuccessful"] - 1
            } else {
              fillvalue <- NA
            }
            rm(country_index, country_cropland)
          }
          rm(state_index, state_cropland)
        }
        rm(district_index, district_cropland)
        # Set all grid cells in the district that require gap-filling to derived
        # fillvalue
        fillindex <- fill_cells[which(fill_gadmlevels[, 3] == district)]
        fao_monfreda_fraction[fillindex] <- fillvalue
      }
      # Print out gap-filling statistics for country
      cat(
        sum(fill_success[c("district", "state", "country")]),
        "districts gap-filled,",
        fill_success["district"], "with data at the district level,",
        fill_success["state"], "with data at the state level, and",
        fill_success["country"], "with data at the country level\n"
      )
      # Save for statistics RData file
      fill_statistics[country, crop, ] <- fill_success
    }
    # Update fao_monfreda_use_pattern depending on whether any cells contain
    # values.
    cropname <- dimnames(fao_monfreda_production_array)[[2]][crop]
    fao_monfreda_use_pattern[country, cropname, ] <-
      any(fao_monfreda_fraction[country_cells] > 0, na.rm = TRUE)
  }
  # Update fao_monfreda_use_pattern for compound countries
  cropname <- dimnames(fao_monfreda_production_array)[[2]][crop]
  clist <- intersect(
    names(compound_countries),
    dimnames(fao_monfreda_use_pattern)[[1]]
  )
  for (country in clist) {
    # Set compound country to TRUE if at least one of the countries in it is
    # TRUE
    if (dim(fao_monfreda_use_pattern)[3] > 1) {
      fao_monfreda_use_pattern[country, cropname, ] <- apply(
        fao_monfreda_use_pattern[compound_countries[[country]], cropname, ],
        2,
        any,
        na.rm = TRUE
      )
    } else {
      fao_monfreda_use_pattern[country, cropname, ] <- any(
        fao_monfreda_use_pattern[compound_countries[[country]], cropname, ],
        na.rm = TRUE
      )
    }
  }
  # Save gap-filled pattern to NetCDF file
  ncvar_put(
    nc = harvested_fraction_file,
    varid = "harvested_fraction",
    vals = c(fao_monfreda_fraction),
    start = c(1, 1, crop),
    count = c(-1, -1, 1)
  )
  nc_sync(harvested_fraction_file)
  # Save gap-filling statistics to RData file
  save(fill_statistics, file = harvested_fraction_fill_statistics_RData)
}

# Finish files generated by this script
nc_close(harvested_fraction_file)
save(fill_statistics, file = harvested_fraction_fill_statistics_RData)
# Update country sums of matching Monfreda and FAOSTAT crops because
# fao_monfreda_use_pattern may have changed.
# This is first created by country_level_data.R
# Indicate that file has been processed by harvested_fraction.R
harvested_fraction_processed <- TRUE
save(list = fao_monfreda_country_objects, file = fao_monfreda_country_RData)
################################################################################
