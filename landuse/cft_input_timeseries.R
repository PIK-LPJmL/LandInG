################################################################################
## Copyright (C) 2022 Potsdam Institute for Climate Impact Research (PIK),    ##
## see COPYRIGHT file.                                                        ##
##                                                                            ##
## This file is part of LandInG and licensed under GNU AGPL Version 3 or      ##
## later. See LICENSE file or go to http://www.gnu.org/licenses/              ##
## Contact: https://github.com/PIK-LPJmL/LandInG/                             ##
################################################################################

################################################################################
## This script converts crop-specific (or crop-group-specific) harvested area ##
## timeseries into a landuse input file suitable for use in LPJmL.            ##
## By default, it adds bands for managed grasslands (based on HYDE grazing    ##
## land) and bioenergy plantations (set to zero), which are part of the       ##
## standard landuse input for LPJmL.                                          ##
## If you plan to create more than one crop aggregation you may give it a     ##
## short name, set below as variable "aggregation_name" and observed in       ##
## landuse_setup.R.                                                           ##
## You may provide a grid file at a coarser resolution than the one used in   ##
## the rest of landuse processing. In this case, landuse information is       ##
## aggregated to the resolution of the grid file.                             ##
################################################################################

# Clean up memory
rm(list = ls(all = TRUE))

################################################################################
## Basic setup of aggregation                                                 ##
## (Optional) name of crop aggregation                                        ##
aggregation_name <- "default"
################################################################################

################################################################################
## Setup of variables valid across all scripts related to land use data       ##
## processing.                                                                ##
## - sets many directories and file names                                     ##
## - also loads several helper functions used by various land use processing  ##
##   scripts                                                                  ##
source("landuse_setup.R")
################################################################################

################################################################################
## Continue setup of aggregation                                              ##
## Period for LPJmL file created (default: same as output_period)             ##
cft_output_period <- output_period
## Unit used in generated file. Leave empty to use fraction (the current      ##
## default unit in LPJmL) or specify a spatially explicit unit                ##
cft_output_units <- ""
## Grid file in LPJmL input format to use (such as a grid file generated by   ##
## the scripts in ../gadm)
## Note: This grid file can have a coarser spatial resolution than the        ##
## harvested area timeseries created by the other scripts in this directory.  ##
cft_gridname <- "PATH_TO_GRIDFILE"
## Country code file in LPJmL input format (such as a "cowname" file          ##
## generated by the scripts in ../gadm). This file needs to match the grid    ##
## file above. This information is only used for debug print statements.      ##
cft_cowname <- "PATH_TO_COUNTRY_FILE"
## If the country code file was generated by the scripts in ../gadm there     ##
## should also be a corresponding CSV file with country names. Supply if      ##
## available. Otherwise leave empty.                                          ##
cft_cowmetaname <- "PATH_TO_COUNTRY_META_FILE_OR_EMPTY"
## Should harvested areas larger than physical cropland be scaled down to fit ##
## into physical cropland? (LPJmL currently does not support multicropping so ##
## CFT-specific areas cannot exceed the cell area)
scale_down_cfts2cropland <- TRUE
## Additional information besides crops, managed grasslands and bioenergy     ##
## plantations.                                                               ##
## Create a band with fallow land as part of the landuse input file (if       ##
## harvested areas are smaller than available cropland the remaining cropland ##
## is considered fallow)                                                      ##
cft_include_fallow <- FALSE
## Create separate input file for fallow land (same definition as above)      ##
cft_separate_fallow <- TRUE
## Name of fallow land band ("rainfed" and "irrigated" added automatically,   ##
## do not use spaces or special characters)                                   ##
fallow_name <- "fallow"
## Create a band with physical cropland as part of the landuse input file     ##
cft_include_cropland <- FALSE
## Create separate input file for physical cropland                           ##
cft_separate_cropland <- TRUE
## Name of cropland band ("rainfed" and "irrigated" added automatically, do   ##
## not use spaces or special characters)                                      ##
cropland_name <- "cropland"
## Filename base for generated LPJmL input files (spatial resolution and      ##
## optional version strings added automatically). Define only output          ##
## directory (if desired) and first part of filename here. By default saved   ##
## to landuse_dir.                                                            ##
cft_output_filename_base <- "cft_"
## Add optional aggregation name and optional version strings                 ##
if (nchar(aggregation_name) > 0) {
  cft_output_filename <- paste0(
    cft_output_filename_base,
    aggregation_name,
    "_cft_aggregation"
  )
}
# Concatenate all possible version strings
file_version_string <- paste0(
  ifelse(
    exists("aquastat_version_string") && nchar(aquastat_version_string) > 0,
    paste0("_", aquastat_version_string),
    ""
  ),
  ifelse(
    exists("fao_version_string") && nchar(fao_version_string) > 0,
    paste0("_", fao_version_string),
    ""
  ),
  ifelse(
    exists("gadm_version_string") && nchar(gadm_version_string) > 0,
    paste0("_", gadm_version_string),
    ""
  ),
  ifelse(
    exists("gaez_version_string") && nchar(gaez_version_string) > 0,
    paste0("_", gaez_version_string),
    ""
  ),
  ifelse(
    exists("hyde_version_string") && nchar(hyde_version_string) > 0,
    paste0("_", hyde_version_string),
    ""
  ),
  ifelse(
    exists("mirca_version_string") && nchar(mirca_version_string) > 0,
    paste0("_", mirca_version_string),
    ""
  ),
  ifelse(
    exists("monfreda_version_string") && nchar(monfreda_version_string) > 0,
    paste0("_", monfreda_version_string),
    ""
  ),
  ifelse(
    exists("ramankutty_version_string") && nchar(ramankutty_version_string) > 0,
    paste0("_", ramankutty_version_string),
    ""
  )
)

cft_output_filename <- paste0(
  cft_output_filename,
  file_version_string,
  "_"
)
################################################################################


################################################################################
## Setup of bands in CFT input file                                           ##
## This needs to conform to CFTs, others, managed grasslands and bioenergy    ##
## plantation types defined in LPJmL.                                         ##
## Order must be identical to the one expected by LPJmL.                      ##
## LPJmL expects the same number of rainfed and irrigated bands.              ##
cft_bands <- c(
  "rainfed temperate cereals",
  "rainfed rice",
  "rainfed maize",
  "rainfed tropical cereals",
  "rainfed pulses",
  "rainfed temperate roots",
  "rainfed tropical roots",
  "rainfed oil crops sunflower",
  "rainfed oil crops soybean",
  "rainfed oil crops groundnut",
  "rainfed oil crops rapeseed",
  "rainfed sugar cane",
  "rainfed other crops",
  "rainfed pasture/managed grass",
  "rainfed bio-energy grass",
  "rainfed bio-energy tree",
  "irrigated temperate cereals",
  "irrigated rice",
  "irrigated maize",
  "irrigated tropical cereals",
  "irrigated pulses",
  "irrigated temperate roots",
  "irrigated tropical roots",
  "irrigated oil crops sunflower",
  "irrigated oil crops soybean",
  "irrigated oil crops groundnut",
  "irrigated oil crops rapeseed",
  "irrigated sugar cane",
  "irrigated other crops",
  "irrigated pasture/managed grass",
  "irrigated bio-energy grass",
  "irrigated bio-energy tree"
)
## cft_bands that occupy cropland                                             ##
## Make sure that the following regular expression matches all crops, but not ##
## pasture, bioenergy, cropland or similar variables you may have added.      ##
## This information is used if scale_down_cfts2cropland == TRUE to know which ##
## bands to scale down.                                                       ##
cft_bands_is_cropland <- logical(length(cft_bands))
names(cft_bands_is_cropland) <- cft_bands
crop_bands <- grep(
  paste("bio-energy|pasture", cropland_name, sep = "|", collapse = "|"),
  cft_bands,
  invert = TRUE
)
cft_bands_is_cropland[crop_bands] <- TRUE
################################################################################


################################################################################
## Source mapping                                                             ##
## For CFT bands without values (e.g. bioenergy plantations) set empty list   ##
##
## source="ha_timeseries" refers to NetCDF with (aggregated) crop-specific    ##
## harvested area time series created by aggregate_cft_timeseries.R.          ##
## Set "variable" to variable name in source NetCDF file                      ##
## Set "band" to one or more crop bands in variable                           ##
##                                                                            ##
## source="hyde_grazing" refers to grazing land by HYDE                       ##
## Set "variable" to variable name in NetCDF file                             ##
## Set "band" if variable has more than 1 band                                ##
##                                                                            ##
## source="fallow" refers to fallow land, computed as available cropland      ##
## minus allocated CFT areas                                                  ##
##                                                                            ##
## source="hyde_rainfed" refers to HYDE rainfed cropland                      ##
## Set "variable" to variable name in NetCDF file                             ##
## Set "band" if variable has more than 1 band                                ##
## source="hyde_irrigated" refers to HYDE irrigated cropland                  ##
## Set "variable" to variable name in NetCDF file                             ##
## Set "band" if variable has more than 1 band                                ##
##                                                                            ##
## Rules how to deal with the sources above have been defined. Additional     ##
## sources may be defined you will also need to add code read the information ##
##                                                                            ##
## cft_mapping must have an entry for each element in cft_bands. It can       ##
## include entries for elements not part of cft_bands, for example if you     ##
## plan to use more than one crop aggregation.                                ##
cft_mapping <- list(
  "rainfed temperate cereals" = list(
    source = "ha_timeseries",
    variable = rainfed_output_name,
    band = "temperate cereals"
  ), # rainfed_output_name defined in landuse_setup.R
  "rainfed rice" = list(
    source = "ha_timeseries",
    variable = rainfed_output_name,
    band = "rice"
  ),
  "rainfed maize" = list(
    source = "ha_timeseries",
    variable = rainfed_output_name,
    band = "maize"
  ),
  "rainfed tropical cereals" = list(
    source = "ha_timeseries",
    variable = rainfed_output_name,
    band = "tropical cereals"
  ),
  "rainfed pulses" = list(
    source = "ha_timeseries",
    variable = rainfed_output_name,
    band = "pulses"
  ),
  "rainfed temperate roots" = list(
    source = "ha_timeseries",
    variable = rainfed_output_name,
    band = "temperate roots"
  ),
  "rainfed tropical roots" = list(
    source = "ha_timeseries",
    variable = rainfed_output_name,
    band = "tropical roots"
  ),
  "rainfed oil crops sunflower" = list(
    source = "ha_timeseries",
    variable = rainfed_output_name,
    band = "oil crops sunflower"
  ),
  "rainfed oil crops soybean" = list(
    source = "ha_timeseries",
    variable = rainfed_output_name,
    band = "oil crops soybean"
  ),
  "rainfed oil crops groundnut" = list(
    source = "ha_timeseries",
    variable = rainfed_output_name,
    band = "oil crops groundnut"
  ),
  "rainfed oil crops rapeseed" = list(
    source = "ha_timeseries",
    variable = rainfed_output_name,
    band = "oil crops rapeseed"
  ),
  "rainfed sugar cane" = list(
    source = "ha_timeseries",
    variable = rainfed_output_name,
    band = "sugarcane"
  ),
  "rainfed other crops" = list(
    source = "ha_timeseries",
    variable = rainfed_output_name,
    band = c("Others, annual", "Others, perennial")
  ),
  "rainfed pasture/managed grass" = list(
    source = "hyde_grazing",
    variable = hyde_grazing_varname
  ), # hyde_grazing_varname defined in landuse_setup.R
  "rainfed bio-energy grass" = list(),
  "rainfed bio-energy tree" = list(),
  "irrigated temperate cereals" = list(
    source = "ha_timeseries",
    variable = irrigated_output_name,
    band = "temperate cereals"
  ), # irrigated_output_name defined in landuse_setup.R
  "irrigated rice" = list(
    source = "ha_timeseries",
    variable = irrigated_output_name,
    band = "rice"
  ),
  "irrigated maize" = list(
    source = "ha_timeseries",
    variable = irrigated_output_name,
    band = "maize"
  ),
  "irrigated tropical cereals" = list(
    source = "ha_timeseries",
    variable = irrigated_output_name,
    band = "tropical cereals"
  ),
  "irrigated pulses" = list(
    source = "ha_timeseries",
    variable = irrigated_output_name,
    band = "pulses"
  ),
  "irrigated temperate roots" = list(
    source = "ha_timeseries",
    variable = irrigated_output_name,
    band = "temperate roots"
  ),
  "irrigated tropical roots" = list(
    source = "ha_timeseries",
    variable = irrigated_output_name,
    band = "tropical roots"
  ),
  "irrigated oil crops sunflower" = list(
    source = "ha_timeseries",
    variable = irrigated_output_name,
    band = "oil crops sunflower"
  ),
  "irrigated oil crops soybean" = list(
    source = "ha_timeseries",
    variable = irrigated_output_name,
    band = "oil crops soybean"
  ),
  "irrigated oil crops groundnut" = list(
    source = "ha_timeseries",
    variable = irrigated_output_name,
    band = "oil crops groundnut"
  ),
  "irrigated oil crops rapeseed" = list(
    source = "ha_timeseries",
    variable = irrigated_output_name,
    band = "oil crops rapeseed"
  ),
  "irrigated sugar cane" = list(
    source = "ha_timeseries",
    variable = irrigated_output_name,
    band = "sugarcane"
  ),
  "irrigated other crops" = list(
    source = "ha_timeseries",
    variable = irrigated_output_name,
    band = c("Others, annual", "Others, perennial")
  ),
  "irrigated pasture/managed grass" = list(), # No irrigated pastures in HYDE
  "irrigated bio-energy grass" = list(),
  "irrigated bio-energy tree" = list()
)
# Check if fallow land bands are part of cft_bands and/or cft_mapping, add if
# necessary.
fallow_bands <- grep(
  paste0("rainfed ", fallow_name, "|irrigated ", fallow_name),
  cft_bands,
  value = TRUE
)
if (length(fallow_bands) == 2 && !cft_include_fallow) {
  message(
    "Setting cft_include_fallow to TRUE because bands ",
    toString(sQuote(fallow_bands)), " detected in cft_bands."
  )
  cft_include_fallow <- TRUE
}
if (cft_include_fallow || cft_separate_fallow) {
  for (irr in c("rainfed", "irrigated")) {
    if (!any(grepl(paste(irr, fallow_name), cft_bands)) && cft_include_fallow) {
      # If it is not already included add fallow land as last rainfed or last
      # irrigated band to cft_bands
      # Bands before fallow land band in cft_bands
      bands1 <- seq_len(max(grep(irr, cft_bands)))
      # Bands after fallow land band in cft_bands
      bands2 <- setdiff(seq_along(cft_bands), bands1)
      cft_bands <- c(
        cft_bands[bands1],
        paste(irr, fallow_name),
        cft_bands[bands2]
      )
    }
    # Add source if not already defined
    if (is.null(cft_mapping[[paste0(irr, fallow_name)]])) {
      cft_mapping[[paste(irr, fallow_name)]] <- list(
        source = "fallow",
        variable = paste(irr, fallow_name)
      )
    }
  }
  if (cft_include_fallow) {
    # Add a note to filename
    cft_output_filename <- paste0(
      cft_output_filename,
      "including_", fallow_name, "_"
    )
    # Add fallow land to cft_bands that occupy cropland
    cft_bands_is_cropland <- cft_bands_is_cropland[cft_bands]
    names(cft_bands_is_cropland) <- cft_bands
    fallow_bands <- grep(fallow_name, names(cft_bands_is_cropland))
    cft_bands_is_cropland[fallow_bands] <- TRUE
  }
}
# Consistency check
if (length(grep(fallow_name, cft_bands)) != 2 &&
  length(grep(fallow_name, cft_bands)) != 0
) {
  stop(
    "Error determining ", fallow_name, " bands in cft_bands. Expected: ",
    toString(sQuote(paste(c("rainfed", "irrigated"), fallow_name))),
    ". Detected: ",
    toString(sQuote(grep(fallow_name, cft_bands, value = TRUE)))
  )
}
# Check if cropland bands are part of cft_bands and/or cft_mapping, add if
# necessary.
cropland_bands <- grep(
  paste0("rainfed ", cropland_name, "|irrigated ", cropland_name),
  cft_bands,
  value = TRUE
)
if (length(cropland_bands) == 2 && !cft_include_cropland) {
  message(
    "Setting cft_include_cropland to TRUE because bands ",
    toString(sQuote(cropland_bands)),
    " detected in cft_bands"
  )
  cft_include_cropland <- TRUE
}
if (cft_include_cropland || cft_separate_cropland) {
  for (irr in c("rainfed", "irrigated")) {
    if (!any(grepl(paste(irr, cropland_name), cft_bands)) &&
      cft_include_cropland
    ) {
      # If it is not already included add cropland as last rainfed or last
      # irrigated band to cft_bands
      # Bands before fallow land band in cft_bands
      bands1 <- seq_len(max(grep(irr, cft_bands)))
      # Bands after fallow land band in cft_bands
      bands2 <- setdiff(seq_along(cft_bands), bands1)
      cft_bands <- c(
        cft_bands[bands1],
        paste(irr, cropland_name),
        cft_bands[bands2]
      )
    }
    # Add source if not already defined
    if (is.null(cft_mapping[[paste0(irr, cropland_name)]])) {
      cft_mapping[[paste(irr, cropland_name)]] <- list(
        source = paste0("hyde_", irr),
        variable = get(paste0("hyde_", irr, "_varname"))
      )
    }
  }
  if (cft_include_cropland) {
    # Add a note to filename
    cft_output_filename <- paste0(
      cft_output_filename,
      "including_", cropland_name, "_"
    )
    # Cropland is not part of cft_bands that occupy cropland
    cft_bands_is_cropland <- cft_bands_is_cropland[cft_bands]
    names(cft_bands_is_cropland) <- cft_bands
    cropland_bands <- grep(cropland_name, names(cft_bands_is_cropland))
    cft_bands_is_cropland[cropland_bands] <- FALSE
  }
}
# Consistency check
if (length(grep(cropland_name, cft_bands)) != 2 &&
  length(grep(cropland_name, cft_bands)) != 0
) {
  stop(
    "Error determining ", cropland_name, " bands in cft_bands. Expected: ",
    toString(sQuote(paste(c("rainfed", "irrigated"), cropland_name))),
    ". Detected: ",
    toString(sQuote(grep(cropland_name, cft_bands, value = TRUE)))
  )
}
if (any(!cft_bands %in% names(cft_mapping))) {
  # All values in cft_bands must have an entry in cft_mapping
  stop(
    "cft_bands ",
    toString(sQuote(setdiff(cft_bands, names(cft_mapping)))),
    " missing in cft_mapping"
  )
}

if (!all(regmatches(cft_bands, gregexpr("^[a-z]*", cft_bands)) %in%
  c("rainfed", "irrigated"))
) {
  # All values in cft_bands must be either rainfed or irrigated
  stop(
    "Invalid value(s) in cft_bands: ",
    toString(
      sQuote(
        grep("^rainfed |^irrigated ", cft_bands, invert = TRUE, value = TRUE)
      )
    )
  )
}
################################################################################

################################################################################
## Set up sources                                                             ##
## 1) ha_timeseries                                                           ##
## By default, this uses aggregated timeseries generated by                   ##
## aggregate_cft_timeseries.R                                                 ##
pattern <- paste0(
  basename(aggregated_timeseries_filename_base),
  "_[0-9]{4}-[0-9]{4}", # chunk years
  file_version_string,
  ".nc"
)
ha_timeseries_filenames <- list.files(
  dirname(aggregated_timeseries_filename_base),
  pattern,
  full.name = TRUE
)
if (length(ha_timeseries_filenames) < 1) {
  stop(
    "No NetCDF files found in ",
    sQuote(dirname(aggregated_timeseries_filename_base)),
    " matching name pattern:\n",
    sQuote(pattern)
  )
}
# Check which variables must be present in NetCDF files (all "variable"
# entries in cft_mapping for source=ha_timeseries)
ha_bands <- which(
  sapply(
    cft_mapping,
    function(indata, search) {
      return(length(indata) > 0 && indata$source == search)
    },
    search = "ha_timeseries"
  )
)
ha_timeseries_vars_req <- unique(
  sapply(
    cft_mapping[ha_bands],
    function(indata) return(indata$variable)
  )
)
# Collect information from ha_timeseries_filenames
ha_timeseries_startyears <- ha_timeseries_endyears <- rep(
  NA,
  length(ha_timeseries_filenames)
)
names(ha_timeseries_startyears) <- names(ha_timeseries_endyears) <-
  ha_timeseries_filenames
ha_timeseries_files <- list()
ha_timeseries_is_fractional <- FALSE
year_processed <- fileyears <- integer(0)
for (filename in ha_timeseries_filenames) {
  ha_timeseries_files[[filename]] <- nc_open(filename)
  # Determine years included in file
  timeunit <- ha_timeseries_files[[filename]]$dim$time$units
  refyear <- as.integer(
    format.Date(gsub("days|years since ", "", timeunit), "%Y")
  )
  ha_timeseries_startyears[filename] <- min(
    refyear + ha_timeseries_files[[filename]]$dim$time$vals
  )
  ha_timeseries_endyears[filename] <- max(
    refyear + ha_timeseries_files[[filename]]$dim$time$vals
  )
  fileyears <- c(
    fileyears,
    refyear + ha_timeseries_files[[filename]]$dim$time$vals
  )
  missing <- setdiff(
    ha_timeseries_vars_req,
    names(ha_timeseries_files[[filename]]$var)
  )
  if (length(missing) > 0) {
    message(
      "Error: Aborting because variable(s) ",
      toString(sQuote(missing)),
      " missing in ",
      sQuote(ha_timeseries_files[[filename]]$filename)
    )
    # Close all open NetCDF files
    invisible(sapply(ha_timeseries_files, nc_close))
    stop("Incompatible harvested area time series NetCDF")
  }
  # Check variable unit
  for (v in ha_timeseries_vars_req) {
    varunit <- ncatt_get(
      nc = ha_timeseries_files[[filename]],
      varid = v,
      attname = "units"
    )
    if (varunit$hasatt) {
      ha_timeseries_is_fractional <- (
        ha_timeseries_is_fractional || !ud.are.convertible(varunit$value, "m2")
      )
    } else {
      # Close all open NetCDF files
      invisible(sapply(ha_timeseries_files, nc_close))
      stop(
        "Variable ", sQuote(v), " in ",
        sQuote(file.path(working_dir, filename)),
        " has no unit attribute."
      )
    }
  }
  # Check that file has finished processing
  year_processed <- c(
    year_processed,
    ncvar_get(nc = ha_timeseries_files[[filename]], varid = "year_processed")
  )
}
# Consistency check
# Does harvested area time series cover full output period?
if (min(cft_output_period) < min(ha_timeseries_startyears) ||
  max(cft_output_period) > max(ha_timeseries_endyears)
) {
  invisible(sapply(ha_timeseries_files, nc_close))
  stop(
    "cft_output_period (",
    min(cft_output_period), "-", max(cft_output_period),
    ") not fully covered by harvested area time series range (",
    min(ha_timeseries_startyears), "-",
    max(ha_timeseries_endyears),
    ")"
  )
}
# Have all years in ha_timeseries_files finished processing?
missing <- which(
  (year_processed != 1 | is.na(year_processed)) &
  fileyears >= min(cft_output_period) & fileyears <= max(cft_output_period)
)
if (length(missing) > 0) {
  invisible(sapply(ha_timeseries_files, nc_close))
  stop(
    "The following year(s) included in cft_output_period (",
    min(cft_output_period), "-", max(cft_output_period),
    ") have not finished processing in harvested area time series files: ",
    toString(fileyears[missing])
  )
}
# If any of the harvested area timeseries files is fractional load HYDE area
ha_timeseries_raster <- raster(
  ha_timeseries_files[[filename]]$filename,
  varname = v,
  level = 1
)
if (ha_timeseries_is_fractional) {
  ha_timeseries_area <- load_hyde_area(
    hyde_area_file,
    unitraster = ha_timeseries_raster,
    faounit = fao_area_units
  )
  ha_timeseries_area_units <- ha_timeseries_area$unit
  ha_timeseries_area <- ha_timeseries_area$area
}
## 2) hyde_grazing                                                            ##
if ("hyde_grazing" %in% sapply(
  cft_mapping,
  function(indata) return(indata$source)
)) {
  # NetCDF variables that must be present in files
  grazing_bands <- which(
    sapply(
      cft_mapping,
      function(indata, search) {
        return(length(indata) > 0 && indata$source == search)
      },
      search = "hyde_grazing"
    )
  )
  hyde_grazing_vars_req <- unique(
    sapply(
      cft_mapping[grazing_bands],
      function(indata) return(indata$variable)
    )
  )
  # Collect information on source file(s)
  # hyde_grazing_filename is defined in landuse_setup.R
  hyde_grazing_is_fractional <- FALSE
  hyde_grazing_files <- list()
  hyde_grazing_startyears <- rep(NA, length(hyde_grazing_filename))
  hyde_grazing_endyears <- rep(NA, length(hyde_grazing_filename))
  names(hyde_grazing_startyears) <- hyde_grazing_filename
  names(hyde_grazing_endyears) <- hyde_grazing_filename
  for (filename in hyde_grazing_filename) {
    hyde_grazing_files[[filename]] <- nc_open(filename)
    missing <- setdiff(
      hyde_grazing_vars_req,
      names(hyde_grazing_files[[filename]]$var)
    )
    if (length(missing) > 0) {
      message(
        "Error: Aborting because variable(s) ",
        toString(sQuote(missing)), " missing in ",
        sQuote(hyde_grazing_files[[filename]]$filename)
      )
      # Close all open NetCDF files
      invisible(sapply(ha_timeseries_files, nc_close))
      invisible(sapply(hyde_grazing_files, nc_close))
      stop("Incompatible HYDE grazing time series NetCDF")
    }
    # Determine years included in file
    timeunit <- hyde_grazing_files[[filename]]$dim$time$units
    refyear <- as.integer(
      format.Date(gsub("days|years since ", "", timeunit), "%Y")
    )
    hyde_grazing_startyears[filename] <- min(
      refyear + hyde_grazing_files[[filename]]$dim$time$vals
    )
    hyde_grazing_endyears[filename] <- max(
      refyear + hyde_grazing_files[[filename]]$dim$time$vals
    )
    # Check variable unit
    for (v in hyde_grazing_vars_req) {
      varunit <- ncatt_get(hyde_grazing_files[[filename]], v, "units")
      if (varunit$hasatt) {
        hyde_grazing_is_fractional <- (
          hyde_grazing_is_fractional || !ud.are.convertible(varunit$value, "m2")
        )
      } else {
        # Close all open NetCDF files
        invisible(sapply(hyde_grazing_files, nc_close))
        invisible(sapply(ha_timeseries_files, nc_close))
        stop(
          "Variable ", sQuote(v),
          " in ", sQuote(filename),
          " has no unit attribute."
        )
      }
    }
  }
  hyde_grazing_raster <- raster(
    hyde_grazing_files[[filename]]$filename,
    varname = v,
    level = 1
  )
  # Load HYDE area to to convert fractional values into absolute areas and/or
  # check that HYDE data do not exceed available grid area.
  hyde_grazing_area <- load_hyde_area(
    hyde_area_file,
    unitraster = hyde_grazing_raster,
    faounit = fao_area_units
  )
  hyde_grazing_area_units <- hyde_grazing_area$unit
  hyde_grazing_area <- hyde_grazing_area$area
  # Consistency check
  # Does grazing data cover full output period?
  if (min(cft_output_period) < min(hyde_grazing_startyears) ||
    max(cft_output_period) > max(hyde_grazing_endyears)
  ) {
    # Close all open NetCDF files
    invisible(sapply(hyde_grazing_files, nc_close))
    invisible(sapply(ha_timeseries_files, nc_close))
    stop(
      "cft_output_period (",
      min(cft_output_period), "-", max(cft_output_period),
      ") not fully covered by HYDE grazing land time series range (",
      min(hyde_grazing_startyears), "-", max(hyde_grazing_endyears),
      ")"
    )
  }
}

## 3) hyde_rainfed and hyde_irrigated
hyde_rainfed_is_fractional <- hyde_irrigated_is_fractional <- FALSE
hyde_rainfed_files <- hyde_irrigated_files <- list()
for (irr in c("rainfed", "irrigated")) {
  # NetCDF variables that must be present in files for hyde_rainfed/
  # hyde_irrigated
  cropland_bands <- which(
    sapply(
      cft_mapping,
      function(indata, search) {
        return(length(indata) > 0 && indata$source == search)
      },
      search = paste0("hyde_", irr)
    )
  )
  hydevar_req <- unique(
    c(
      sapply(
        cft_mapping[cropland_bands],
        function(indata) return(indata$variable)
      ),
      get(paste0("hyde_", irr, "_varname"))
    )
  )
  # Collect information on NetCDF file(s)
  # hyde_rainfed_filename and hyde_irrigated_filename defined in
  # landuse_setup.R
  hydevar_startyears <- hydevar_endyears <- rep(
    NA, length(get(paste0("hyde_", irr, "_filename")))
  )
  names(hydevar_startyears) <- names(hydevar_endyears) <- get(
    paste0("hyde_", irr, "_filename")
  )
  hydevar_files <- list()
  hydevar_is_fractional <- FALSE
  for (filename in get(paste0("hyde_", irr, "_filename"))) {
    hydevar_files[[filename]] <- nc_open(filename)
    if (any(!hydevar_req %in% names(hydevar_files[[filename]]$var))) {
      message(
        "Error: Aborting because variable(s) ",
        toString(
          sQuote(setdiff(hydevar_req, names(hydevar_files[[filename]]$var)))
        ),
        " missing in ",
        sQuote(hydevar_files[[filename]]$filename)
      )
      # Close all open NetCDF files
      invisible(sapply(ha_timeseries_files, nc_close))
      invisible(sapply(hydevar_files, nc_close))
      if (exists("hyde_grazing_files")) {
        invisible(sapply(hyde_grazing_files, nc_close))
      }
      stop("Incompatible HYDE cropland time series NetCDF")
    }
    # Determine years included in file
    timeunit <- hydevar_files[[filename]]$dim$time$units
    refyear <- as.integer(
      format.Date(gsub("days|years since ", "", timeunit), "%Y")
    )
    hydevar_startyears[filename] <- min(
      refyear + hydevar_files[[filename]]$dim$time$vals
    )
    hydevar_endyears[filename] <- max(
      refyear + hydevar_files[[filename]]$dim$time$vals
    )
    # Check variable uni
    for (v in hydevar_req) {
      varunit <- ncatt_get(hydevar_files[[filename]], v, "units")
      if (varunit$hasatt) {
        hydevar_is_fractional <- (
          hydevar_is_fractional || !ud.are.convertible(varunit$value, "m2")
        )
      } else {
        # Close all open NetCDF files
        invisible(sapply(ha_timeseries_files, nc_close))
        invisible(sapply(hydevar_files, nc_close))
        if (exists("hyde_grazing_files")) {
          invisible(sapply(hyde_grazing_files, nc_close))
        }
        stop(
          "Variable ", sQuote(v),
          " in ", sQuote(filename),
          " has no unit attribute."
        )
      }
    }
  }
  # Consistency check
  # Does cropland time series cover the full output period?
  if (min(cft_output_period) < min(hydevar_startyears) ||
    max(cft_output_period) > max(hydevar_endyears)
  ) {
    # Close all open NetCDF files
    invisible(sapply(ha_timeseries_files, nc_close))
    invisible(sapply(hydevar_files, nc_close))
    if (exists("hyde_grazing_files")) {
      invisible(sapply(hyde_grazing_files, nc_close))
    }
    stop(
      "cft_output_period (",
      min(cft_output_period), "-", max(cft_output_period),
      ") not fully covered by HYDE ", irr,
      " cropland time series range (",
      min(hydevar_startyears), "-", max(hydevar_endyears),
      ")"
    )
  }
  # Asign to irrigation-specific variables
  assign(
    paste0("hyde_", irr, "_raster"),
    raster(hydevar_files[[filename]]$filename, varname = v, level = 1)
  )
  assign(paste0("hyde_", irr, "_files"), hydevar_files)
  assign(paste0("hyde_", irr, "_startyears"), hydevar_startyears)
  assign(paste0("hyde_", irr, "_endyears"), hydevar_endyears)
  assign(paste0("hyde_", irr, "_is_fractional"), hydevar_is_fractional)
  assign(paste0("hyde_", irr, "_vars_req"), hydevar_req)
  if (exists("hyde_grazing_area")) {
    # Reuse HYDE area if available, change if you use different sources for
    # cropland and grazing land
    assign(paste0("hyde_", irr, "_area"), hyde_grazing_area)
    assign(paste0("hyde_", irr, "_area_units"), hyde_grazing_area_units)
  } else {
    tmpraster <- raster(
      hydevar_files[[filename]]$filename,
      varname = v,
      level = 1
    )
    hydevar_area <- load_hyde_area(
      hyde_area_file,
      unitraster = tmpraster,
      faounit = fao_area_units
    )
    hydevar_area_units <- hydevar_area$unit
    hydevar_area <- hydevar_area$area
    assign(paste0("hyde_", irr, "_area"), hydevar_area)
    assign(paste0("hyde_", irr, "_area_units"), hydevar_area_units)
    rm(hydevar_area, hydevar_area_units)
    rm(tmpraster)
  }
}
################################################################################


################################################################################
## Gather information to determine resolution and extent of created CFT input ##
## file.                                                                      ##
# Read grid file and check for resolution and spatial extent
cft_gridheader <- read_header(cft_gridname)
cft_gridfile <- file(cft_gridname, "rb")
seek(cft_gridfile, get_headersize(cft_gridheader))
cft_griddata <- matrix(
  readBin(
    cft_gridfile,
    what = get_datatype(cft_gridheader)$type,
    size = get_datatype(cft_gridheader)$size,
    n = cft_gridheader$header["nbands"] * cft_gridheader$header["ncell"],
    endian = cft_gridheader$endian
  ) * cft_gridheader$header["scalar"],
  ncol = cft_gridheader$header["nbands"],
  byrow = cft_gridheader$header["order"] != 4
)
close(cft_gridfile)
# Create raster object corresponding to grid data
cft_extent <- extent(
  min(cft_griddata[, 1] - cft_gridheader$header["cellsize_lon"] / 2),
  max(cft_griddata[, 1] + cft_gridheader$header["cellsize_lon"] / 2),
  min(cft_griddata[, 2] - cft_gridheader$header["cellsize_lat"] / 2),
  max(cft_griddata[, 2] + cft_gridheader$header["cellsize_lat"] / 2)
)
cft_raster <- raster(
  cft_extent,
  resolution = cft_gridheader$header[c("cellsize_lon", "cellsize_lat")]
)
# Determine indices of grid cells in raster for later data extraction
cft_raster_gridindex <- cellFromXY(cft_raster, cft_griddata)
cat(
  "LPJmL grid file: ", cft_gridname,
  " (ncell=", cft_gridheader$header["ncell"],
  ", cellsize_lon=", round(cft_gridheader$header["cellsize_lon"], 8),
  ", cellsize_lat=", round(cft_gridheader$header["cellsize_lat"], 8),
  ")\n",
  sep = ""
)
# Add resolution string to filename of file(s) generated by this script
tmp_res <- unique(60 * cft_gridheader$header[c("cellsize_lon", "cellsize_lat")])
tmp_string <- paste(round(tmp_res), "min", sep = "", collapse = "_by_")
cft_output_filename <- paste0(cft_output_filename, tmp_string, "_")
# Country file
cft_cowheader <- read_header(cft_cowname)
if (cft_cowheader$header["ncell"] != cft_gridheader$header["ncell"]) {
  invisible(sapply(ha_timeseries_files, nc_close))
  invisible(sapply(hyde_rainfed_files, nc_close))
  invisible(sapply(hyde_irrigated_files, nc_close))
  if (exists("hyde_grazing_files")) {
    invisible(sapply(hyde_grazing_files, nc_close))
  }
  stop(
    "Country file ", sQuote(cft_cowname),
    " does not match grid data ", sQuote(cft_gridname), "\n"
  )
}
cft_cowfile <- file(cft_cowname, "rb")
seek(cft_cowfile, get_headersize(cft_cowheader))
cft_cowdata <- matrix(
  readBin(
    cft_cowfile,
    what = get_datatype(cft_cowheader)$type,
    size = get_datatype(cft_cowheader)$size,
    n = cft_cowheader$header["nbands"] * cft_cowheader$header["ncell"],
    endian = cft_cowheader$endian
  ) * cft_cowheader$header["scalar"],
  ncol = cft_cowheader$header["nbands"],
  byrow = cft_cowheader$header["order"] != 4
)
close(cft_cowfile)
# Corresponding country names
if (exists("cft_cowmetaname") && nchar(cft_cowmetaname) > 0 &&
  file.exists(cft_cowmetaname)
) {
  cft_cowmetadata <- read.csv(
    cft_cowmetaname,
    stringsAsFactors = FALSE,
    comment.char = "#"
  )
  if (all(cft_cowdata[, 1] %in% cft_cowmetadata$ID)) {
    cat(
      "Assuming that country codes in", sQuote(cft_cowname),
      "match country names in", sQuote(cft_cowmetaname), "\n"
    )
    missing <- which(!cft_cowmetadata$ID %in% cft_cowdata[, 1])
    if (length(missing) > 0) {
      warning(
        sQuote(cft_cowname), " and ", sQuote(cft_cowmetaname),
        " may be incompatible because the following country names from ",
        sQuote(cft_cowmetaname), " are not assigned to a single cell:\n",
        toString(sQuote(cft_cowmetadata$country[missing])),
        call. = FALSE,
        immediate. = TRUE
      )
    }
    cft_cow_usenames <- TRUE
  } else {
    warning(
      "Provided files ", sQuote(cft_cowname), " and ", sQuote(cft_cowmetaname),
      " appear to be incompatible.\nNot using country names in ",
      sQuote(cft_cowmetaname),
      call. = FALSE,
      immediate. = TRUE
    )
    cft_cow_usenames <- FALSE
  }
} else {
  cft_cow_usenames <- FALSE
}

# Check that grid resolution and spatial extent fit to source data
# Names of sources to check
source_check <- c(
  "ha_timeseries_raster",
  "hyde_rainfed_raster",
  "hyde_irrigated_raster",
  "hyde_grazing_raster"
)
# Name of aggregation scalar corresponding to each variable in source_check
source_scalar <- c(
  "cft2harvested_area",
  "cft2rainfed",
  "cft2irrigated",
  "cft2grazing"
)
# Perform checks for each raster named in source_check
for (check in seq_along(source_check)) {
  if (!exists(source_check[check])) {
    message(
      "Skipping check of source raster ",
      source_check[check],
      " because it does not exist."
    )
    next
  }
  # Retrieve source raster to check
  source_raster <- get(source_check[check])
  # Aggregation factor/resolution
  cft2source <- round(res(cft_raster) / res(source_raster), 6)
  # Check if aggregation factor is valid
  if (min(cft2source) < 1) {
    invisible(sapply(ha_timeseries_files, nc_close))
    invisible(sapply(hyde_rainfed_files, nc_close))
    invisible(sapply(hyde_irrigated_files, nc_close))
    if (exists("hyde_grazing_files")) {
      invisible(sapply(hyde_grazing_files, nc_close))
    }
    stop(
      "Grid resolution of ", sQuote(cft_gridname),
      " is too fine for resolution of ", source_check[check]
    )
  }
  if (max(cft2source %% 1) > 0) {
    invisible(sapply(ha_timeseries_files, nc_close))
    invisible(sapply(hyde_rainfed_files, nc_close))
    invisible(sapply(hyde_irrigated_files, nc_close))
    if (exists("hyde_grazing_files")) {
      invisible(sapply(hyde_grazing_files, nc_close))
    }
    stop(
      "Spatial resolution of ", sQuote(cft_gridname),
      " is not an integer multiple of resolution of ", source_check[check]
    )
  }
  # Spatial extent
  if ((xmin(cft_raster) - xmin(source_raster)) < (-xres(cft_raster) / 100)) {
    invalid <- which(
      (cft_griddata[, 1] - xres(cft_raster) / 2 - xmin(source_raster)) <
      (-xres(cft_raster) / 100)
    )
    invisible(sapply(ha_timeseries_files, nc_close))
    invisible(sapply(hyde_rainfed_files, nc_close))
    invisible(sapply(hyde_irrigated_files, nc_close))
    if (exists("hyde_grazing_files")) {
      invisible(sapply(hyde_grazing_files, nc_close))
    }
    stop(
      length(invalid), " cells of ", sQuote(cft_gridname),
      " are outside of western bound of ", source_check[check], " (",
      xmin(source_raster),
      "deg)"
    )
  }
  if ((xmax(cft_raster) - xmax(source_raster)) > (xres(cft_raster) / 100)) {
    invalid <- which(
      (cft_griddata[, 1] + xres(cft_raster) / 2 - xmax(source_raster)) >
      (xres(cft_raster) / 100)
    )
    invisible(sapply(ha_timeseries_files, nc_close))
    invisible(sapply(hyde_rainfed_files, nc_close))
    invisible(sapply(hyde_irrigated_files, nc_close))
    if (exists("hyde_grazing_files")) {
      invisible(sapply(hyde_grazing_files, nc_close))
    }
    stop(
      length(invalid), " cells of ", sQuote(cft_gridname),
      "are outside of eastern bound of ", source_check[check], " (",
      xmax(source_raster),
      "deg)"
    )
  }
  if ((ymin(cft_raster) - ymin(source_raster)) < (-yres(cft_raster) / 100)) {
    invalid <- which(
      (cft_griddata[, 2] - yres(cft_raster) / 2 - ymin(source_raster)) <
      (-yres(cft_raster) / 100)
    )
    invisible(sapply(ha_timeseries_files, nc_close))
    invisible(sapply(hyde_rainfed_files, nc_close))
    invisible(sapply(hyde_irrigated_files, nc_close))
    if (exists("hyde_grazing_files")) {
      invisible(sapply(hyde_grazing_files, nc_close))
    }
    stop(
      length(invalid), " cells of ", sQuote(cft_gridname),
      " are outside of southern bound of ", source_check[check], " (",
      xmin(source_raster),
      "deg)"
    )
  }
  if ((ymax(cft_raster) - ymax(source_raster)) > (yres(cft_raster) / 100)) {
    invalid <- which(
      (cft_griddata[, 2] + yres(cft_raster) / 2 - ymax(source_raster)) >
      (yres(cft_raster) / 100)
    )
    invisible(sapply(ha_timeseries_files, nc_close))
    invisible(sapply(hyde_rainfed_files, nc_close))
    invisible(sapply(hyde_irrigated_files, nc_close))
    if (exists("hyde_grazing_files")) {
      invisible(sapply(hyde_grazing_files, nc_close))
    }
    stop(
      length(invalid), " cells of ", sQuote(cft_gridname),
      " are outside of northern bound of ", source_check[check], " (",
      ymax(source_raster),
      "deg)"
    )
  }
  # Origin (cell boundaries align)
  xborder <- abs(xmin(cft_raster) - xmin(source_raster))
  min_xres <- min(xres(cft_raster), xres(source_raster))
  yborder <- abs(ymin(cft_raster) - ymin(source_raster))
  min_yres <- min(yres(cft_raster), yres(source_raster))
  if (round(xborder / min_xres, 3) %% 1 != 0 ||
    round(yborder / min_yres, 3) %% 1 != 0
  ) {
    invisible(sapply(ha_timeseries_files, nc_close))
    invisible(sapply(hyde_rainfed_files, nc_close))
    invisible(sapply(hyde_irrigated_files, nc_close))
    if (exists("hyde_grazing_files")) {
      invisible(sapply(hyde_grazing_files, nc_close))
    }
    stop(
      "Cell boundaries in ", sQuote(cft_gridname),
      " do not align with cell boundaries in ", source_check[check]
    )
  }
  # Assign dataset-specific aggregation factor
  assign(source_scalar[check], cft2source)
}
################################################################################


################################################################################
## Prepare and write LPJmL input file(s)                                      ##
## File preparation                                                           ##
# File unit and cell areas
cft_is_fraction <- !ud.are.convertible(cft_output_units, "m2")
cft_gridarea <- cellarea(
  cft_griddata[, 2],
  cft_gridheader$header["cellsize_lon"],
  cft_gridheader$header["cellsize_lat"]
) * ud.convert(1, "m2", fao_area_units) # cellarea() returns m2
# Filename of CFT input file
cft_output_filename <- paste0(
  cft_output_filename,
  min(cft_output_period), "-", max(cft_output_period),
  ".bin"
)
if (file.exists(cft_output_filename)) {
  invisible(sapply(ha_timeseries_files, nc_close))
  invisible(sapply(hyde_rainfed_files, nc_close))
  invisible(sapply(hyde_irrigated_files, nc_close))
  if (exists("hyde_grazing_files")) {
    invisible(sapply(hyde_grazing_files, nc_close))
  }
  stop(
    "cft_output_filename ", sQuote(cft_output_filename), " exists already.\n",
    "Delete or rename file to create again."
  )
}
cat(
  "Preparing to write LPJmL input file ", sQuote(cft_output_filename),
  " with ", length(cft_bands), " bands covering ",
  max(cft_output_period) - min(cft_output_period) + 1, " years (",
  min(cft_output_period), "-", max(cft_output_period),
  ")\n",
  sep = ""
)
cat(
  "Area unit:", sQuote(cft_output_units),
  ifelse(
    nchar(cft_output_units) == 0 || cft_output_units == "1",
    "(fraction)\n",
    "\n"
  )
)
if (any(sapply(cft_mapping, length) == 0)) {
  message(
    "The following crops have no defined source data and will be empty: ",
    toString(sQuote(names(which(sapply(cft_mapping, length) == 0))))
  )
}
if (scale_down_cfts2cropland) {
  cat(
    "Harvested areas of crops exceeding physical cropland will be scaled",
    "down to fit into physical cropland.\n"
  )
} else {
  cat(
    "Harvested areas of crops exceeding physical cropland will **not** be",
    "scaled down to fit into physical cropland. Warning: This file is",
    "probably not compatible with current LPJmL.\n"
  )
}
# Filename of separate fallow land file
if (cft_separate_fallow) {
  if (dirname(cft_output_filename_base) != ".") {
    cft_fallow_filename <- file.path(
      dirname(cft_output_filename_base),
      sub(
        paste0("^", basename(cft_output_filename_base)),
        paste0(basename(cft_output_filename_base), fallow_name, "_"),
        basename(cft_output_filename)
      )
    )
  } else {
    cft_fallow_filename <- sub(
      paste0("^", basename(cft_output_filename_base)),
      paste0(basename(cft_output_filename_base), fallow_name, "_"),
      basename(cft_output_filename)
    )
  }
  cat(
    "Also creating separate LPJmL input file", sQuote(cft_fallow_filename),
    "for fallow land.\n"
  )
  if (file.exists(cft_fallow_filename)) {
    invisible(sapply(ha_timeseries_files, nc_close))
    invisible(sapply(hyde_rainfed_files, nc_close))
    invisible(sapply(hyde_irrigated_files, nc_close))
    if (exists("hyde_grazing_files")) {
      invisible(sapply(hyde_grazing_files, nc_close))
    }
    stop(
      "cft_fallow_filename ", sQuote(cft_fallow_filename), " exists already.\n",
      "Delete or rename file to create again."
    )
  }
}
# Filename of separate cropland file
if (cft_separate_cropland) {
  if (dirname(cft_output_filename_base) != ".") {
    cft_cropland_filename <- file.path(
      dirname(cft_output_filename_base),
      sub(
        paste0("^", basename(cft_output_filename_base)),
        paste0(basename(cft_output_filename_base), cropland_name, "_"),
        basename(cft_output_filename)
      )
    )
  } else {
    cft_cropland_filename <- sub(
      paste0("^", basename(cft_output_filename_base)),
      paste0(basename(cft_output_filename_base), cropland_name, "_"),
      basename(cft_output_filename)
    )
  }
  cat(
    "Also creating separate LPJmL input file", sQuote(cft_cropland_filename),
    "for cropland.\n"
  )
  if (file.exists(cft_cropland_filename)) {
    invisible(sapply(ha_timeseries_files, nc_close))
    invisible(sapply(hyde_rainfed_files, nc_close))
    invisible(sapply(hyde_irrigated_files, nc_close))
    if (exists("hyde_grazing_files")) {
      invisible(sapply(hyde_grazing_files, nc_close))
    }
    stop(
      "cft_cropland_filename ", sQuote(cft_cropland_filename),
      " exists already.\nDelete or rename file to create again."
    )
  }
}
# Generate file(s) and write file header(s)
cft_output_header <- create_header(
  name = "LPJLUSE",
  version = 3,
  order = 1,
  firstyear = min(cft_output_period),
  nyear = max(cft_output_period) - min(cft_output_period) + 1,
  ncell = cft_gridheader$header["ncell"],
  nbands = length(cft_bands),
  cellsize_lon = cft_gridheader$header["cellsize_lon"],
  scalar = 1.0,
  cellsize_lat = cft_gridheader$header["cellsize_lat"],
  datatype = 3 # Use float
)
# Note: If you want to make sure that write_header() does not overwrite an
# existing file set overwrite = FALSE
# By default, the existance of the files is checked above.
write_header(cft_output_filename, cft_output_header, overwrite = TRUE)
cft_output_file <- file(cft_output_filename, "ab")
if (cft_separate_fallow) {
  cft_fallow_header <- cft_output_header
  cft_fallow_header$header["nbands"] <- 2
  write_header(cft_fallow_filename, cft_fallow_header, overwrite = TRUE)
  cft_fallow_file <- file(cft_fallow_filename, "ab")
}
if (cft_separate_cropland) {
  cft_cropland_header <- cft_output_header
  cft_cropland_header$header["nbands"] <- 2
  write_header(cft_cropland_filename, cft_cropland_header, overwrite = TRUE)
  cft_cropland_file <- file(cft_cropland_filename, "ab")
}

cft_missing_grid <- integer(length(cft_mapping))
names(cft_missing_grid) <- names(cft_mapping)

## Process data year by year                                                  ##
for (year in min(cft_output_period):max(cft_output_period)) {
  cat("*** Year", year, "***\n")
  # Dummy for one year of CFT data
  cft_output_yeardata <- array(
    dim = c(
      cft_output_header$header["nbands"],
      cft_output_header$header["ncell"]
    ),
    dimnames = list(cft_bands, NULL)
  )
  if (cft_separate_fallow) {
    # Dummy for one year of fallow land data
    cft_fallow_yeardata <- array(
      dim = c(
        cft_fallow_header$header["nbands"],
        cft_fallow_header$header["ncell"]
      ),
      dimnames = list(paste(c("rainfed", "irrigated"), fallow_name), NULL)
    )
  }
  if (cft_separate_cropland) {
    # Dummy for one year of cropland data
    cft_cropland_yeardata <- array(
      dim = c(
        cft_cropland_header$header["nbands"],
        cft_cropland_header$header["ncell"]
      ),
      dimnames = list(paste(c("rainfed", "irrigated"), cropland_name), NULL)
    )
  }
  # Grazing land source data for this year
  # Note: current cft_mapping does not have irrigated grazing land. Load
  # separately if you distinguish rainfed and irrigated pastures.
  # See helper/load_hyde_yeardata.R for function definition.
  if (exists("hyde_grazing_raster")) {
    hyde_grazing_yeardata <- load_hyde_yeardata(
      year = year,
      file_startyears = hyde_grazing_startyears,
      file_endyears = hyde_grazing_endyears,
      file_list = hyde_grazing_files,
      file_raster = hyde_grazing_raster,
      vars_req = hyde_grazing_vars_req,
      area_raster = hyde_grazing_area,
      target_unit = fao_area_units,
      target_raster = cft_raster,
      target_varname = "hyde_grazing_yeardata",
      fact = cft2grazing,
      enforce_grid_max = TRUE
    )
  }
  # Cropland and harvested areas are specific per irrigation status
  for (irr in c("rainfed", "irrigated")) {
    # Cropland source data for this year
    hydevar <- paste0("hyde_", irr)
    hydevar_yeardata <- load_hyde_yeardata(
      year = year,
      file_startyears = get(paste0(hydevar, "_startyears")),
      file_endyears = get(paste0(hydevar, "_endyears")),
      file_list = get(paste0(hydevar, "_files")),
      file_raster = get(paste0(hydevar, "_raster")),
      vars_req = get(paste0(hydevar, "_vars_req")),
      area_raster = get(paste0(hydevar, "_area")),
      target_unit = fao_area_units,
      target_raster = cft_raster,
      target_varname = paste0(hydevar, "_yeardata"),
      fact = get(paste0("cft2", irr)),
      enforce_grid_max = TRUE
    )

    # Harvested area source data for this year
    # Determine from cft_mapping which NetCDF variables are needed
    tmpvars <- as.character(
      na.omit(
        unique(
          sapply(
            cft_mapping[grep(paste0("^", irr), names(cft_mapping))],
            function(indata, search, parameter) {
              return(
                ifelse(
                  is.null(indata$source),
                  NA,
                  ifelse(
                    indata$source == search,
                    indata[[parameter]],
                    NA
                  )
                )
              )
            },
            search = "ha_timeseries",
            parameter = "variable"
          )
        )
      )
    )
    # See helper/load_ha_yeardata.R for function definition.
    ha_timeseries_yeardata <- load_ha_yeardata(
      year = year,
      file_startyears = ha_timeseries_startyears,
      file_endyears = ha_timeseries_endyears,
      file_list = ha_timeseries_files,
      file_raster = ha_timeseries_raster,
      vars_req = tmpvars,
      area_raster = ha_timeseries_area,
      target_unit = fao_area_units,
      target_raster = cft_raster,
      target_varname = "ha_timeseries_yeardata",
      fact = cft2harvested_area
    )

    # Combine source data into CFT output array
    for (cft in grep(paste0("^", irr), cft_bands, value = TRUE)) {
      if (length(cft_mapping[[cft]]) == 0) {
        # Empty band, set all values to 0
        cft_output_yeardata[cft, ] <- 0
        if (year == min(cft_output_period)) {
          # Print info message once
          cat("CFT ", sQuote(cft), ": empty source\n", sep = "")
        }
        next
      }
      if (cft_mapping[[cft]]$source == "fallow") {
        # Do after crop loop since it is calculated from cropland not occupied
        # by any crop
        next
      }
      v <- cft_mapping[[cft]]$variable
      if (cft_mapping[[cft]]$source == "hyde_grazing") {
        if (any(!v %in% dimnames(hyde_grazing_yeardata)[[2]])) {
          message(
            "Error: Variable ",
            toString(
              sQuote(setdiff(v, dimnames(hyde_grazing_yeardata)[[2]]))
            ),
            " in source ", sQuote(cft_mapping[[cft]]$source),
            " for CFT ", sQuote(cft),
            " missing. Setting values to zero. Please fix cft_mapping."
          )
          cft_output_yeardata[cft, ] <- 0
          next
        }
        if (year == min(cft_output_period)) {
          # Print info message about mapping once
          cat(
            "CFT ", sQuote(cft), ": ",
            sQuote(cft_mapping[[cft]]$source), "->",
            toString(sQuote(v)), "->",
            ifelse(
              !is.null(cft_mapping[[cft]]$band),
              toString(sQuote(cft_mapping[[cft]]$band)),
              ""
            ),
            "\n",
            sep = ""
          )
        }
        # Extract data for cells in cft_griddata
        cft_output_yeardata[cft, ] <- rowSums(
          array(
            hyde_grazing_yeardata[cft_raster_gridindex, v],
            dim = c(length(cft_raster_gridindex), length(v))
          ),
          na.rm = TRUE
        )
      } else if (cft_mapping[[cft]]$source == hydevar) {
        if (any(!v %in% dimnames(hydevar_yeardata)[[2]])) {
          message(
            "Error: Variable ",
            toString(sQuote(setdiff(v, dimnames(hydevar_yeardata)[[2]]))),
            " in source ", sQuote(cft_mapping[[cft]]$source),
            " for CFT ", sQuote(cft),
            "missing. Setting values to zero. Please fix cft_mapping."
          )
          cft_output_yeardata[cft, ] <- 0
          next
        }
        if (year == min(cft_output_period)) {
          # Print info message about mapping once
          cat(
            "CFT ", sQuote(cft), ": ",
            sQuote(cft_mapping[[cft]]$source), "->",
            totring(sQuote(v)), "->",
            ifelse(
              !is.null(cft_mapping[[cft]]$band),
              toString(sQuote(cft_mapping[[cft]]$band)),
              ""
            ),
            "\n",
            sep = ""
          )
        }
        # Extract data for cells in cft_griddata
        cft_output_yeardata[cft, ] <- rowSums(
          hydevar_yeardata[cft_raster_gridindex, v],
          na.rm = TRUE
        )
      } else if (cft_mapping[[cft]]$source == "ha_timeseries") {
        if (any(!v %in% dimnames(ha_timeseries_yeardata)[[3]])) {
          message(
            "Error: Variable ",
            toString(
              sQuote(setdiff(v, dimnames(ha_timeseries_yeardata)[[3]]))
            ),
            " in source ", sQuote(cft_mapping[[cft]]$source),
            " for CFT ", sQuote(cft),
            "missing. Setting values to zero. Please fix cft_mapping."
          )
          cft_output_yeardata[cft, ] <- 0
          next
        }
        missing <- which(!cft_mapping[[cft]]$band %in%
          dimnames(ha_timeseries_yeardata)[[2]]
        )
        if (length(missing) == length(cft_mapping[[cft]]$band)) {
          # None of the bands are available, set output to 0
          message(
            "Error: All ", length(cft_mapping[[cft]]$band), " bands (",
            toString(sQuote(cft_mapping[[cft]]$band[missing])),
            ") defined for CFT ", sQuote(cft),
            " not available in source. Setting values to zero. ",
            "Please fix cft_mapping."
          )
          cft_output_yeardata[cft, ] <- 0
          next
        }
        if (length(missing) > 0) {
          # Only part of the bands are available, use data but print warning
          message(
            "Error: ", length(missing),
            " out of ", length(cft_mapping[[cft]]$band), " bands (",
            toString(sQuote(cft_mapping[[cft]]$band[missing])),
            ") defined for CFT ", sQuote(cft),
            " not available in source. Using remaining bands. ",
            "Please fix cft_mapping."
          )
        }
        # Aggregate bands from source data
        bands <- intersect(
          cft_mapping[[cft]]$band,
          dimnames(ha_timeseries_yeardata)[[2]]
        )
        cft_output_yeardata[cft, ] <- rowSums(
          array(
            ha_timeseries_yeardata[cft_raster_gridindex, bands, v],
            dim = c(length(cft_raster_gridindex), length(bands), length(v))
          ),
          na.rm = TRUE
        )
        if (year == min(cft_output_period)) {
          # Print info message about mapping once
          cat(
            "CFT ", sQuote(cft), ": ",
            sQuote(cft_mapping[[cft]]$source), "->",
            toString(sQuote(v)), "->",
            ifelse(
              !is.null(cft_mapping[[cft]]$band),
              toString(sQuote(cft_mapping[[cft]]$band)),
              ""
            ),
            "\n",
            sep = ""
          )
        }
      } else {
        # Undefined source. If you added a new source above add code here to
        # assign data to cells.
        message(
          "Error: Source ", sQuote(cft_mapping[[cft]]$source),
          "for CFT ", sQuote(cft), " not defined. ",
          "Setting values to zero. Please fix cft_mapping."
        )
        cft_output_yeardata[cft, ] <- 0
      }
    }
    # Cropland data for cells in cft_griddata
    v <- get(paste0(hydevar, "_varname"))
    tmpcropland <- rowSums(
      array(
        hydevar_yeardata[cft_raster_gridindex, v],
        dim = c(length(cft_raster_gridindex), length(v))
      ),
      na.rm = TRUE
    )
    # Aggregate all CFT bands that occupy cropland (specific to irrigation
    # status)
    bands <- intersect(
      names(which(cft_bands_is_cropland)),
      grep(paste0("^", irr), cft_bands, value = TRUE)
    )
    tmphasum <- colSums(cft_output_yeardata[bands, ], na.rm = TRUE)
    # Check if there are CFT areas on cropland even though there is no
    # cropland. This can happen with rainfed harvested areas that are
    # allocated to irrigated cropland in harvested_area_timeseries.R
    exceeded <- which(tmphasum > 0 & tmpcropland == 0)
    if (length(exceeded) > 0 && scale_down_cfts2cropland) {
      cat(
        "There are",
        length(exceeded),
        "cells in",
        length(unique(cft_cowdata[exceeded, 1])),
        "countries with", irr, "harvested areas but no", irr,
        "cropland. These will be removed.\n"
      )
      if (cft_cow_usenames) {
        # If country names are available print country names
        cowtable <- data.frame(
          table(cft_cowdata[exceeded, 1])
        )
        cowtable <- cowtable[order(cowtable$Freq, decreasing = TRUE), ]
        print(
          data.frame(
            country = cft_cowmetadata$country[match(
              cowtable$Var1,
              cft_cowmetadata$ID
            )],
            cells = cowtable$Freq
          )
        )
      }
    }
    # Scale down CFT areas of crops that occupy cropland if
    # scale_down_cfts2cropland == TRUE
    if (scale_down_cfts2cropland) {
      scaling <- tmpcropland / tmphasum
      scaling[which(tmphasum == 0)] <- 0
      scaling[which(scaling > 1)] <- 1
      for (cft in bands) {
        cft_output_yeardata[cft, ] <- cft_output_yeardata[cft, ] * scaling
      }
    }
    # Calculate fallow land from unused cropland
    tmphasum <- colSums(cft_output_yeardata[bands, ], na.rm = TRUE)
    if (cft_include_fallow || cft_separate_fallow) {
      tmpfallow <- tmpcropland - tmphasum
      tmpfallow[which(tmpfallow < 0)] <- 0
      fallow_in_mapping <- names(
        which(
          sapply(
            cft_mapping,
            function(indata, source) {
              return(
                ifelse(
                  length(indata) == 0,
                  FALSE,
                  indata$source == source
                )
              )
            },
            source = "fallow"
          )
        )
      )
      for (cft in intersect(
        grep(paste0("^", irr), fallow_in_mapping, value = TRUE),
        dimnames(cft_output_yeardata)[[1]]
      )) {
        cft_output_yeardata[cft, ] <- tmpfallow
      }
      if (cft_separate_fallow) {
        for (cft in intersect(
          grep(paste0("^", irr), fallow_in_mapping, value = TRUE),
          dimnames(cft_fallow_yeardata)[[1]]
        )) {
          cft_fallow_yeardata[cft, ] <- tmpfallow
        }
      }
    }
    if (cft_separate_cropland) {
      # Extract data for optional cropland file
      cft_cropland_yeardata[paste(irr, cropland_name), ] <- rowSums(
        array(
          hydevar_yeardata[cft_raster_gridindex, v],
          dim = c(length(cft_raster_gridindex), length(v))
        ),
        na.rm = TRUE
      )
    }
  }
  # Check for missing values in output data
  tmpmissing <- apply(
    cft_output_yeardata,
    1,
    function(indata) length(which(is.na(indata)))
  )
  if (cft_separate_fallow && !cft_include_fallow) {
    tmpmissing <- c(
      tmpmissing,
      apply(
        cft_fallow_yeardata,
        1,
        function(indata) length(which(is.na(indata)))
      )
    )
  }
  if (cft_separate_cropland && !cft_include_cropland) {
    tmpmissing <- c(
      tmpmissing,
      apply(
        cft_cropland_yeardata,
        1,
        function(indata) length(which(is.na(indata)))
      )
    )
  }
  # Only print warning message about missing values if number has changed
  # compared to previously reported missing values. Avoid repeat warnings every
  # every year if cft_griddata includes cells outside landmask of source data
  bands <- intersect(names(tmpmissing), names(cft_missing_grid))
  change_missing <- names(which(tmpmissing[bands] != cft_missing_grid[bands]))
  if (length(change_missing) > 0) {
    cat(
      "The following bands have missing values which will be replaced by",
      "zero values. Missing values either point to differences in the land",
      "mask between", sQuote(cft_gridname),
      "and the gridded source data or to problems in the gridded source data.\n"
    )
    print(data.frame(Num_NAs = tmpmissing[change_missing]))
    cft_missing_grid[bands] <- tmpmissing[bands]
  }
  # Set missing values to 0 in output data since LPJmL does not understand
  # missing value.
  cft_output_yeardata <- pmax(cft_output_yeardata, 0, na.rm = TRUE)
  # Check if the sum of assigned CFT areas exceeds cell area in any cell.
  # Print warning if scale_down_cfts2cropland == TRUE
  # Do not include cropland bands if they are included in cft_mapping
  bands <- grep(
    cropland_name,
    dimnames(cft_output_yeardata)[[1]],
    invert = TRUE
  )
  tmpsum <- colSums(cft_output_yeardata[bands, ])
  if (scale_down_cfts2cropland && any(tmpsum > (cft_gridarea * 1.0001))) {
    message(
      "Info: Sum across CFT bands exceeds cell area in ",
      length(which(tmpsum > (cft_gridarea * 1.0001))),
      " cells by up to ",
      max(tmpsum - cft_gridarea), " ", fao_area_units
    )
  }
  if (cft_separate_cropland) {
    cft_cropland_yeardata <- pmax(cft_cropland_yeardata, 0, na.rm = TRUE)
    tmpsum <- colSums(cft_cropland_yeardata)
    if (any(tmpsum > (cft_gridarea * 1.01))) {
      warning(
        "Cropland exceeds cell area in ",
        length(which(tmpsum > (cft_gridarea * 1.01))),
        " cells by up to ",
        max(tmpsum - cft_gridarea), " ", fao_area_units,
        immediate. = TRUE, call. = FALSE
      )
    } else if (any(tmpsum > (cft_gridarea * 1.0001))) {
      message(
        "Info: cropland exceeds cell area in ",
        length(which(tmpsum > (cft_gridarea * 1.0001))),
        " cells by up to ",
        max(tmpsum - cft_gridarea), " ", fao_area_units
      )
    }
  }
  if (cft_separate_fallow) {
    cft_fallow_yeardata <- pmax(cft_fallow_yeardata, 0, na.rm = TRUE)
  }
  # If necessary, convert output data from absolute area to fractional unit
  if (cft_is_fraction) {
    cat(
      "Converting CFT data from",
      sQuote(fao_area_units),
      "to",
      sQuote(cft_output_units),
      "\n"
    )
    for (cft in dimnames(cft_output_yeardata)[[1]]) {
      cft_output_yeardata[cft, ] <- cft_output_yeardata[cft, ] /
        cft_gridarea * ud.convert(1, "", cft_output_units)
      # Last part takes care of relative units that are not fractional, e.g. %
    }
    if (cft_separate_fallow) {
      cat(
        "Converting", fallow_name, "data from",
        sQuote(fao_area_units),
        "to",
        sQuote(cft_output_units),
        "\n"
      )
      for (cft in dimnames(cft_fallow_yeardata)[[1]]) {
        cft_fallow_yeardata[cft, ] <- cft_fallow_yeardata[cft, ] /
          cft_gridarea * ud.convert(1, "", cft_output_units)
        # Last part takes care of relative units that are not fractional, e.g. %
      }
    }
    if (cft_separate_cropland) {
      cat(
        "Converting", cropland_name, "data from",
        sQuote(fao_area_units),
        "to",
        sQuote(cft_output_units),
        "\n"
      )
      for (cft in dimnames(cft_cropland_yeardata)[[1]]) {
        cft_cropland_yeardata[cft, ] <- cft_cropland_yeardata[cft, ] /
          cft_gridarea * ud.convert(1, "", cft_output_units)
        # Last part takes care of relative units that are not fractional, e.g. %
      }
    }
  } else if (ud.convert(1, fao_area_units, cft_output_units) != 1) {
    # If necessary, convert output data to final output unit
    cat(
      "Converting CFT data from",
      sQuote(fao_area_units),
      "to",
      sQuote(cft_output_units),
      "\n"
    )
    cft_output_yeardata <- cft_output_yeardata *
      ud.convert(1, fao_area_units, cft_output_units)
    if (cft_separate_fallow) {
      cat(
        "Converting", fallow_name, "data from",
        sQuote(fao_area_units),
        "to",
        sQuote(cft_output_units),
        "\n"
      )
      cft_fallow_yeardata <- cft_fallow_yeardata *
        ud.convert(1, fao_area_units, cft_output_units)
    }
    if (cft_separate_cropland) {
      cat(
        "Converting", cropland_name, "data from",
        sQuote(fao_area_units),
        "to",
        sQuote(cft_output_units),
        "\n"
      )
      cft_cropland_yeardata <- cft_cropland_yeardata *
        ud.convert(1, fao_area_units, cft_output_units)
    }
  }
  # Write data to files
  # LPJmL input files can have different datatypes defined in header.
  # Convert data to correct datatype.
  if (typeof(get_datatype(cft_output_header)$type) == "double") {
    writeBin(
      as.double(cft_output_yeardata / cft_output_header$header["scalar"]),
      cft_output_file,
      size = get_datatype(cft_output_header)$size,
      endian = cft_output_header$endian
    )
  } else if (typeof(get_datatype(cft_output_header)$type) == "integer") {
    if (year == min(cft_output_period)) {
      # Print message about reduced accuracy only once
      warning(
        "CFT data will be converted to ",
        typeof(get_datatype(cft_output_header)$type),
        " size ", get_datatype(cft_output_header)$size,
        " with a scalar of ", cft_output_header$header["scalar"],
        ", which has lower accuracy.",
        call. = FALSE,
        immediate. = TRUE
      )
    }
    writeBin(
      as.integer(
        round(cft_output_yeardata / cft_output_header$header["scalar"])
      ),
      cft_output_file,
      size = get_datatype(cft_output_header)$size,
      endian = cft_output_header$endian
    )
  } else {
    invisible(sapply(ha_timeseries_files, nc_close))
    invisible(sapply(hyde_rainfed_files, nc_close))
    invisible(sapply(hyde_irrigated_files, nc_close))
    if (exists("hyde_grazing_files")) {
      invisible(sapply(hyde_grazing_files, nc_close))
    }
    stop(
      "Unsupported data type in cft_output_header: ",
      cft_output_header$header["datatype"]
    )
  }
  if (cft_separate_cropland) {
    if (typeof(get_datatype(cft_cropland_header)$type) == "double") {
      writeBin(
        as.double(cft_cropland_yeardata / cft_cropland_header$header["scalar"]),
        cft_cropland_file,
        size = get_datatype(cft_cropland_header)$size,
        endian = cft_cropland_header$endian
      )
    } else if (typeof(get_datatype(cft_cropland_header)$type) == "integer") {
      if (year == min(cft_output_period)) {
        # Print message about reduced accuracy only once.
        warning(
          "cropland data will be converted to ",
          typeof(get_datatype(cft_cropland_header)$type),
          " size ", get_datatype(cft_cropland_header)$size,
          " with a scalar of ", cft_cropland_header$header["scalar"],
          ", which has lower accuracy.",
          call. = FALSE,
          immediate. = TRUE
        )
      }
      writeBin(
        as.integer(
          round(cft_cropland_yeardata / cft_cropland_header$header["scalar"])
        ),
        cft_cropland_file,
        size = get_datatype(cft_cropland_header)$size,
        endian = cft_cropland_header$endian
      )
    } else {
      invisible(sapply(ha_timeseries_files, nc_close))
      invisible(sapply(hyde_rainfed_files, nc_close))
      invisible(sapply(hyde_irrigated_files, nc_close))
      if (exists("hyde_grazing_files")) {
        invisible(sapply(hyde_grazing_files, nc_close))
      }
      stop(
        "Unsupported data type in cft_cropland_header: ",
        cft_cropland_header$header["datatype"]
      )
    }
  }
  if (cft_separate_fallow) {
    if (typeof(get_datatype(cft_fallow_header)$type) == "double") {
      writeBin(
        as.double(cft_fallow_yeardata / cft_fallow_header$header["scalar"]),
        cft_fallow_file,
        size = get_datatype(cft_fallow_header)$size,
        endian = cft_fallow_header$endian
      )
    } else if (typeof(get_datatype(cft_fallow_header)$type) == "integer") {
      if (year == min(cft_output_period)) {
        # Print message about reduced accuracy only once.
        warning(
          "fallow land data will be converted to ",
          typeof(get_datatype(cft_fallow_header)$type),
          " size ", get_datatype(cft_fallow_header)$size,
          " with a scalar of ", cft_fallow_header$header["scalar"],
          ", which has lower accuracy.",
          call. = FALSE,
          immediate. = TRUE
        )
      }
      writeBin(
        as.integer(
          round(cft_fallow_yeardata / cft_fallow_header$header["scalar"])
        ),
        cft_fallow_file,
        size = get_datatype(cft_fallow_header)$size,
        endian = cft_fallow_header$endian
      )
    } else {
      invisible(sapply(ha_timeseries_files, nc_close))
      invisible(sapply(hyde_rainfed_files, nc_close))
      invisible(sapply(hyde_irrigated_files, nc_close))
      if (exists("hyde_grazing_files")) {
        invisible(sapply(hyde_grazing_files, nc_close))
      }
      stop(
        "Unsupported data type in cft_fallow_header: ",
        cft_fallow_header$header["datatype"]
      )
    }
  }
}
## Processing finished. Close input and output files                          ##
close(cft_output_file)
invisible(sapply(ha_timeseries_files, nc_close))
cat(
  file.size(cft_output_filename), "bytes written to",
  sQuote(cft_output_filename), "\n"
)
# Consistency check if file has expected size
# Expected size
size <- prod(cft_output_header$header[c("ncell", "nbands", "nyear")]) *
  get_datatype(cft_output_header)$size + get_headersize(cft_output_header)
if (file.size(cft_output_filename) != size) {
  warning(
    "File size seems wrong: ",
    file.size(cft_output_filename), " != ", size,
    " expected file size.",
    call. = FALSE,
    immediate. = TRUE
  )
}
if (cft_separate_cropland) {
  close(cft_cropland_file)
  cat(
    file.size(cft_cropland_filename), "bytes written to",
    sQuote(cft_cropland_filename), "\n"
  )
  # Consistency check if file has expected size
  # Expected size
  size <- prod(cft_cropland_header$header[c("ncell", "nbands", "nyear")]) *
    get_datatype(cft_cropland_header)$size + get_headersize(cft_cropland_header)
  if (file.size(cft_cropland_filename) != size) {
    warning(
      "File size seems wrong: ",
      file.size(cft_cropland_filename), " != ", size,
      " expected file size.",
      call. = FALSE,
      immediate. = TRUE
    )
  }
}
if (cft_separate_fallow) {
  close(cft_fallow_file)
  cat(
    file.size(cft_fallow_filename), "bytes written to",
    sQuote(cft_fallow_filename), "\n"
  )
  # Consistency check if file has expected size
  # Expected size
  size <- prod(cft_fallow_header$header[c("ncell", "nbands", "nyear")]) *
    get_datatype(cft_fallow_header)$size + get_headersize(cft_fallow_header)
  if (file.size(cft_fallow_filename) != size) {
    warning(
      "File size seems wrong: ",
      file.size(cft_fallow_filename), " != ", size,
      " expected file size.",
      call. = FALSE,
      immediate. = TRUE
    )
  }
}
invisible(sapply(hyde_rainfed_files, nc_close))
invisible(sapply(hyde_irrigated_files, nc_close))
if (exists("hyde_grazing_files")) {
  invisible(sapply(hyde_grazing_files, nc_close))
}
################################################################################
