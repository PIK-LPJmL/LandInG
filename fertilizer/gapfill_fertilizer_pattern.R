################################################################################
## Copyright (C) 2022 Potsdam Institute for Climate Impact Research (PIK),    ##
## see COPYRIGHT file.                                                        ##
##                                                                            ##
## This file is part of LandInG and licensed under GNU AGPL Version 3 or      ##
## later. See LICENSE file or go to http://www.gnu.org/licenses/              ##
## Contact: https://github.com/PIK-LPJmL/LandInG/                             ##
################################################################################

################################################################################
## This script can be used to fill gaps in the spatial fertilizer patterns    ##
## that may result from cropland patterns used in the creation of the source  ##
## dataset. It will ensure that fertilizer patterns contain non-missing       ##
## values in all cells with land according to the land mask.                  ##
## Gap-filling is carried out either at the national scale if                 ##
## fertilizer_pattern_is_national == TRUE or at the subnational scale using   ##
## level-2 administrative units as smallest units.                            ##
## Script run can be parallelized to speed up processing of crops. The        ##
## parallelization mechanism is implemented through foreach which has         ##
## backends for several parallelization mechanisms. This script has options   ##
## for the doMPI backend (using MPI) and the doParallel backend. Further      ##
## backends are possible. The example below may not work on your system. Try  ##
## to adjust parameters or set "cluster <- FALSE" to switch off               ##
## parallelization and run in sequential mode.                                ##
################################################################################

# Clean up memory
rm(list = ls(all = TRUE))

################################################################################
## Setup of variables valid across all scripts related to fertilizer data     ##
## processing.                                                                ##
## - sets many directories and file names                                     ##
source("fertilizer_setup.R")
## Try parallelization                                                        ##
cluster <- TRUE
## Missing value used in NetCDF files generated by this script.               ##
missval_float <- 1e20
missval_integer <- -5
################################################################################


################################################################################
## Trying to set up cluster using MPI interface or doParallel.                ##
## The implementation using the MPI interface has been developed for a high   ##
## performance cluster. If Rmpi and doMPI are installed and cluster == TRUE   ##
## the script tries to use this combination of packages.                      ##
## If Rmpi is not available but cluster == TRUE the script attempts to use    ##
## parallelization through the "parallel" package and doParallel.             ##
##                                                                            ##
## This part may need to be tweaked for your system set up.                   ##
parallel_mpi <- parallel_local <- FALSE # Not to be set by user
if (cluster) {
  # Try parallelization
  if (require(Rmpi)) {
    # Rmpi = R implementation of MPI interface
    # This is intended for parallelization on high-performance cluster.
    if (require(doMPI)) {
      # doMPI = interface for foreach construct to run in MPI parallel mode
       # Start MPI cluster (link R instances together)
      cl <- doMPI::startMPIcluster()
      # Number of R instances linked together
      num_cluster <- doMPI::clusterSize(cl)
      if (num_cluster > 1) {
        # Script is using more than 1 CPU, so really run in parallel mode
        # Tell foreach to use MPI backend for parallelization
        doMPI::registerDoMPI(cl)
        cat("Running in parallel mode on", num_cluster, "worker nodes.\n")
        parallel_mpi <- TRUE
      } else {
        # Only one task
        # Tell foreach to use sequential mode
        registerDoSEQ()
        cat("Running in sequential mode because only one node is available.\n")
        num_cluster <- 1
      }
    } else {
      # doMPI package is missing
      warning(
        "It seems that you have Rmpi installed. This script requires ",
        "both Rmpi and doMPI package to run in parallel mode.",
        call. = FALSE,
        immediate. = TRUE
      )
      registerDoSEQ() # Tell foreach to use sequential mode
      cat("Falling back to running in sequential mode.\n")
      num_cluster <- 1
    }
  } else if (require(doParallel)) {
    # Try parallelization through parallel package.
    # This is probably more suitable to run in parallel on a local machine
    # Get number of CPU cores
    ncores <- parallel::detectCores()
    # It is probably a good idea not to use all CPUs on your computer.
    # The number of usable CPUs may also be limited by the memory requirement
    # of each task. Test thoroughly in order not to cripple your system.
    if (is.finite(ncores)) {
      num_cluster <- ceiling(ncores / 2)
    } else {
      # parallel::detectCores() could not detect number of CPUs. Fall back to 1.
      num_cluster <- 1
    }
    if (num_cluster > 1) {
      # Start cluster on local machine
      cl <- parallel::makeCluster(num_cluster)
      # Tell foreach to use this cluster
      registerDoParallel(num_cluster)
      parallel_local <- TRUE
      cat("Running in parallel mode on", num_cluster, "CPUs\n")
    } else {
      # Only one task
      registerDoSEQ() # Tell foreach to use sequential mode
      cat("Running in sequential mode because only one CPU is available.\n")
    }
  } else {
    # Rmpi and doParallel package are missing
    warning(
      "This script requires Rmpi and doMPI or",
      " parallel and doParallel to run in parallel mode.\n",
      "Please install missing packages or set cluster to FALSE.",
      call. = FALSE,
      immediate. = TRUE
    )
    registerDoSEQ() # Tells foreach to use sequential mode
    cat("Falling back to running in sequential mode.\n")
    num_cluster <- 1
  }
} else {
  # Do not try parallelization
  library(foreach)
  registerDoSEQ() # Tells foreach to use sequential mode
  cat("Running in sequential mode.\n")
  num_cluster <- 1
}
################################################################################


################################################################################
## Load spatial units                                                         ##
if (fertilizer_pattern_admin == "gadm") {
  cat("Admin units loaded from", sQuote(gadmlevel_file), "\n")
  pattern_admin_raster <- brick(gadmlevel_file)
  pattern_admin_names <- read.csv(
    gadmlevel_names_file,
    stringsAsFactors = FALSE,
    comment.char = "#"
  )
  # Check spatial extent of GADM units
  if (matching_extent(
    extent(pattern_admin_raster),
    global_extent,
    xres(pattern_admin_raster),
    yres(pattern_admin_raster)
  )) {
    pattern_admin_raster <- setExtent(pattern_admin_raster, global_extent)
  }
  # Number of countries in each cell used to determine border cells
  pattern_border_raster <- brick(gadmborder_file)
  # Check spatial extent of border raster
  if (matching_extent(
    extent(pattern_border_raster),
    global_extent,
    xres(pattern_border_raster),
    yres(pattern_border_raster)
  )) {
    pattern_border_raster <- setExtent(pattern_border_raster, global_extent)
  }
  # Column name in country grouping that contains matching codes
  country_grouping_col <- gadm_country_col
  # Find column containing 3-letter ISO code in pattern_admin_names
  iso_col <- grep(
    "level0.code",
    colnames(pattern_admin_names),
    ignore.case = TRUE,
  )
  if (length(iso_col) != 1) {
    stop("Error finding country ISO code column in pattern_admin_names")
  }
  # Find column containing country IDs
  code_col <- grep(
    "level0.id",
    colnames(pattern_admin_names),
    ignore.case = TRUE,
  )
  if (length(code_col) != 1) {
    stop("Error finding country ID column in pattern_admin_names")
  }
} else if (fertilizer_pattern_admin == "luh2") {
  cat("Admin units loaded from", sQuote(luh2country_file), "\n")
  pattern_admin_raster <- brick(
    luh2country_file,
    varname = luh2country_variable,
    band = luh2country_layer
  )
  pattern_admin_names <- NULL
  pattern_border_raster <- NULL
  country_grouping_col <- luh2_country_col
  # No names, therefore no columns with IDs and ISO codes
  iso_col <- NULL
  code_col <- NULL
} else {
  stop(
    paste(
      "Undefined fertilizer_pattern_admin", sQuote(fertilizer_pattern_admin),
      "\nCheck fertilizer_setup.R"
    )
  )
}
if (nlayers(pattern_admin_raster) == 1) {
  # Reduce brick to raster layer in case of only one layer because single-layer
  # bricks cause problems in raster package code.
  pattern_admin_raster <- subset(pattern_admin_raster, 1)
}
if (!is.null(pattern_border_raster) && nlayers(pattern_border_raster) == 1) {
  # Reduce brick to raster layer in case of only one layer because single-layer
  # bricks cause problems in raster package code.
  pattern_border_raster <- subset(pattern_border_raster, 1)
}
if (!anyNA(values(pattern_admin_raster)) && fertilizer_pattern_strip_zero) {
  message(
    "Info: Admin data does not contain any NAs and ",
    "fertilizer_pattern_strip_zero is TRUE. Replacing 0 with NA in admin data"
  )
  pattern_admin_raster <- mask(
    pattern_admin_raster,
    pattern_admin_raster,
    maskvalue = 0
  )
}
################################################################################


################################################################################
## Load country grouping and crop list                                        ##
if (file.exists(country_group_file)) {
  cat("Country groups loaded from", sQuote(country_group_file), "\n")
  country_group_data <- read.csv(country_group_file, stringsAsFactors = FALSE)
} else {
  stop(
    paste(
      "Country groups file", country_group_file, "does not exist.",
      "\nPlease check fertilizer_setup.R"
    )
  )
}

if (file.exists(mapping_file)) {
  cat("Crop type mapping loaded from", sQuote(mapping_file), "\n")
  crop_type_mapping <- read.csv(mapping_file, stringsAsFactors = FALSE)
} else {
  stop(
    paste(
      "Mapping file", mapping_file, "does not exist.",
      "\nPlease check fertilizer_setup.R"
    )
  )
}

# Convert any special characters to ASCII
for (table in c("country_group_data", "crop_mapping")) {
  if (exists(table)) {
    table_data <- get(table)
    for (col in colnames(table_data)) {
      if (typeof(table_data[, col]) == "character") {
        if (!all(stri_enc_isascii(table_data[, col]), na.rm = TRUE)) {
          # String has non-ASCII characters
          if (!all(stri_enc_isutf8(table_data[, col]), na.rm = TRUE)) {
            # String has non-UTF8 characters -> assume windows-1252 encoding and
            # convert to UTF-8
            message(
              "Converting column ", sQuote(col),
              " from windows-1252 to UTF-8 encoding in ",
              table
            )
            table_data[, col] <- stri_encode(
              table_data[, col],
              "windows-1252",
              "UTF-8"
            )
          }
          # Convert UTF-8 strings to ASCII strings, if necessary translating
          # special characters
          message(
            "Converting column ", sQuote(col),
            " from UTF-8 to ASCII encoding in ",
            table
          )
          table_data[, col] <- stri_encode(table_data[, col], "UTF-8", "UTF-8")
          table_data[, col] <- stri_trans_general(
            table_data[, col],
            "latin-ascii"
          )
        }
      }
    }
    assign(table, table_data)
    rm(table_data)
  }
}
# Check that country_group_data has columns matching codes used in fertilizer
# patterns.
if (!country_grouping_col %in% colnames(country_group_data)) {
  # Try to match name using grep
  if (length(
    grep(country_grouping_col, colnames(country_group_data), ignore.case = TRUE)
  ) == 1
  ) {
    message(
      "Replace country_grouping_col ", sQuote(country_grouping_col), " with ",
      sQuote(
        grep(
          country_grouping_col,
          colnames(country_group_data),
          ignore.case = TRUE,
          value = TRUE
        )
      )
    )
    country_grouping_col <- grep(
      country_grouping_col,
      colnames(country_group_data),
      ignore.case = TRUE,
      value = TRUE
    )
  } else {
    stop(
      paste(
        "Column country_grouping_col", sQuote(country_grouping_col),
        "missing in country_group_data"
      )
    )
  }
}

# Check consistency between admin unit masks and country grouping
if (fertilizer_pattern_admin == "gadm") {
  # Check for countries used in GADM but missing in UNSD country_group_data.
  # Variable add_list_gadm defined in helper/fix_admin_masks.R
  if (exists("add_list_gadm"))
    country_group_data <- add_to_country_list(country_group_data, add_list_gadm)

  # Try to fix country codes used in GADM country mask that are not in UNSD
  # country group listing.
  # ccode_replacement_gadm defined in helper/fix_admin_masks.R
  # This only works if GADM names have been provided. Note: subnational units
  # remain unchanged.
  if (!is.null(pattern_admin_names) &&
    exists("ccode_replacement_gadm")
  ) {
    if (nlayers(pattern_admin_raster) == 1) {
      ccodes <- na.omit(unique(values(pattern_admin_raster)))
    } else {
      national_band <- find_national_band(pattern_admin_raster)
      ccodes <- na.omit(
        unique(values(subset(pattern_admin_raster, national_band)))
      )
    }
    iso_r <- match(ccodes, pattern_admin_names[, code_col])
    iso_codes <- pattern_admin_names[iso_r, iso_col]
    # Name column in country_group_data
    name_col <- grep(
      "country", colnames(pattern_admin_names), ignore.case = TRUE
    )
    for (r in seq_len(nrow(ccode_replacement_gadm))) {
      if (!ccode_replacement_gadm[r, "source"] %in%
        country_group_data[, country_grouping_col] &&
        ccode_replacement_gadm[r, "replacement"] %in%
        country_group_data[, country_grouping_col] &&
        ccode_replacement_gadm[r, "replacement"] %in% iso_codes &&
        ccode_replacement_gadm[r, "source"] %in% iso_codes
      ) {
        r_source <- match(
          ccode_replacement_luh2[r, "source"],
          pattern_admin_names[, iso_col]
        )
        r_replacement <- match(
          ccode_replacement_luh2[r, "replacement"],
          pattern_admin_names[, iso_col]
        )
        cat(
          "Replace country code", sQuote(ccode_replacement_luh2[r, "source"]),
          "with code", sQuote(ccode_replacement_luh2[r, "replacement"]),
          "for", sQuote(pattern_admin_names[r_replacement, name_col]), "\n"
        )
        if (nlayers(pattern_admin_raster) == 1) {
          pattern_admin_raster <- mask(
            pattern_admin_raster,
            pattern_admin_raster,
            maskvalue = pattern_admin_names[r_source, code_col],
            updatevalue = pattern_admin_names[r_replacement, code_col]
          )
        } else {
          # Extract band with national values
          national_raster <- subset(pattern_admin_raster, national_band)
          # Only replace values in national band
          national_raster <- mask(
            national_raster,
            national_raster,
            maskvalue = pattern_admin_names[r_source, code_col],
            updatevalue = pattern_admin_names[r_replacement, code_col]
          )
          # Update values for national_band in pattern_admin_raster
          pattern_admin_raster <- setValues(
            pattern_admin_raster,
            values(national_raster),
            layer = national_band
          )
          rm(national_raster)
        }
      }
    }
  } else if (exists("ccode_replacement_gadm")) {
    warning(
      "Cannot apply user-defined ccode_replacement_gadm because ",
      "pattern_admin_names is missing.",
      call. = FALSE,
      immediate. = TRUE
    )
  }
  # Update all country codes in admin unit mask and check if they are available
  # in country_group_data.
  if (nlayers(pattern_admin_raster) == 1) {
    ccodes <- na.omit(unique(values(pattern_admin_raster)))
  } else {
    national_band <- find_national_band(pattern_admin_raster)
    ccodes <- na.omit(
      unique(values(subset(pattern_admin_raster, national_band)))
    )
  }
  if (!is.null(pattern_admin_names)) {
    # Replace IDs with ISO codes
    iso_r <- match(ccodes, pattern_admin_names[, code_col])
    iso_codes <- pattern_admin_names[iso_r, iso_col]
    pattern_admin_mismatch <- setdiff(
      iso_codes,
      country_group_data[, country_grouping_col]
    )
    name_r <- match(pattern_admin_mismatch, pattern_admin_names[, iso_col])
    if (!all(iso_codes %in% country_group_data[, country_grouping_col])) {
      message(
        "Info: countries ",
        paste(
          pattern_admin_mismatch,
          " (", pattern_admin_names[name_r, name_col], ")",
          sep = "",
          collapse = ", "
        ),
        " in pattern_admin_raster not available in country_group_data."
      )
    }
    rm(name_r, iso_r, iso_codes, pattern_admin_mismatch)
  } else if(!all(ccodes %in% country_group_data[, country_grouping_col])) {
    message(
      "Info: country code(s) ",
      toString(setdiff(ccodes, country_group_data[, country_grouping_col])),
      " in pattern_admin_raster not available in country_group_data."
    )
  }
}
if (fertilizer_pattern_admin == "luh2") {
  # Check for countries used in LUH2 but missing in UNSD country_group_data.
  # Variable add_list_luh2 defined in helper/fix_admin_masks.R
  if (exists("add_list_luh2")) {
    country_group_data <- add_to_country_list(country_group_data, add_list_luh2)
  }

  # Try to fix country codes used in LUH2 country mask that are not in UNSD
  # country group listing.
  # ccode_replacement_luh2 defined in helper/fix_admin_masks.R
  if (exists("ccode_replacement_luh2") && nlayers(pattern_admin_raster) == 1) {
    # All country codes in admin unit mask
    ccodes <- na.omit(unique(values(pattern_admin_raster)))
    # Name column in country_group_data
    name_col <- grep(
      "country", colnames(country_group_data), ignore.case = TRUE
    )
    for (r in seq_len(nrow(ccode_replacement_luh2))) {
      if (!ccode_replacement_luh2[r, "source"] %in%
        country_group_data[, country_grouping_col] &&
        ccode_replacement_luh2[r, "replacement"] %in%
        country_group_data[, country_grouping_col]
      ) {
        r_group <- match(
          ccode_replacement_luh2[r, "replacement"],
          country_group_data[, country_grouping_col]
        )
        cat(
          "Replace country code", sQuote(ccode_replacement_luh2[r, "source"]),
          "with code", sQuote(ccode_replacement_luh2[r, "replacement"]),
          "for", sQuote(country_group_data[r_group, name_col]), "\n"
        )
        pattern_admin_raster <- mask(
          pattern_admin_raster,
          pattern_admin_raster,
          maskvalue = ccode_replacement_luh2[r, "source"],
          updatevalue = ccode_replacement_luh2[r, "replacement"]
        )
      }
    }
  } else if (exists("ccode_replacement_luh2")) {
    warning(
      "Cannot apply user-defined ccode_replacement_luh2 because ",
      "pattern_admin_raster has more than one band.",
      call. = FALSE,
      immediate. = TRUE
    )
  }
  # Update all country codes in admin unit mask and check if they are available
  # in country_group_data.
  ccodes <- na.omit(unique(values(pattern_admin_raster)))
  if (!all(ccodes %in% country_group_data[, country_grouping_col])) {
    warning(
      "country code(s) ",
      toString(
        sQuote(setdiff(ccodes, country_group_data[, country_grouping_col]))
      ),
      " in pattern_admin_raster not available in country_group_data.\n",
      "Consider adding them via an extry in 'add_list_luh2' or replacing",
      " them via an entry in 'ccode_replacement_luh2'",
      call. = FALSE,
      immediate. = TRUE
    )
  }
}
################################################################################


################################################################################
## Gap-fill fertilizer patterns for each crop                                 ##
crops <- na.omit(crop_type_mapping[, fertilizer_pattern_map_col])
crops <- unique(crops[which(nchar(crops) > 0)])
if (length(fertilizer_pattern_refyear) > 1) {
  warning(
    "downstream scripts currently only support ",
    "fertilizer_pattern_refyear of length 1. You provided: ",
    toString(fertilizer_pattern_refyear),
    call. = FALSE,
    immediate. = TRUE
  )
}
for (nut in fertilizer_pattern_nutrients) {
  cat("Nutrient:", nut, "\n")
  if (!fertilizer_pattern_admin_resmatch) {
    # Admin unit dataset has different resolution. Try to match.
    # Derive filenames per crop, expected filename pattern:
    # [CROP][NUTRIENT]apprate.nc
    filenames <- file.path(
      fertilizer_pattern_dir,
      paste0(crops, nut, "apprate.nc")
    )
    # If any crop file exists compare resolution to admin unit dataset.
    # Note: this assumes that all crops have the same resolution. Switch off if
    # different crops have different resolution.
    if (any(file.exists(filenames))) {
      filedata <- brick(filenames[which(file.exists(filenames))[1]])
      # Keep a copy of original data to restore
      pattern_admin_raster_backup <- pattern_admin_raster
      pattern_admin_raster <- match_admin_to_data(
        filedata,
        pattern_admin_raster,
        fun = modal_ties_lowest,
        verbose = TRUE
      )
      if (!is.null(pattern_border_raster)) {
        # Keep a copy of original data to restore
        pattern_border_raster_backup <- pattern_border_raster
        pattern_border_raster <- match_admin_to_data(
          filedata,
          pattern_border_raster,
          fun = max,
          verbose = FALSE
        )
      }
    }
    # Note: resolution is also checked in gapfill_pattern() and adjusted if
    # necessary. Aggregating here avoids having to redo it for every crop.
    # Switch off this part of the code if different crops have different
    # resolutions.
  }
  crop_loop <- foreach(
    crop = crops,
    .inorder = FALSE,
    .combine = c
  ) %dopar% {
    # Log gap-filling into temporary file
    logfile <- tempfile(
      paste0(crop, nut, "_"),
      tmpdir = getwd(),
      fileext = ".txt"
    )
    fp <- file(logfile, "wt")
    sink(fp, type = "output")
    sink(fp, type = "message")
    # Expected filename pattern: [CROP][NUTRIENT]apprate.nc
    filename <- file.path(
      fertilizer_pattern_dir,
      paste0(crop, nut, "apprate.nc")
    )
    if (file.exists(filename)) {
      # Check file unit
      file_nc <- nc_open(filename)
      file_unit <- ncatt_get(file_nc,  paste0(crop, nut, "apprate"), "units")
      if (file_unit$hasatt &&
        !grepl(fertilizer_pattern_unit, file_unit$value, ignore.case = TRUE)
      ) {
        warning(
          "fertilizer_pattern_unit ",
          sQuote(fertilizer_pattern_unit),
          " defined in fertilizer_setup.R cannot be detected in unit ",
          "defined in NetCDF file", sQuote(file_unit$value),
          ".\nPlease make sure to set correct unit in fertilizer_setup.R",
          call. = FALSE,
          immediate. = TRUE
        )
      }
      nc_close(file_nc)
      cat("Gap-filling", filename, "\n")
      # Load data as RasterBrick
      filedata <- brick(filename)
      filedata_filled <- gapfill_pattern(
        filedata = filedata,
        strip_zero = fertilizer_pattern_strip_zero,
        unit_raster = pattern_admin_raster,
        unit_raster_names = pattern_admin_names,
        unit_border_raster = pattern_border_raster,
        # GADM does not match admin units used in source data, so filter cells
        # that may be assigned to wrong country.
        assign_grid_threshold = fertilizer_pattern_assign_grid_threshold,
        fill_regional_data = TRUE,
        # This is the minimum number of countries required in a country group to
        # use that group's value.
        assign_country_threshold = fertilizer_pattern_assign_country_threshold,
        country_grouping = country_group_data,
        country_grouping_col = country_grouping_col,
        is_national = fertilizer_pattern_is_national,
        fert_band = fertilizer_pattern_fert_band,
        source_band = fertilizer_pattern_source_band,
        source_country_vals = c(3, 3.25, 5, 5.25, 5.5, 5.75, 6, 6.25, 6.5, 6.75),
        verbose = TRUE
      )
      if (nlayers(filedata_filled) !=
        length(fertilizer_pattern_refyear) * 3 + 1
      ) {
        # Cannot use stop() in foreach loop
        message(
          "Invalid number of bands returned by gapfill_pattern for nutrient ",
          nut, " and crop ", crop
        )
        # Stop logging to temporary file.
        sink(type = "output")
        sink(type = "message")
        close(fp)
        return(NULL)
      } else {
        # Determine filename of gap-filled data. Resolution may not be the same
        # as unit_raster although we advise to always use unit_raster at same
        # resolution as fertilizer patterns.
        tmp_res <- ifelse(res(filedata_filled) < 1 / 60, 3600, 60) *
          res(filedata_filled)
        tmp_string <- paste(
          unique(round(tmp_res)),
          unique(ifelse(res(filedata_filled) < 1 / 60, "sec", "min")),
          sep = "",
          collapse = "_by_"
        )
        filled_working_dir <- file.path("tmp", paste0("work_", tmp_string))
        if (!dir.exists(filled_working_dir)) {
          dir.create(filled_working_dir, recursive = TRUE)
        }
        filename_filled <- file.path(
          filled_working_dir,
          paste0(
            crop, nut, "apprate_",
            fertilizer_pattern_admin,
            ifelse(
              fertilizer_pattern_is_national,
              "_national",
              "_subnational"
            ),
            ".nc"
          )
        )
        # Set up NetCDF variables
        lon_dim <- ncdim_def(
          name = "longitude",
          units = "degrees_east",
          vals = xFromCol(filedata_filled),
          longname = "longitude"
        )
        lat_dim <- ncdim_def(
          name = "latitude",
          units = "degrees_north",
          vals = yFromRow(filedata_filled),
          longname = "latitude"
        )
        time_dim <- ncdim_def(
          name = "time",
          units = "year",
          vals = fertilizer_pattern_refyear,
        )
        fert_var <- ncvar_def(
          name = paste0(crop, nut, "apprate"),
          units = fertilizer_pattern_unit,
          dim = list(lon_dim, lat_dim, time_dim),
          missval = missval_float,
          longname = paste(nut, "fertilizer application rate for", crop),
          compression = 5
        )
        gapfill_stats_var <- ncvar_def(
          name = "gapfill_level",
          units = "",
          dim = list(lon_dim, lat_dim, time_dim),
          missval = missval_float,
          longname = "Level at which gap-filling was performed",
          compression = 5
        )
        gapfill_source_var <- ncvar_def(
          name = "gapfill_sources",
          units = "",
          dim = list(lon_dim, lat_dim, time_dim),
          missval = missval_integer,
          longname = "Number of cells/countries used for gap-filling",
          prec = "integer",
          compression = 5
        )
        # Create output file
        nc <- nc_create(
          filename_filled,
          list(fert_var, gapfill_stats_var, gapfill_source_var)
        )
        ncatt_put(
          nc, paste0(crop, nut, "apprate"), "missing_value", missval_float
        )
        ncatt_put(nc, "gapfill_level", "missing_value", missval_float)
        ncatt_put(nc, "gapfill_sources", "missing_value", missval_integer)
        nc_sync(nc)
        band <- seq_along(fertilizer_pattern_refyear)
        writedata <- as.double(values(subset(filedata_filled, band)))
        writedata[which(is.na(writedata))] <- missval_float
        ncvar_put(
          nc,
          paste0(crop, nut, "apprate"),
          writedata,
        )
        rm(writedata)
        band <- band + length(fertilizer_pattern_refyear)
        writedata <- as.double(values(subset(filedata_filled, band)))
        writedata[which(is.na(writedata))] <- missval_float
        ncvar_put(
          nc,
          "gapfill_level",
          writedata,
        )
        rm(writedata)
        band <- band + length(fertilizer_pattern_refyear)
        writedata <- as.integer(round(values(subset(filedata_filled, band))))
        writedata[which(is.na(writedata))] <- missval_integer
        ncvar_put(
          nc,
          "gapfill_sources",
          writedata,
        )
        rm(writedata)
        nc_close(nc)
        # Stop logging to temporary file.
        sink(type = "output")
        sink(type = "message")
        close(fp)
        # Move gap-fill log file to location of NetCDF file.
        logfile_final <- file.path(
          filled_working_dir,
          paste0(
            crop, nut, "apprate_",
            fertilizer_pattern_admin,
            ifelse(
              fertilizer_pattern_is_national,
              "_national",
              "_subnational"
            ),
            ".log"
          )
        )
        file.rename(logfile, logfile_final)
      }
    } else {
      warning(
        "*** Fertilizer pattern file ", filename, " not found. ***",
        call. = FALSE,
        immediate. = TRUE
      )
      # Stop logging to temporary file.
      sink(type = "output")
      sink(type = "message")
      close(fp)
      return(NULL)
    }
    # Return name
    crop
  }
  if (length(crop_loop) != length(crops)) {
    warning(
      "The following crops were not gap-filled correctly for ",
      "nutrient ", sQuote(nut), ": ",
      toString(sQuote(setdiff(crops, crop_loop))),
      call. = FALSE,
      immediate. = TRUE
    )
  } else {
    cat(length(crops), "crops gap-filled for nutrient", sQuote(nut), "\n")
  }
  if (exists("pattern_admin_raster_backup")) {
    # Restore original data just in case different nutrients have different
    # resolutions.
    pattern_admin_raster <- pattern_admin_raster_backup
    rm(pattern_admin_raster_backup)
  }
  if (exists("pattern_border_raster_backup")) {
    # Restore original data just in case different nutrients have different
    # resolutions.
    pattern_border_raster <- pattern_border_raster_backup
    rm(pattern_border_raster_backup)
  }
}
################################################################################


################################################################################
## If running in parallel mode do some clean-up.                              ##
if (parallel_mpi) {
  # Release linked R instances and close MPI cluster.
  doMPI::closeCluster(cl)
  Rmpi::mpi.quit()
}
if (parallel_local) {
  # Release parallel cluster
  parallel::stopCluster(cl)
}
################################################################################
