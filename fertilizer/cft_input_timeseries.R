################################################################################
## Copyright (C) 2022 Potsdam Institute for Climate Impact Research (PIK),    ##
## see COPYRIGHT file.                                                        ##
##                                                                            ##
## This file is part of LandInG and licensed under GNU AGPL Version 3 or      ##
## later. See LICENSE file or go to http://www.gnu.org/licenses/              ##
## Contact: https://github.com/PIK-LPJmL/LandInG/                             ##
################################################################################

################################################################################
## This script converts crop-specific fertilizer time series and manure time  ##
## series into a fertilizer input suitable for LPJmL.                         ##
## Output crops can either be time series of individual source crops or of    ##
## several source crops aggregated to an output crop group.                   ##
## The toolbox does not explicitly support using different fertilizer         ##
## application rates for rainfed and irrigated crops given that the default   ##
## data soures for fertilizer patterns and trends do not distinguish between  ##
## rainfed and irrigated crops.                                               ##
## The toolbox does not support crop-specific manure application rates. If    ##
## manure source data are aggregated spatially to the output resolution,      ##
## manure application rates may differ between rainfed and irrigated cropland ##
## if separate weighting datasets are defined below.                          ##
## Users may decide add manure application rates to crop-specific fertilizer  ##
## rates or generate a separate input for manure application rates.           ##
## Users may provide a grid file at a coarser resolution than the one used in ##
## the rest of fertilizer processing. In this case, fertilizer information is ##
## aggregated to the resolution of the grid file.                             ##
################################################################################

# Clean up memory
rm(list = ls(all = TRUE))

################################################################################
## Setup of variables valid across all scripts related to fertilizer data     ##
## processing.                                                                ##
## - sets many directories and file names                                     ##
source("fertilizer_setup.R")
## Missing value used in NetCDF files generated by this script.               ##
missval_float <- 1e20
missval_integer <- -5
################################################################################


################################################################################
## Set up for created input file(s)                                           ##
## Nutrient for which input file is requested. Run this script several times  ##
## to request files for multiple nutrients.                                   ##
cft_nut <- "N"
## Period for input file created (default: same as output_period)             ##
cft_output_period <- c(startyear, endyear)
## Unit used in generated file. By default, LPJmL uses "g/m2"                 ##
cft_output_unit <- "g/m2"
## Optional version string added to file names of created files to            ##
## distinguish between multiple generated datasets                            ##
version_string <- ""
## Optional name of crop aggregation added to file names of created files to  ##
## distinguish between multiple generated datasets                            ##
aggregation_name <- "default"
## Output format. Either "NetCDF" or "CLM" (LPJmL native input format)
cft_format <- "CLM"
## Grid file in LPJmL input format to use (such as a grid file generated by   ##
## the scripts in ../gadm)
## Note: This grid file can have a coarser spatial resolution than the        ##
## harvested area timeseries created by the other scripts in this directory.  ##
cft_gridname <- "path/to/grid_file.bin"
## Whether to process fertilizer data into input file. Default: TRUE.         ##
process_fertilizer <- TRUE
## Whether to process manure data into input file. Default: TRUE.             ##
process_manure <- TRUE
## See also settings 'combine_fertilizer_manure' and                          ##
## 'manure_availability_scalar' in fertilizer_setup.R                         ##
## Whether to account for manure not allocated (TRUE/FALSE). Manure from the  ##
## source dataset can either be lost when scaling to cropland or when applying##
## an optional manure_threshold set in fertilizer_setup.R. If set to TRUE     ##
## absolute amount of manure not allocated is saved to file.                  ##
manure_noalloc_account <- TRUE
## Optional maximum application rate for fertilizer. Provide value in unit    ##
## cft_output_unit. Set to Inf in order to impose no maximum rate.            ##
fert_threshold <- 50
## Whether to account for fertilizer cut off by optional threshold            ##
## (TRUE/FALSE). If set to TRUE, rate not allocated per CFT is saved to file. ##
## If fertilizer and manure are combined into one variable                    ##
## (combine_fertilizer_manure == TRUE), threshold is applied to fertilizer    ##
## rate before combining with manure.                                         ##
fert_noalloc_account <- TRUE
################################################################################


################################################################################
## Set up for datasets used for weighted crop and spatial aggregation.        ##
##                                                                            ##
## Harvested area dataset used to aggregate crop-specific fertilizer rates to ##
## CFT-specific rates. By default, use dataset created by scripts in landuse  ##
## directory of this toolbox. Supply file name pattern that matches harvested ##
## area time series files to use. Default setting matches default used in     ##
## landuse processing. If you have used version strings in landuse processing ##
## add them to pattern to make sure that files are detected correctly.        ##
## Note mapping between harvested area crop names and fertilizer crop names   ##
## must be set up in 'mapping_file' defined in fertilizer_setup.R.            ##
ha_weighting_name_pattern <- file.path(
  "..", "landuse", "tmp", "[enter_spatial_resolution]",
  "harvested_area_GADM_timeseries_\\d{4}-\\d{4}_[_[:alnum:]]*.nc"
)
## Variable name in NetCDF containing harvested areas                         ##
ha_weighting_varname <- c(
  rainfed = "rainfed_harvested_area",
  irrigated = "irrigated_harvested_area"
)
## Variable name in NetCDF containing crop names. If NetCDF does not contain  ##
## names set to NULL and provide crop names directly below.                   ##
ha_weighting_crop_varname <- "crop"
## Crop names in harvested area file. Provide directly if not available in    ##
## NetCDF file. Set to NULL in order to read from NetCDF.                     ##
ha_weighting_crop_names <- NULL
##                                                                            ##
## Dataset to use for spatial aggregation of manure. You may either define    ##
## separate datasets for manure on rainfed and irrigated cropland (suggested  ##
## option) or use manure_cropland_name defined in fertilizer_setup.R.         ##
manure_weighting_name <- c(
  rainfed = file.path(
    "..", "landuse", "HYDE", "path", "to",
    "hyde_tot_rainfed_annual_startyear_endyear.nc4"
  ),
  irrigated = file.path(
    "..", "landuse", "HYDE", "path", "to",
    "hyde_tot_irri_annual_startyear_endyear.nc4"
  )
)
## Unit of weighting dataset
manure_weighting_unit <- "km2"
## Variable name in NetCDF containing cropland                                ##
manure_weighting_varname <- c(rainfed = "tot_rainfed", irrigated = "tot_irri")
## Optional file providing grid area for weighting dataset. Set to NULL if not##
## used. Required if manure_weighting_unit is fractional instead of an area.  ##
manure_weighting_area_file <- file.path(
  "..", "landuse", "HYDE", "general_files",
  "garea_cr.asc"
)
## Area unit in pasture_weighting_area_file.                                  ##
manure_weighting_area_file_unit <- "km2"
##                                                                            ##
## Optional weighting file to use for spatial aggregation on pastures. HYDE   ##
## grazing land proposed as default. Set to NULL in order not to use weighted ##
## aggregation. Note: HYDE does not provide irrigated pastures.               ##
pasture_weighting_name <- file.path(
  "..", "landuse", "HYDE", "path", "to",
  "hyde_grazing_annual_startyear_endyear.nc4"
)
## Unit of weighting dataset                                                  ##
pasture_weighting_unit <- "km2"
## Variable name used in pasture_weighting_name                               ##
pasture_weighting_varname <- c(rainfed = "grazing", irrigated = NULL)
## Optional file providing grid area for weighting dataset. Set to NULL if not##
## used. Required if pasture_weighting_unit is fractional instead of an area. ##
pasture_weighting_area_file <- file.path(
  "..", "landuse", "HYDE", "general_files",
  "garea_cr.asc"
)
## Area unit in pasture_weighting_area_file.                                  ##
pasture_weighting_area_file_unit <- "km2"
################################################################################


################################################################################
## Setup of bands in fertilizer input file                                    ##
## This needs to conform to CFTs, others, managed grasslands and bioenergy    ##
## plantation types defined in LPJmL.                                         ##
## Order must be identical to the one expected by LPJmL.                      ##
## LPJmL expects the same number of rainfed and irrigated bands.              ##
## Use the same capitalization of "rainfed" and "irrigated" as in named       ##
## variable attributes above.                                                 ##
cft_bands <- c(
  "rainfed temperate cereals",
  "rainfed rice",
  "rainfed maize",
  "rainfed tropical cereals",
  "rainfed pulses",
  "rainfed temperate roots",
  "rainfed tropical roots",
  "rainfed oil crops sunflower",
  "rainfed oil crops soybean",
  "rainfed oil crops groundnut",
  "rainfed oil crops rapeseed",
  "rainfed sugar cane",
  "rainfed other crops",
  "rainfed pasture/managed grass",
  "rainfed bio-energy grass",
  "rainfed bio-energy tree",
  # fallow land currently not implemented in LPJmL
  # "rainfed fallow",
  "irrigated temperate cereals",
  "irrigated rice",
  "irrigated maize",
  "irrigated tropical cereals",
  "irrigated pulses",
  "irrigated temperate roots",
  "irrigated tropical roots",
  "irrigated oil crops sunflower",
  "irrigated oil crops soybean",
  "irrigated oil crops groundnut",
  "irrigated oil crops rapeseed",
  "irrigated sugar cane",
  "irrigated other crops",
  "irrigated pasture/managed grass",
  "irrigated bio-energy grass",
  "irrigated bio-energy tree"
  # fallow land currently not implemented in LPJmL
  # "irrigated fallow"
)
## cft_bands that receive manure.                                             ##
## The default manure source dataset provides manure application rates on     ##
## cropland. These are not crop-specific. Therefore, apply manure rate to all ##
## CFTs on cropland (and optionally on fallow land).                          ##
## Make sure that the following regular expression matches all crops, but not ##
## pasture, bio-energy, or similar variables you may have added.              ##
crop_bands <- grep("bio-energy|pasture", cft_bands, invert = TRUE)
cft_bands_get_manure <- logical(length(cft_bands))
names(cft_bands_get_manure) <- cft_bands
cft_bands_get_manure[crop_bands] <- TRUE
## By default, use HYDE grazing land for spatial aggregation on pastures.     ##
## Make sure the following regular expression matches all CFT bands that use  ##
## pasture_weighting_name for weighting.                                      ##
pasture_weighting_bands <- grep("pasture", cft_bands)
## By default, use harvested area weighting for crop bands (but not for       ##
## pastures and fallow land).                                                 ##
ha_weighting_bands <- setdiff(crop_bands, grep("fallow", cft_bands))
################################################################################


################################################################################
## Load grid file and determine requested output resolution and spatial extent##
cft_gridheader <- read_header(cft_gridname)
cft_gridfile <- file(cft_gridname, "rb")
seek(cft_gridfile, get_headersize(cft_gridheader))
cft_griddata <- matrix(
  readBin(
    cft_gridfile,
    what = get_datatype(cft_gridheader)$type,
    size = get_datatype(cft_gridheader)$size,
    n = cft_gridheader$header["nbands"] * cft_gridheader$header["ncell"],
    endian = cft_gridheader$endian
  ) * cft_gridheader$header["scalar"],
  ncol = cft_gridheader$header["nbands"],
  byrow = cft_gridheader$header["order"] != 4
)
close(cft_gridfile)
# Create raster object corresponding to grid data
cft_extent <- extent(
  min(cft_griddata[, 1] - cft_gridheader$header["cellsize_lon"] / 2),
  max(cft_griddata[, 1] + cft_gridheader$header["cellsize_lon"] / 2),
  min(cft_griddata[, 2] - cft_gridheader$header["cellsize_lat"] / 2),
  max(cft_griddata[, 2] + cft_gridheader$header["cellsize_lat"] / 2)
)
cft_raster <- raster(
  cft_extent,
  resolution = cft_gridheader$header[c("cellsize_lon", "cellsize_lat")]
)
# Determine indices of grid cells in raster for later data extraction
cft_raster_gridindex <- cellFromXY(cft_raster, cft_griddata)
cat(
  paste0(
    "LPJmL grid file: ", cft_gridname,
    " (ncell=", cft_gridheader$header["ncell"],
    ", cellsize_lon=", round(cft_gridheader$header["cellsize_lon"], 8),
    ", cellsize_lat=", round(cft_gridheader$header["cellsize_lat"], 8),
    ")\n"
  )
)
# Determine resolution string for output file
tmp_res <- ifelse(res(cft_raster) < 1 / 60, 3600, 60) * res(cft_raster)
cft_res_string <- paste(
  unique(round(tmp_res)),
  unique(ifelse(res(cft_raster) < 1 / 60, "sec", "min")),
  sep = "",
  collapse = "_by_"
)
rm(tmp_res)
################################################################################


################################################################################
## Determine if source datasets are compatible with output resolution.        ##
# Load crop list
if (file.exists(mapping_file)) {
  cat("Crop type mapping loaded from", sQuote(mapping_file), "\n")
  crop_type_mapping <- read.csv(mapping_file, stringsAsFactors = FALSE)
} else {
  stop(
    paste(
      "Mapping file", mapping_file, "does not exist.",
      "\nPlease check fertilizer_setup.R"
    )
  )
}
# Convert any special characters to ASCII
for (table in c("crop_type_mapping")) {
  if (exists(table)) {
    table_data <- get(table)
    for (col in colnames(table_data)) {
      if (typeof(table_data[, col]) == "character") {
        if (!all(stri_enc_isascii(table_data[, col]), na.rm = TRUE)) {
          # String has non-ASCII characters
          if (!all(stri_enc_isutf8(table_data[, col]), na.rm = TRUE)) {
            # String has non-UTF8 characters -> assume windows-1252 encoding and
            # convert to UTF-8
            message(
              "Converting column ", sQuote(col),
              " from windows-1252 to UTF-8 encoding in ",
              table
            )
            table_data[, col] <- stri_encode(
              table_data[, col],
              "windows-1252",
              "UTF-8"
            )
          }
          # Convert UTF-8 strings to ASCII strings, if necessary translating
          # special characters
          message(
            "Converting column ", sQuote(col),
            " from UTF-8 to ASCII encoding in ",
            table
          )
          table_data[, col] <- stri_encode(table_data[, col], "UTF-8", "UTF-8")
          table_data[, col] <- stri_trans_general(
            table_data[, col],
            "latin-ascii"
          )
        }
      }
    }
    assign(table, table_data)
    rm(table_data)
  }
}
# Crops for which fertilizer data are available
fert_bands <- which(
  # Fertilizer pattern name
  nchar(crop_type_mapping[, fertilizer_pattern_map_col]) > 0 &
  # Fertilizer assigned to LPJmL CFT (no need to check crops which will not be
  # used anyway)
  nchar(crop_type_mapping[, cft_map_col]) > 0
)
# Check that all CFTs have at least one entry with fertilizer data
cft_no_source <- (!cft_bands %in% crop_type_mapping[fert_bands, cft_map_col])
if (
  !any(grepl("rainfed|irrigated", crop_type_mapping[fert_bands, cft_map_col]))
) {
  # Assume that crop_type_mapping does not distinguish between rainfed and
  # irrigated crops and uses the same mapping for both.
  cft_no_source <- cft_no_source & !cft_bands %in%
    paste("rainfed", crop_type_mapping[fert_bands, cft_map_col]) &
    !cft_bands %in% paste("irrigated", crop_type_mapping[fert_bands, cft_map_col])
  # Is mapping irrigation-specific?
  mapping_irr_spec <- FALSE
} else {
  mapping_irr_spec <- TRUE
}
if (any(cft_no_source) && process_fertilizer) {
  message(
    "The following CFT bands have no defined fertilizer source: ",
    toString(sQuote(cft_bands[which(cft_no_source)]))
  )
}
cat("*** Determine source datasets compatible with desired output: ***\n")
# Find fertilizer time series in temporary working directories
if (!process_fertilizer && !process_manure) {
  stop(
    paste(
      "You have disabled processing of both fertilizer and manure.",
      "Please enable at least one."
    )
  )
}
if (process_manure && !any(cft_bands_get_manure)) {
  message(
    "Info: You have selected processing of manure but have defined no ",
    "cft_bands to receive manure. Please check cft_bands_get_manure."
  )
}
fert_dir <- character()
fert_res <- list()
fert_names <- list()
fert_crops <- unique(crop_type_mapping[fert_bands, fertilizer_pattern_map_col])
if (process_fertilizer) {
  for (search_dir in list.dirs("tmp", recursive = FALSE)) {
    search_pattern <- paste0(
      "^(", paste(fert_crops, collapse = "|"), ")",
      #"^[- _[:alnum:]]+",
      cft_nut,
      "_timeseries_pattern_", fertilizer_pattern_admin, "_",
      ifelse(fertilizer_pattern_is_national, "national", "subnational"),
      "_trend_", fertilizer_trend_admin, "_",
      ifelse(fertilizer_trend_is_national, "national", "subnational"),
      "_\\d{4}-\\d{4}.nc$"
    )
    fert_names[[search_dir]] <- list.files(
      search_dir,
      search_pattern,
      full.names = TRUE
    )
    if (length(fert_names[[search_dir]]) > 0) {
      # Determine crops found in search_dir
      found_crops <- regmatches(
        basename(fert_names[[search_dir]]),
        regexpr(
          paste0("^(", paste(fert_crops, collapse = "|"), ")"),
          basename(fert_names[[search_dir]])
        )
      )
      if (!all(fert_crops %in% found_crops)) {
        # Directory has data for some, but not all fert_crops
        warning(
          "Directory ", sQuote(search_dir),
          " contains time series for ", length(fert_names[[search_dir]]),
          " crops, but the following crops defined in ",
          "crop_type_mapping[, ", fertilizer_pattern_map_col, "] are missing: ",
          toString(sQuote(setdiff(fert_crops, found_crops))),
          ". Please confirm that combine_fertilizer_pattern_trend_*.R",
          " successfully creates time series for all crops.",
          call. = FALSE,
          immediate. = TRUE
        )
        # By default: do not use incomplete set of crops. Change this only if
        # there is a good reason.
        warning(
          "Not using incomplete data in ", sQuote(search_dir),
          call. = FALSE, immediate. = TRUE
        )
        next
      }
      # search_dir has data that can potentially be used
      # Check resolution
      fert_raster <- raster(fert_names[[search_dir]][1], band = 1)
      fert2cft <- res(cft_raster) / res(fert_raster)
      if (any(fert2cft < 0.999)) {
        # Data resolution is too coarse for CFT output resolution.
        message(
          "Fertilizer time series data in ", sQuote(search_dir),
          " is too coarse for desired output resolution."
        )
        fert_names[[search_dir]] <- NULL
        rm(fert_raster)
        next
      }
      # Crop to output spatial extent if source data has larger extent.
      fert_raster <- crop(fert_raster, cft_raster)
      # Check alignment and whether resolution can be aggregated.
      fert_res_check <- try(
        match_admin_to_data(cft_raster, fert_raster, fun = sum, verbose = FALSE)
      )
      if (class(fert_res_check) == "try-error") {
        message(
          "Fertilizer time series data in ", sQuote(search_dir),
          " does not align with desired output grid"
        )
        fert_names[[search_dir]] <- NULL
        rm(fert_raster, fert_res_check)
        next
      }
      # Check if fert_raster covers full extent of cft_raster
      if (ncell(fert_res_check) != ncell(cft_raster)) {
        message(
          "Fertilizer time series data in ", sQuote(search_dir),
          " does not cover full extent of desired output grid"
        )
        fert_names[[search_dir]] <- NULL
        rm(fert_raster, fert_res_check)
        next
      }
      # Check unit
      tmp_nc <- nc_open(fert_names[[search_dir]][1])
      tmp_unit <- ncatt_get(
        tmp_nc,
        paste0(found_crops[1], cft_nut, "_timeseries"),
        "units"
      )
      nc_close(tmp_nc)
      if (!tmp_unit$hasatt) {
        warning(
          "Warning: No unit attribute set in ",
          sQuote(fert_names[[search_dir]][1]),
          ". Make sure unit ",
          sQuote(fertilizer_pattern_unit),
          " set in fertilizer_setup.R is correct.",
          call. = FALSE,
          immediate. = TRUE
        )
        # Set to fertilizer_pattern_unit
        tmp_unit$value <- fertilizer_pattern_unit
      }
      if (!ud.are.convertible(tmp_unit$value, cft_output_unit)) {
        message(
          "Info: Cannot use fertilizer time series data in ",
          sQuote(search_dir), " because unit ", sQuote(tmp_unit$value),
          " cannot be converted into desired output unit ",
          sQuote(cft_output_unit)
        )
        fert_names[[search_dir]] <- NULL
        rm(fert_raster, fert_res_check, tmp_nc, tmp_unit)
        next
      }
      cat(
        "Compatible fertilizer time series data found in",
        sQuote(search_dir),
        "\n"
      )
      fert_dir <- c(fert_dir, search_dir)
      fert_res[[search_dir]] <- res(fert_raster)
      rm(fert_raster, fert_res_check, tmp_nc, tmp_unit)
    } else {
      fert_names[[search_dir]] <- NULL
    }
  }
  if (length(fert_dir) == 0) {
    # No fertilizer time series data found with a resolution that is compatible
    # with cft_raster.
    stop("No compatible fertilizer time series data found")
  }
}
# Find manure time series in temporary working directories
manure_dir <- character(0)
manure_res <- list()
manure_names <- list()
if (process_manure && any(cft_bands_get_manure)) {
  # Is original source data given as rate per unit area or as total amount?
  tmp_is_rate <- !is.null(manure_ref_area) &&
    (length(manure_ref_area) == 1 && is.null(names(manure_ref_area)) ||
    cft_nut %in% names(manure_ref_area))
  # Area reference in original source data. "grid" or "cropland" if
  # manure_is_rate.
  tmp_ref_area <- ifelse(
    is.null(manure_ref_area),
    NULL,
    ifelse(
      is.null(names(manure_ref_area)) && length(manure_ref_area) == 1,
      manure_ref_area,
      ifelse(cft_nut %in% names(manure_ref_area), manure_ref_area[nut], NULL)
    )
  )
  # Optional maximum application rate.
  manure_apply_threshold <- ifelse(
    is.null(manure_threshold),
    Inf,
    ifelse(
      is.null(names(manure_threshold)) && length(manure_threshold) == 1,
      manure_threshold,
      ifelse(
        cft_nut %in% names(manure_threshold),
        manure_threshold[cft_nut],
        Inf
      )
    )
  )
  # Unit of optional maximum application rate.
  manure_apply_threshold_unit <- ifelse(
    length(manure_rate_unit) > 1, manure_rate_unit[nut], manure_rate_unit
  )
  # Derive mass component and area component in optional maximum application
  # rate.
  manure_apply_threshold_mass_unit <- regmatches(
    manure_apply_threshold_unit,
    regexpr("^[a-zA-Z]+", manure_apply_threshold_unit)
  )
  manure_apply_threshold_area_unit <- ifelse(
    grepl("km-2|/[ ]?km2", manure_apply_threshold_unit),
    "km2",
    ifelse(
      grepl("m-2|/[ ]?m2", manure_apply_threshold_unit),
      "m2",
      ifelse(
        grepl("ha-1|/[ ]?ha", manure_apply_threshold_unit),
        "ha",
        stop(
          paste(
            "Cannot detect area unit from",
            sQuote(manure_apply_threshold_unit)
          )
        )
      )
    )
  )
  # At which resolution to apply maximum application rate
  manure_apply_threshold_res <- ifelse(
    is.null(names(manure_threshold_res)) && length(manure_threshold_res) == 1,
    manure_threshold_res,
    ifelse(
      cft_nut %in% names(manure_threshold_res),
      manure_threshold_res[cft_nut],
      stop(
        paste0("Missing setting manure_threshold_res[", dQuote(cft_nut), "]")
      )
    )
  )
  for (search_dir in list.dirs("tmp", recursive = FALSE)) {
    search_pattern <- paste0(
      "manure_", cft_nut, "_rate_",
      ifelse(
        !tmp_is_rate | (!is.null(tmp_ref_area) & tmp_ref_area == "grid"),
        "scaled_",
        ""
      ),
      ifelse(
        is.finite(manure_apply_threshold) &
          manure_apply_threshold_res == "source",
        "limited_",
        ""
      ),
      "\\d{4}-\\d{4}.nc$"
    )
    manure_names[[search_dir]] <- list.files(
      search_dir,
      search_pattern,
      full.names = TRUE
    )
    if (length(manure_names[[search_dir]]) > 0) {
      tmp_fileyears <- integer(0)
      for (filename in manure_names[[search_dir]]) {
        tmp_nc <- nc_open(filename)
        tmp_fileyears <- c(tmp_fileyears, nc_file_years(tmp_nc))
        tmp_unit <- ncatt_get(
          tmp_nc,
          paste0("manure_", cft_nut, "_rate"),
          "units"
        )
        nc_close(tmp_nc)
        if (!tmp_unit$hasatt) {
          warning(
            "No unit attribute set in ",
            sQuote(filename),
            ". Make sure unit ",
            sQuote(manure_rate_unit),
            " set in fertilizer_setup.R is correct.",
            call. = FALSE,
            immediate. = TRUE
          )
          tmp_unit$value <- manure_apply_threshold_unit
        }
        if (!ud.are.convertible(tmp_unit$value, cft_output_unit)) {
          message(
            "Error: Cannot use manure time series data in ", sQuote(search_dir),
            " because unit ", sQuote(tmp_unit$value),
            " cannot be converted into desired output unit ",
            sQuote(cft_output_unit)
          )
          manure_names[[search_dir]] <- NULL
          break
        }
        if (is.finite(manure_apply_threshold) &&
          manure_apply_threshold_res == "target" &&
          !ud.are.convertible(tmp_unit$value, manure_apply_threshold_unit)
        ) {
          # Cannot apply manure_threshold because units are incompatible.
          message(
            "Error: Cannot use manure time series data in ", sQuote(search_dir),
            " because unit ", sQuote(tmp_unit$value),
            " is incompatible with defined manure_threshold ",
            manure_apply_threshold, manure_apply_threshold_unit
          )
          manure_names[[search_dir]] <- NULL
          break
        }
      }
      if (is.null(manure_names[[search_dir]])) {
        next
      }
      in_period <- which(
        tmp_fileyears >= min(cft_output_period) &
        tmp_fileyears <= max(cft_output_period)
      )
      if (any(table(tmp_fileyears[in_period]) > 1)) {
        # Files overlap, cannot be used
        message(
          "Error: Cannot use manure time series found in ",
          sQuote(search_dir), " because they overlap: ",
          toString(sQuote(basename(manure_names[[search_dir]])))
        )
        manure_names[[search_dir]] <- NULL
        next
      }
      # Check resolution
      manure_raster <- raster(
        manure_names[[search_dir]][1],
        band = 1,
        varname = paste0("manure_", cft_nut, "_rate")
      )
      manure2cft <- res(cft_raster) / res(manure_raster)
      if (any(manure2cft < 0.999)) {
        # Data resolution is too coarse for CFT output resolution.
        message(
          "Manure time series data in ", sQuote(search_dir),
          " is too coarse for desired output resolution"
        )
        rm(manure_raster)
        manure_names[[search_dir]] <- NULL
        next
      }
      # Crop to output spatial extent if source data has larger extent.
      manure_raster <- crop(manure_raster, cft_raster)
      # Check alignment and whether resolution can be aggregated.
      manure_res_check <- try(
        match_admin_to_data(
          cft_raster,
          manure_raster,
          fun = sum,
          verbose = FALSE
        )
      )
      if (class(manure_res_check) == "try-error") {
        message(
          "Manure time series data in ", sQuote(search_dir),
          " does not align with desired output grid"
        )
        manure_names[[search_dir]] <- NULL
        rm(manure_raster, manure_res_check)
        next
      }
      # Check if manure_raster covers full extent of cft_raster
      if (ncell(manure_res_check) != ncell(cft_raster)) {
        message(
          "Manure time series data in ", sQuote(search_dir),
          " does not cover full extent of desired output grid"
        )
        manure_names[[search_dir]] <- NULL
        rm(manure_raster, manure_res_check)
        next
      }        
      cat(
        "Compatible manure time series data found in", sQuote(search_dir), "\n"
      )
      manure_dir <- c(manure_dir, search_dir)
      manure_res[[search_dir]] <- res(manure_raster)
      rm(manure_raster, manure_res_check)
      if (length(tmp_fileyears) != max(tmp_fileyears) - min(tmp_fileyears) + 1) {
        warning(
          "Manure time series data in ", sQuote(search_dir),
          " has gaps. Missing year(s): ",
          toString(
            sort(
              setdiff(
                seq(min(tmp_fileyears), max(tmp_fileyears)),
                tmp_fileyears
              )
            )
          ),
          call. = FALSE,
          immediate. = TRUE
        )
      }
    }
  }
  if (length(manure_dir) == 0) {
    # No manure time series data found with a resolution that is compatible
    # with cft_raster.
    stop("No compatible manure time series data found")
  }
}
################################################################################
## Determine if datasets set up for weighted aggregation are compatible with  ##
## source datasets they will be used for.                                     ##
cat("*** Determine compatible weighting datasets: ***\n")
if (process_fertilizer) {
  # Harvested area dataset
  # Detect available file(s)
  if (length(ha_weighting_name_pattern) != 1) {
    # Support for multiple file name patterns currently not implemented.
    stop("Multiple patterns for ha_weighting_name_pattern not supported")
  }
  ha_weighting_dir <- dirname(ha_weighting_name_pattern)
  ha_weighting_names <- list.files(
    ha_weighting_dir,
    pattern = basename(ha_weighting_name_pattern),
    full.names = TRUE
  )
  if (length(ha_weighting_names) == 0) {
    stop(
      paste(
        "No harvested area files found matching search pattern",
        sQuote(gsub("\\", "\\\\", ha_weighting_name_pattern, fixed = TRUE))
      )
    )
  }
  # Check resolution
  ha_weighting_raster <- raster(
    ha_weighting_names[1],
    band = 1,
    level = 1,
    varname = ha_weighting_varname[1]
  )
  # Check crop names in files.
  if (!is.null(ha_weighting_crop_names)) {
    ha_weighting_crop_names_src <- "user"
  }
  if (!is.null(ha_weighting_crop_varname)) {
    # NetCDF files have variable containing crop names. Read them.
    for (filename in ha_weighting_names) {
      tmp_nc <- nc_open(filename)
      if (is.null(ha_weighting_crop_names)) {
        # Read crop names from file into variable ha_weighting_crop_names
        ha_weighting_crop_names <- ncvar_get(tmp_nc, ha_weighting_crop_varname)
        ha_weighting_crop_names_src <- filename
      } else {
        # Confirm that crop names in file match ha_weighting_crop_names
        if (!identical(
          ha_weighting_crop_names,
          ncvar_get(tmp_nc, ha_weighting_crop_varname)
        )) {
          stop(
            paste(
              "Crop names in harvested area time series file",
              sQuote(filename),
              "do not match ha_weighting_crop_names",
              ifelse(
                ha_weighting_crop_names_src == "user",
                "supplied by user",
                paste("read from", sQuote(ha_weighting_crop_names_src))
              )
            )
          )
        }
      }
      # Check that harvested area variables have correct number of crop bands.
      for (tmp_varname in ha_weighting_varname) {
        if (tmp_nc[["var"]][[tmp_varname]][["varsize"]][3] !=
          length(ha_weighting_crop_names)
        ) {
          nc_close(tmp_nc)
          stop(
            paste(
              "Variable dimensions for", sQuote(tmp_varname),
              "do not match ha_weighting_crop_varname in file",
              sQuote(filename)
            )
          )
        }
        tmp_unit <- ncatt_get(tmp_nc, tmp_varname, "units")
        if (!tmp_unit$hasatt) {
          warning(
            "No unit attribute set for ", sQuote(tmp_varname),
            " in file ", sQuote(filename),
            ". Cannot determine whether harvested area is absolute area or",
            " cell fraction.",
            call. = FALSE,
            immediate. = TRUE
          )
        } else if (!ud.are.convertible(tmp_unit$value, "m2")) {
          warning(
            "Unit attribute ", sQuote(tmp_unit$value),
            " set for ", sQuote(tmp_varname), " in file ", sQuote(filename),
            " is not an absolute area, which leads to inaccuracies in case of",
            " weighted spatial aggregation.",
            call. = FALSE,
            immediate. = TRUE
          )
        }
      }
      nc_close(tmp_nc)
    }
  } else {
    # If crop names are not determined from files, at least check that harvested
    # area variables have correct number of crop bands.
    for (filename in ha_weighting_names) {
      tmp_nc <- nc_open(filename)
      for (tmp_varname in ha_weighting_varname) {
        if (tmp_nc[["var"]][[tmp_varname]][["varsize"]][3] !=
          length(ha_weighting_crop_names)
        ) {
          nc_close(tmp_nc)
          stop(
            paste(
              "Variable dimensions for", sQuote(tmp_varname),
              "do not match ha_weighting_crop_varname in file",
              sQuote(filename)
            )
          )
        }
        tmp_unit <- ncatt_get(tmp_nc, tmp_varname, "units")
        if (!tmp_unit$hasatt) {
          warning(
            "No unit attribute set for ", sQuote(tmp_varname),
            " in file ", sQuote(filename),
            ". Cannot determine whether harvested area is absolute area or",
            " cell fraction.",
            call. = FALSE,
            immediate. = TRUE
          )
        } else if (!ud.are.convertible(tmp_unit$value, "m2")) {
          warning(
            "Unit attribute ", sQuote(tmp_unit$value),
            " set for ", sQuote(tmp_varname), " in file ", sQuote(filename),
            " is not an absolute area, which may lead to inaccuracies in case",
            " of weighted spatial aggregation.",
            call. = FALSE,
            immediate. = TRUE
          )
        }
      }
      nc_close(tmp_nc)
    }
  }
  # Check if crop names already contain rainfed/irrigated attribute.
  if (!is.null(names(ha_weighting_varname))) {
    if (all(grepl("rainfed|irrigated", names(ha_weighting_varname)))) {
      # Harvested area time series has separate variables for rainfed and
      # irrigated crops. Check whether crop names contain rainfed/irrigated
      # attribute.
      if (any(grepl("rainfed|irrigated", ha_weighting_crop_names))) {
        # Crop names in harvested area time series contain rainfed/irrigated
        # attribute.
        stop(
          paste(
            "Unexpected rainfed/irrigated attribute in crop name(s)",
            toString(
              sQuote(
                grep("rainfed|irrigated", ha_weighting_crop_names, value = TRUE)
              )
            ),
            "in harvested area time series"
          )
        )
      }
    } else {
      stop(
        paste(
          "Unexpected named element(s)",
          toString(
            sQuote(
              setdiff(names(ha_weighting_varname), c("rainfed", "irrigated"))
            )
          ),
          "in ha_weighting_varname"
        )
      )
    }
  } else if (!all(grepl("rainfed|irrigated", ha_weighting_crop_names)) &&
    (any(grepl("rainfed", cft_bands)) && any(grepl("irrigated", cft_bands)))
  ) {
    # There are rainfed and irrigated CFT bands.
    # There are no separate variables for rainfed and irrigated harvested areas,
    # but not all crop names include rainfed/irrigated attribute.
    stop(
      paste(
        "Harvested area time series in",
        sQuote(ha_weighting_dir),
        "does not contain separate variables for rainfed and irrigated",
        "harvested areas. However, crop names do not contain rainfed/irrigated",
        "attribute."
      )
    )
  }
  # Prepare to match crop names in harvested area time series with crop names
  # used for fertilizer time series.
  if (!mapping_irr_spec) {
    # crop_type_mapping does not distinguish between rainfed and irrigated
    # crops so duplicate
    use_mapping <- data.frame()
    for (irr in c("rainfed", "irrigated")) {
      if (any(grepl(irr, cft_bands))) {
        use_mapping <- rbind(
          use_mapping,
          data.frame(
            crop_type_mapping[, fertilizer_pattern_map_col],
            ifelse(
              nchar(crop_type_mapping[, monfreda_map_col]) > 0,
              paste(irr, crop_type_mapping[, monfreda_map_col]),
              NA
            ),
            ifelse(
              nchar(crop_type_mapping[, fao_name_map_col]) > 0,
              paste(irr, crop_type_mapping[, fao_name_map_col]),
              NA
            ),
            crop_type_mapping[, fao_code_map_col],
            ifelse(
              nchar(crop_type_mapping[, cft_map_col]) > 0,
              paste(irr, crop_type_mapping[, cft_map_col]),
              NA
            ),
            check.names = FALSE
          ),
          deparse.level = 0,
          make.row.names = FALSE
        )
      }
    }
    if (ncol(use_mapping) > 0) {
      colnames(use_mapping) <- c(
        fertilizer_pattern_map_col,
        monfreda_map_col,
        fao_name_map_col,
        fao_code_map_col,
        cft_map_col
      )
    }
  } else {
    col <- c(
      fertilizer_pattern_map_col,
      monfreda_map_col,
      fao_name_map_col,
      fao_code_map_col,
      cft_map_col
    )
    use_mapping <- crop_type_mapping[, col]
  }
  # Reduce use_mapping to CFTs included in cft_bands
  use_mapping <- use_mapping[which(use_mapping[, cft_map_col] %in% cft_bands), ]
  fert_bands <- which(
    nchar(use_mapping[, fertilizer_pattern_map_col]) > 0 &
    nchar(use_mapping[, cft_map_col]) > 0
  )
  fert_crops <- use_mapping[fert_bands, fertilizer_pattern_map_col]

  # Try to match crop names in harvested area time series to crop names in
  # fertilizer time series.
  fert_weighting_table <- data.frame(
    fert = fert_crops,
    cft_band = use_mapping[fert_bands, cft_map_col],
    weighting = rep(NA, length(fert_crops))
  )
  # FAOSTAT item name direct match
  if (!is.null(names(ha_weighting_varname))) {
    ind <- which(use_mapping[fert_bands, fao_name_map_col] %in%
      paste(
        names(ha_weighting_varname),
        rep(ha_weighting_crop_names, each = length(ha_weighting_varname))
      )
    )
  } else {
    ind <- which(use_mapping[fert_bands, fao_name_map_col] %in%
      ha_weighting_crop_names)
  }
  fert_weighting_table[ind, "weighting"] <-
    use_mapping[fert_bands[ind], fao_name_map_col]
  if (anyNA(fert_weighting_table[, "weighting"])) {
    # Monfreda name match
    if (!is.null(names(ha_weighting_varname))) {
      ind <- which(is.na(fert_weighting_table[, "weighting"]) &
        use_mapping[fert_bands, monfreda_map_col] %in% setdiff(
          paste(
            names(ha_weighting_varname),
            rep(ha_weighting_crop_names, each = length(ha_weighting_varname))
          ),
          na.omit(fert_weighting_table[, "weighting"])
        )
      )
    } else {
      ind <- which(is.na(fert_weighting_table[, "weighting"]) &
        use_mapping[fert_bands, monfreda_map_col] %in% setdiff(
          ha_weighting_crop_names, na.omit(fert_weighting_table[, "weighting"])
        )
      )
    }
    fert_weighting_table[ind, "weighting"] <-
      use_mapping[fert_bands[ind], monfreda_map_col]
  }
  if (anyNA(fert_weighting_table[, "weighting"])) {
    # Fertilizer crops with missing harvested area crop name
    missing_crop <- which(is.na(fert_weighting_table$weighting))
    # Index in use_mapping
    missing_map <- fert_bands[missing_crop]
    # Compute string distance between FAOSTAT_item_name and all unassigned crops
    # in ha_weighting_crop_names
    if (!is.null(names(ha_weighting_varname))) {
      avail <- setdiff(
        paste(
          names(ha_weighting_varname),
          rep(ha_weighting_crop_names, each = length(ha_weighting_varname))
        ),
        fert_weighting_table$weighting
      )
    } else {
      avail <- setdiff(ha_weighting_crop_names, fert_weighting_table$weighting)
    }
    distmatrix <- stringdistmatrix(
      ifelse(
        is.na(use_mapping[missing_map, fao_name_map_col]),
        "",
        use_mapping[missing_map, fao_name_map_col]
      ),
      avail
    )
    fert_weighting_table[missing_crop, "weighting"] <- ifelse(
      # Only replace if distance is less than half the characters
      apply(distmatrix, 1, min) < nchar(
        # do not count "rainfed" / "irrigated" towards string length
        sub(
          "rainfed |irrigated ",
          "",
          use_mapping[missing_map, fao_name_map_col]
        )
      ) / 2,
      avail[apply(distmatrix, 1, which.min)],
      NA
    )
    if (any(!is.na(fert_weighting_table[missing_crop, "weighting"]))) {
      inserted <- setdiff(
        missing_crop,
        which(is.na(fert_weighting_table$weighting))
      )
      # Index in use_mapping
      # Update fertilizer crops with missing harvested area crop name
      missing_crop <- which(is.na(fert_weighting_table$weighting))
      # Index in use_mapping
      missing_map <- fert_bands[missing_crop]
      for (ind in seq_along(missing_crop)) {
        if (!is.null(names(ha_weighting_varname))) {
          avail <- setdiff(
            paste(
              names(ha_weighting_varname),
              rep(ha_weighting_crop_names, each = length(ha_weighting_varname))
            ),
            fert_weighting_table$weighting
          )
        } else {
          avail <- setdiff(
            ha_weighting_crop_names,
            fert_weighting_table$weighting
          )
        }
        if (nchar(use_mapping[missing_map[ind], fao_name_map_col]) > 3 &
          length(
            grep(
              use_mapping[missing_map[ind], fao_name_map_col],
              avail,
              ignore.case = TRUE
            )
          ) == 1
        ) {
          fert_weighting_table[missing_crop[ind], "weighting"] <- grep(
            use_mapping[missing_map[ind], fao_name_map_col],
            avail,
            ignore.case = TRUE,
            value = TRUE
          )
        }
        if (nchar(use_mapping[missing_map[ind], monfreda_map_col]) > 3 &
          length(
            grep(
              use_mapping[missing_map[ind], monfreda_map_col],
              avail,
              ignore.case = TRUE
            )
          ) == 1
        ) {
          fert_weighting_table[missing_crop[ind], "weighting"] <- grep(
            use_mapping[missing_map[ind], "Monfreda_name"],
            avail,
            ignore.case = TRUE,
            value = TRUE
          )
        }
      }
      inserted <- union(
        inserted,
        setdiff(missing_crop, which(is.na(fert_weighting_table$weighting)))
      )
      inserted_map <- fert_bands[inserted]
      cat(
        "Fuzzy matching of crop names between fertilizer time series and",
        "harvested area time series:\n"
      )
      tmp_table <- data.frame(
        Fertilizer_name = fert_weighting_table[inserted, "fert"],
        Declared_ha_name = use_mapping[inserted_map, fao_name_map_col],
        Assigned_ha_name =  fert_weighting_table[inserted, "weighting"]
      )
      saved_width <- options()$width
      width <- sum(
        apply(sapply(rbind(tmp_table, colnames(tmp_table)), nchar), 2, max)
      ) + 10
      options(width = width)
      print(tmp_table)
      cat(
        "Check if these are correct and consider updating mapping_file",
        sQuote(mapping_file), "\n"
      )
      rm(tmp_table)
      options(width = saved_width)
    }
  }
  # Check if there are still any missing assignments for bands supposed to use
  # harvested area weighting
  missing_weighting_ha <- which(is.na(fert_weighting_table$weighting) &
    fert_weighting_table$cft_band %in% cft_bands[ha_weighting_bands]
  )
  if (length(missing_weighting_ha) > 0) {
    # Fail if any fertilizer crop from mapping file cannot be assigned a
    # corresponding harvested area crop. This could be changed into a warning.
    tmp_table <- use_mapping[fert_bands[missing_weighting_ha], ]
    saved_width <- options()$width
    width <- sum(
      apply(
        sapply(
          rbind(tmp_table, colnames(tmp_table)),
          function(indata) nchar(ifelse(is.na(indata), "NA", indata))
        ), 2, max)
    ) + 10
    # Redirect the following cat and print statements to stderr to appear with
    # stop message.
    sink(stderr())
    options(width = width)
    cat(
      "Error: Could not find matching crop in harvested area time series for",
      "the following:\n"
    )
    print(tmp_table)
    options(width = saved_width)
    sink()
    stop(paste("Please check crop_type_mapping from", sQuote(mapping_file)))
  }
  # Crop to output spatial extent if source data has larger extent.
  ha_weighting_raster <- crop(ha_weighting_raster, cft_raster)
  # Compare to all detected version of fertilizer time series
  ha_weighting_res_match <- character(0)
  for (fert_opt in fert_dir) {
    fert_raster <- raster(fert_names[[fert_opt]][1], band = 1)
    HA2fert <- res(fert_raster) / res(ha_weighting_raster)
    if (any(HA2fert < 0.999)) {
      # Data resolution is too coarse for fertilizer time series resolution.
      message(
        "Harvested area time series data in ",
        sQuote(dirname(ha_weighting_name_pattern)),
        " is too coarse for fertilizer time series in ", sQuote(fert_opt)
      )
      rm(fert_raster)
      # Remove fert_opt as valid option because there is no compatible harvested
      # area dataset for weighting.
      fert_dir <- fert_dir[which(fert_dir != fert_opt)]
      fert_res[[fert_opt]] <- NULL
      fert_names[[fert_opt]] <- NULL
      next
    }
    # Crop to output spatial extent if source data has larger extent.
    fert_raster <- crop(fert_raster, cft_raster)
    # Check alignment and whether resolution can be aggregated.
    ha_weighting_res_check <- try(
      match_admin_to_data(
        fert_raster,
        ha_weighting_raster,
        fun = sum,
        verbose = FALSE
      )
    )
    if (class(ha_weighting_res_check) == "try-error") {
      message(
        "Harvested area time series data in ",
        sQuote(dirname(ha_weighting_name_pattern)),
        " does not align with fertilizer time series in ", sQuote(search_dir)
      )
      rm(fert_raster, ha_weighting_res_check)
      # Remove fert_opt as valid option because there is no compatible harvested
      # area dataset for weighting.
      fert_dir <- fert_dir[which(fert_dir != fert_opt)]
      fert_res[[fert_opt]] <- NULL
      fert_names[[fert_opt]] <- NULL
      next
    }
    # Check if ha_weighting_raster covers full extent of fert_raster
    if (ncell(ha_weighting_res_check) != ncell(fert_raster)) {
      message(
        "Harvested area time series data in ", 
        sQuote(dirname(ha_weighting_name_pattern)),
        " does not cover full extent of desired output grid"
      )
      # Remove fert_opt as valid option because there is no compatible harvested
      # area dataset for weighting.
      fert_dir <- fert_dir[which(fert_dir != fert_opt)]
      fert_res[[fert_opt]] <- NULL
      fert_names[[fert_opt]] <- NULL
      rm(fert_raster, ha_weighting_res_check)
      next
    }        
    rm(fert_raster, ha_weighting_res_check)
    # List harvested area time series as valid weighting option for fert_opt
    ha_weighting_res_match <- c(ha_weighting_res_match, fert_opt)
  }
  rm(ha_weighting_raster)
  if (length(ha_weighting_res_match) > 0) {
    # Check file years covered by harvested area time series
    ha_weighting_fileyears <- integer()
    ha_weighting_nc <- list()
    for (filename in ha_weighting_names) {
      tmp_nc <- nc_open(filename)
      tmp_fileyears <- nc_file_years(tmp_nc)
      ha_weighting_fileyears <- c(ha_weighting_fileyears, tmp_fileyears)
      ind <- seq(
        to = length(ha_weighting_fileyears), length.out = length(tmp_fileyears)
      )
      names(ha_weighting_fileyears)[ind] <- basename(filename)
      # If harvested area file is within cft_output_period save NetCDF pointer
      # for later.
      if (any(tmp_fileyears >= min(cft_output_period)) &&
        !all(tmp_fileyears > max(cft_output_period))
      ) {
        ha_weighting_nc[[length(ha_weighting_nc) + 1]] <- tmp_nc
        names(ha_weighting_nc)[length(ha_weighting_nc)] <- min(tmp_fileyears)
      } else {
        # Close NetCDF pointer if not needed anymore.
        nc_close(tmp_nc)
      }
    }
    # Make sure NetCDF pointers are in chronological order
    ha_weighting_nc <- ha_weighting_nc[sort(names(ha_weighting_nc))]
    # Check chronological consistency during cft_output_period
    in_period <- which(
      ha_weighting_fileyears >= min(cft_output_period) &
      ha_weighting_fileyears <= max(cft_output_period)
    )
    if (any(table(ha_weighting_fileyears[in_period]) > 1)) {
      # Files overlap or multiple versions of harvested area dataset matching
      # search pattern, cannot be used
      message(
        "Error: Cannot use harvested area time series found in ",
        sQuote(dirname(ha_weighting_name_pattern)), " because files overlap."
      )
      tmp_table <- data.frame(
        Year = names(which(table(ha_weighting_fileyears[in_period]) > 1))
      )
      for (col in seq_len(max(table(ha_weighting_fileyears[in_period])))) {
        tmp_table <- cbind(tmp_table, rep(NA, nrow(tmp_table)))
        colnames(tmp_table)[col + 1] <- paste("Covered by file", col, sep = "_")
      }
      for (r in seq_len(nrow(tmp_table))) {
        r2 <- which(ha_weighting_fileyears == tmp_table$Year[r])
        col <- seq(2, length.out = length(r2))
        tmp_table[r, col] <- names(ha_weighting_fileyears)[r2]
      }
      saved_width <- options()$width
      options(width = max(rowSums(sapply(tmp_table, nchar))) + 10)
      # Redirect the following outputs to stderr to appear together with message
      # and stop
      sink(stderr())
      print(tmp_table[seq_len(min(10, nrow(tmp_table))), ])
      if (nrow(tmp_table) > 10) {
        cat(
          "[...]", nrow(tmp_table) - 10,
          "more year(s) covered by multiple source files.\n"
        )
      }
      sink()
      options(width = saved_width)
      if (length(ha_weighting_nc) > 0) {
        sapply(ha_weighting_nc, nc_close)
      }
      stop("No compatible harvested area dataset for fertilizer time series")
    }
    if (length(in_period) != max(ha_weighting_fileyears[in_period]) -
      min(ha_weighting_fileyears[in_period]) + 1
    ) {
      warning(
        "There are gaps in harvested area time series. ",
        "Missing years: ",
        toString(
          setdiff(
            seq(
              min(ha_weighting_fileyears[in_period]),
              max(ha_weighting_fileyears[in_period])
            ),
            ha_weighting_fileyears
          )
        ),
        call. = FALSE,
        immediate. = TRUE
      )
    }
    if (length(in_period) != max(cft_output_period) -
      min(cft_output_period) + 1
    ) {
      warning(
        "Harvested area time series does not cover the full desired ",
        "output period.",
        call. = FALSE,
        immediate. = TRUE
      )
    }
    cat(
      "Compatible harvested area time series in",
      sQuote(dirname(ha_weighting_name_pattern)),
      "found as weighting dataset for fertilizer time series in",
      toString(sQuote(fert_dir)), "\n"
    )
    rm(ha_weighting_fileyears)
  } else {
    stop(
      "No compatible harvested area time series found to use as weighting ",
      "dataset for fertilizer time series"
    )
  }

  # Optional weighting dataset used for pastures
  if (!is.null(pasture_weighting_name) && length(pasture_weighting_bands) > 0) {
    if (is.null(names(pasture_weighting_name)) &&
      length(pasture_weighting_name) > 1
    ) {
      # For the moment, do not support multiple pasture_weighting_name values
      # unless they are named.
      if (exists("ha_weighting_nc") && length(ha_weighting_nc) > 0) {
        sapply(ha_weighting_nc, nc_close)
      }
      stop(
        paste(
          "Multiple values for pasture_weighting_name not supported unless",
          "they are named."
        )
      )
    }
    if (!is.null(names(pasture_weighting_name)) &&
      !is.null(names(pasture_weighting_varname)) &&
      !identical(names(pasture_weighting_name), names(pasture_weighting_varname))
    ) {
      # Force pasture_weighting_name and pasture_weighting_varname to use the
      # same names or no names.
      if (exists("ha_weighting_nc") && length(ha_weighting_nc) > 0) {
        sapply(ha_weighting_nc, nc_close)
      }
      stop(
        paste(
          "pasture_weighting_name and pasture_weighting_varname must either",
          "use no names or the same names."
        )
      )
    }
    if (!is.null(names(pasture_weighting_varname)) &&
      !all(names(pasture_weighting_varname) %in% c("rainfed", "irrigated"))
    ) {
      # Only support "rainfed" and "irrigated" as names for
      # pasture_weighting_varname
      stop(
        paste(
          "Unexpected named element(s)",
          toString(
            sQuote(
              setdiff(
                names(pasture_weighting_varname),
                c("rainfed", "irrigated")
              )
            )
          ),
          "in pasture_weighting_varname"
        )
      )
    }
      
    pasture_weighting_res_match <- character(0)
    pasture_weighting_is_fractional <- FALSE
    for (pasture_opt in names(pasture_weighting_varname)) {
      if (is.null(pasture_weighting_varname[pasture_opt]))
        next
      tmp_filename <- ifelse(
        is.null(names(pasture_weighting_name)),
        pasture_weighting_name,
        pasture_weighting_name[pasture_opt]
      )
      pasture_raster <- raster(
        tmp_filename,
        band = 1,
        varname = pasture_weighting_varname[pasture_opt]
      )
      
      # Crop to output spatial extent if source data has larger extent.
      pasture_raster <- crop(pasture_raster, cft_raster)
      for (fert_opt in fert_dir) {
        fert_raster <- raster(fert_names[[fert_opt]][1], band = 1)
        pasture2fert <- res(fert_raster) / res(pasture_raster)
        if (any(pasture2fert < 0.999)) {
          # Data resolution is too coarse for fertilizer time series resolution.
          message(
            "Pasture weighting time series data in ",
            sQuote(tmp_filename),
            " is too coarse for fertilizer time series in ", sQuote(fert_opt)
          )
          rm(fert_raster)
          # Remove fert_opt as valid option because there is no compatible
          # pasture weighting dataset.
          fert_dir <- fert_dir[which(fert_dir != fert_opt)]
          fert_res[[fert_opt]] <- NULL
          fert_names[[fert_opt]] <- NULL
          next
        }
        # Crop to output spatial extent if source data has larger extent.
        fert_raster <- crop(fert_raster, cft_raster)
        # Check alignment and whether resolution can be aggregated.
        pasture_weighting_res_check <- try(
          match_admin_to_data(
            fert_raster,
            pasture_raster,
            fun = sum,
            verbose = FALSE
          )
        )
        if (class(pasture_weighting_res_check) == "try-error") {
          message(
            "Pasture time series data in ", sQuote(tmp_filename),
            " does not align with fertilizer time series in ", sQuote(fert_opt)
          )
          rm(fert_raster, pasture_weighting_res_check)
          # Remove fert_opt as valid option because there is no compatible
          # pasture dataset for weighting.
          fert_dir <- fert_dir[which(fert_dir != fert_opt)]
          fert_res[[fert_opt]] <- NULL
          fert_names[[fert_opt]] <- NULL
          # If there is more than one pasture_opt make sure
          # pasture_weighting_res_match is valid for all.
          pasture_weighting_res_match <- setdiff(
            pasture_weighting_res_match,
            fert_opt
          )
          next
        }
        # Check if pasture_raster covers full extent of fert_raster
        if (ncell(pasture_weighting_res_check) != ncell(fert_raster)) {
          message(
            "Pasture time series data in ", sQuote(tmp_filename),
            " does not cover full extent of desired output grid"
          )
          # Remove fert_opt as valid option because there is no compatible
          # pasture dataset for weighting.
          fert_dir <- fert_dir[which(fert_dir != fert_opt)]
          fert_res[[fert_opt]] <- NULL
          fert_names[[fert_opt]] <- NULL
          # If there is more than one pasture_opt make sure
          # pasture_weighting_res_match is valid for all.
          pasture_weighting_res_match <- setdiff(
            pasture_weighting_res_match,
            fert_opt
          )
          rm(fert_raster, pasture_weighting_res_check)
          next
        }        
        rm(fert_raster, pasture_weighting_res_check)
        # List pasture time series as valid weighting option for fert_opt
        pasture_weighting_res_match <- union(
          pasture_weighting_res_match,
          fert_opt
        )
      }
      # Set weighting in use_mapping
      r <- which(fert_weighting_table[, "cft_band"] %in%
        grep(pasture_opt, cft_bands[pasture_weighting_bands], value = TRUE)
      )
      fert_weighting_table[r, "weighting"] <- paste(pasture_opt, "pasture")
    }
    missing_weighting_pasture <- which(is.na(fert_weighting_table$weighting) &
      fert_weighting_table$cft_band %in% cft_bands[pasture_weighting_bands]
    )
    if (length(missing_weighting_pasture) > 0) {
      # By default, HYDE grazing land does not have any irrigated pasture.
      # Therefore, only warn im case of missing weight for pastures.
      r <- which(
        fert_weighting_table$cft_band %in% cft_bands[pasture_weighting_bands]
      )
      tmp_table <- fert_weighting_table[r, ]
      saved_width <- options()$width
      width <- sum(
        apply(
          sapply(
            rbind(tmp_table, colnames(tmp_table)),
            function(indata) nchar(ifelse(is.na(indata), "NA", indata))
          ),
          2,
          max
        )
      ) + 10
      options(width = width)
      warning(
        "Could not determine matching weight for all pasture bands",
        " in cft_bands. Bands without weight will not receive any fertilizer:",
        call. = FALSE,
        immediate. = TRUE
      )
      sink(stderr())
      print(tmp_table)
      sink()
      options(width = saved_width)
      rm(tmp_table)
    }
    if (length(pasture_weighting_res_match) > 0) {
      # Check file years in pasture weighting file(s)
      for (pasture_weighting_opt in seq_along(pasture_weighting_name)) {
        filename <- pasture_weighting_name[pasture_weighting_opt]
        tmp_nc <- nc_open(filename)
        tmp_fileyears <- nc_file_years(tmp_nc)
        in_period <- which(
          tmp_fileyears >= min(cft_output_period) &
          tmp_fileyears <= max(cft_output_period)
        )
        if (length(in_period) != max(tmp_fileyears[in_period]) -
          min(tmp_fileyears[in_period]) + 1
        ) {
          warning(
            "There are gaps in pasture time series ",
            sQuote(filename),
            ". Missing years: ",
            toString(
              setdiff(
                seq(min(tmp_fileyears[in_period]), max(tmp_fileyears[in_period])),
                tmp_fileyears
              )
            ),
            call. = FALSE,
            immediate. = TRUE
          )
        }
        if (length(in_period) != max(cft_output_period) -
          min(cft_output_period) + 1
        ) {
          warning(
            "Warning: pasture time series ",
            sQuote(filename),
            " does not cover the full desired output period.",
            call. = FALSE,
            immediate. = TRUE
          )
        }
        # Check unit of pasture data. If necessary, test for compatible area
        # file.
        for (tmp_varname in pasture_weighting_varname) {
          if (tmp_varname %in% names(tmp_nc$var)) {
            tmp_unit <- ncatt_get(tmp_nc, tmp_varname, "units")
            if (!tmp_unit$hasatt) {
              warning(
                "No unit attribute set in ", sQuote(filename),
                " for variable ", sQuote(tmp_varname),
                ". Make sure pasture_weighting_unit ",
                sQuote(pasture_weighting_unit),
                " is correct.",
                call. = FALSE,
                immediate. = TRUE
              )
              # Set to unit defined by user
              tmp_unit$value <- pasture_weighting_unit
            }
            pasture_weighting_is_fractional <- FALSE
            if (!ud.are.convertible(tmp_unit$value, "m2")) {
              # Pasture is not an absolute area.
              if (ud.are.convertible(tmp_unit$value, "1")) {
                pasture_weighting_is_fractional <- TRUE
                if (is.null(pasture_weighting_area_file) ||
                  !file.exists(pasture_weighting_area_file)
                ) {
                  if (!is.null(pasture_weighting_area_file)) {
                    warning(
                      "Defined pasture_weighting_area_file ",
                      sQuote(filename),
                      " does not exist.",
                      call. = FALSE,
                      immediate. = TRUE
                    )
                  }
                  warning(
                    "Unit of pasture weighting file ",
                    sQuote(filename),
                    " is fractional but no corresponding area is available.",
                    " Using internal calculation to derive cell area",
                    call. = FALSE,
                    immediate. = TRUE
                  )
                } else {
                  pasture_area_raster <- raster(pasture_weighting_area_file)
                  pasture_area_raster <- crop(
                    pasture_area_raster,
                    pasture_raster
                  )
                  # Check alignment and whether resolution can be aggregated.
                  pasture_area_res_check <- try(
                    match_admin_to_data(
                      pasture_raster,
                      pasture_area_raster,
                      fun = sum,
                      verbose = FALSE
                    )
                  )
                  if (class(pasture_area_res_check) == "try-error") {
                    stop(
                      paste(
                        "Pasture area", sQuote(pasture_weighting_area_file),
                        "does not align with pasture data.",
                        "Please provide compatible pasture_weighting_area_file."
                      )
                    )
                  }
                  rm(pasture_area_res_check, pasture_area_raster)
                }
              } else {
                warning(
                  "Unit ", sQuote(tmp_unit$value), " for variable ",
                  sQuote(tmp_varname), " in file ", sQuote(filename),
                  " is neither fractional nor an absolute area.",
                  " This may lead to inaccuracies in case of weighted spatial",
                  " aggregation.",
                  call. = FALSE,
                  immediate. = TRUE
                )
              }
            }
          }
        }
        rm(pasture_raster)
        nc_close(tmp_nc)
      }
      cat(
        "Compatible pasture time series",
        toString(sQuote(pasture_weighting_name)),
        "found as weighting dataset for fertilizer time series in",
        toString(sQuote(fert_dir)), "\n"
      )
      # Open NetCDFs for later
      pasture_weighting_nc <- list()
      if (is.null(names(pasture_weighting_name))) {
        pasture_weighting_nc[[1]] <- nc_open(pasture_weighting_name)
      } else {
        for (pasture_weighting_opt in names(pasture_weighting_name)) {
          pasture_weighting_nc[[pasture_weighting_opt]] <-
            nc_open(pasture_weighting_name[pasture_weighting_opt])
        }
      }
    } else {
      if (exists("ha_weighting_nc") && length(ha_weighting_nc) > 0) {
        sapply(ha_weighting_nc, nc_close)
      }
      stop(
        paste(
          "No compatible pasture time series found to use as weighting",
          "dataset for fertilizer time series"
        )
      )
    }
  } else if (length(pasture_weighting_bands) > 0) {
    warning(
      "You have set no pasture weighting dataset to use for spatial ",
      "aggregation on pasture areas.",
      call. = FALSE,
      immediate. = TRUE
    )
  }
  # If there is more than one valid source dataset use the one with coarsest
  # resolution.
  if (length(fert_dir) > 1) {
    fert_dir <- names(which.max(lapply(fert_res, prod)))
    fert_res <- fert_res[[fert_dir]]
    fert_names <- fert_names[[fert_dir]]
    cat(
      "Fertilizer time series in", sQuote(fert_dir), "selected for use.\n"
    )
  }
  # Open NetCDF files
  fert_nc <- list()
  for (crop_name in unique(fert_weighting_table$fert)) {
    fileindex <- grep(
      paste0("^", crop_name, cft_nut, "_timeseries"),
      basename(fert_names[[fert_dir]]),
    )
    if (length(fileindex) != 1) {
      stop(
        paste("Unexpected error determining file for crop", sQuote(crop_name))
      )
    }
    fert_nc[[crop_name]] <- nc_open(fert_names[[fert_dir]][fileindex])
  }
}
if (process_manure && any(cft_bands_get_manure)) {
  # Check cropland dataset used for manure aggregation
  if (is.null(manure_weighting_name)) {
    # Use manure_cropland_name and corresponding variables from
    # fertilizer_setup.R
    manure_weighting_name <- ifelse(
      is.null(manure_cropland_name),
      NULL,
      ifelse(
        is.null(names(manure_cropland_name)) && length(manure_cropland_name) == 1,
        manure_cropland_name,
        ifelse(
          cft_nut %in% names(manure_cropland_name),
          manure_cropland_name[cft_nut],
          NULL
        )
      )
    )
    manure_weighting_varname <- ifelse(
      is.null(names(manure_cropland_varname)) &&
        length(manure_cropland_varname) == 1,
      manure_cropland_varname,
      manure_cropland_varname[cft_nut]
    )
    manure_weighting_unit <- ifelse(
      is.null(names(manure_cropland_unit)) && length(manure_cropland_unit) == 1,
      manure_cropland_unit,
      manure_cropland_unit[cft_nut]
    )
    manure_weighting_area_file <- ifelse(
      is.null(manure_cropland_area_file),
      NULL,
      ifelse(
        is.null(names(manure_cropland_area_file)) &&
          length(manure_cropland_area_file) == 1,
        manure_cropland_area_file,
        ifelse(
          nut %in% names(manure_cropland_area_file),
          manure_cropland_area_file[nut],
          NULL
        )
      )
    )
    manure_weighting_area_file_unit <- ifelse(
      is.null(names(manure_cropland_area_file_unit)) &&
        length(manure_cropland_area_file_unit) == 1,
      manure_cropland_area_file_unit,
      manure_cropland_area_file_unit[nut]
    )
    if (!is.null(manure_weighting_name)) {
      warning(
        "You have not set up manure_weighting_name in this script. ",
        "Using manure_cropland_name and corresponding parameters from",
        " fertilizer_setup.R instead.",
        call. = FALSE,
        immediate. = TRUE
      )
    }
  }
  manure_weighting_options <- NULL
  for (check in c(
    "manure_weighting_area_file",
    "manure_weighting_area_file_unit",
    "manure_weighting_name",
    "manure_weighting_unit",
    "manure_weighting_varname"
  )) {
    if (!is.null(names(get(check)))) {
      manure_weighting_options <- union(
        manure_weighting_options,
        names(get(check))
      )
    }
  }

  if (!is.null(manure_weighting_name)) {
    if (is.null(manure_weighting_options)) {
      # Add dummy option if no variable has named options
      manure_weighting_options <- "dummy"
    }
    # Check all available weighting options.
    manure_weighting_res_match <- character(0)
    for (manure_weighting_opt in manure_weighting_options) {
      filename <- ifelse(
        is.null(names(manure_weighting_name)),
        manure_weighting_name,
        manure_weighting_name[manure_weighting_opt]
      )
      if (is.na(filename) || !file.exists(filename)) {
        if (exists("fert_nc") && length(fert_nc) > 0)
          sapply(fert_nc, nc_close)
        if (exists("ha_weighting_nc") && length(ha_weighting_nc) > 0)
          sapply(ha_weighting_nc, nc_close)
        if (exists("pasture_weighting_nc") && length(pasture_weighting_nc) > 0)
          sapply(pasture_weighting_nc, nc_close)
        stop(
          paste0(
            "File manure_weighting_name[", sQuote(manure_weighting_opt), "] ",
            sQuote(manure_weighting_name[manure_weighting_opt]),
            " does not exist."
          )
        )
      }
      tmp_varname <- ifelse(
        is.null(names(manure_weighting_varname)),
        manure_weighting_varname,
        manure_weighting_varname[manure_weighting_opt]
      )
      if (is.na(tmp_varname)) {
        if (exists("fert_nc") && length(fert_nc) > 0)
          sapply(fert_nc, nc_close)
        if (exists("ha_weighting_nc") && length(ha_weighting_nc) > 0)
          sapply(ha_weighting_nc, nc_close)
        if (exists("pasture_weighting_nc") && length(pasture_weighting_nc) > 0)
          sapply(pasture_weighting_nc, nc_close)
        stop(
          paste0(
            "manure_weighting_varname[", sQuote(manure_weighting_opt), "] ",
            " does not exist."
          )
        )
      }
        
      manure_weighting_raster <- raster(
        filename,
        varname = tmp_varname,
        band = 1
      )
      # Crop to output spatial extent if source data has larger extent.
      manure_weighting_raster <- crop(manure_weighting_raster, cft_raster)
      # Compare with all available manure source datasets.
      for (manure_opt in manure_dir) {
        manure_raster <- raster(
          manure_names[[manure_opt]][1],
          band = 1,
          varname = paste0("manure_", cft_nut, "_rate")
        )
        cropland2manure <- res(manure_raster) / res(manure_weighting_raster)
        if (any(cropland2manure < 0.999)) {
          # Data resolution is too coarse for manure time series resolution.
          message(
            "Manure weighting time series data in ", sQuote(filename),
            " is too coarse for manure time series in ", sQuote(manure_opt)
          )
          rm(manure_raster)
          # Remove manure_opt as valid option because there is no compatible
          # cropland weighting dataset.
          manure_dir <- manure_dir[which(manure_dir != manure_opt)]
          manure_res[[manure_opt]] <- NULL
          manure_names[[manure_opt]] <- NULL
          # If there is more than one manure_weighting_options make sure
          # manure_weighting_res_match is valid for all.
          manure_weighting_res_match <- setdiff(
            manure_weighting_res_match,
            manure_opt
          )
          next
        }
        # Crop to output spatial extent if source data has larger extent.
        manure_raster <- crop(manure_raster, cft_raster)
        # Check alignment and whether resolution can be aggregated.
        manure_weighting_res_check <- try(
          match_admin_to_data(
            manure_raster,
            manure_weighting_raster,
            fun = sum,
            verbose = FALSE
          )
        )
        if (class(manure_weighting_res_check) == "try-error") {
          message(
            "Manure weighting time series data in ", sQuote(filename),
            " does not align with manure time series in ", sQuote(manure_opt)
          )
          rm(manure_raster, manure_weighting_res_check)
          # Remove manure_opt as valid option because there is no compatible
          # cropland dataset for weighting.
          manure_dir <- manure_dir[which(manure_dir != manure_opt)]
          manure_res[[manure_opt]] <- NULL
          manure_names[[manure_opt]] <- NULL
          # If there is more than one manure_weighting_options make sure
          # manure_weighting_res_match is valid for all.
          manure_weighting_res_match <- setdiff(
            manure_weighting_res_match,
            manure_opt
          )
          next
        }
        # Check if manure_weighting_raster covers full extent of manure_raster
        if (ncell(manure_weighting_res_check) != ncell(manure_raster)) {
          message(
            "Manure weighting time series data in ", sQuote(filename),
            " does not cover full extent of desired output grid"
          )
          # Remove manure_opt as valid option because there is no compatible
          # cropland dataset for weighting.
          manure_dir <- manure_dir[which(manure_dir != manure_opt)]
          manure_res[[manure_opt]] <- NULL
          manure_names[[manure_opt]] <- NULL
          rm(manure_raster, cropland_weighting_res_check)
          # If there is more than one manure_weighting_options make sure
          # manure_weighting_res_match is valid for all.
          manure_weighting_res_match <- setdiff(
            manure_weighting_res_match,
            manure_opt
          )
          next
        }        
        rm(manure_raster, manure_weighting_res_check)
        # List cropland time series as valid weighting option for manure_opt
        manure_weighting_res_match <- union(
          manure_weighting_res_match,
          manure_opt
        )
      }
    }
    if (length(manure_weighting_res_match) > 0) {
      # Check file years in pasture weighting file(s)
      for (filename in manure_weighting_name) {
        tmp_nc <- nc_open(filename)
        tmp_fileyears <- nc_file_years(tmp_nc)
        in_period <- which(
          tmp_fileyears >= min(cft_output_period) &
          tmp_fileyears <= max(cft_output_period)
        )
        if (length(in_period) != max(tmp_fileyears[in_period]) -
          min(tmp_fileyears[in_period]) + 1
        ) {
          warning(
            "There are gaps in manure weighting time series ",
            sQuote(filename),
            ". Missing years: ",
            toString(
              setdiff(
                seq(
                  min(tmp_fileyears[in_period]),
                  max(tmp_fileyears[in_period])
                ),
                tmp_fileyears
              )
            ),
            call. = FALSE,
            immediate. = TRUE
          )
        }
        if (length(in_period) != max(cft_output_period) -
          min(cft_output_period) + 1
        ) {
          warning(
            "Manure weighting time series ",
            sQuote(filename),
            " does not cover the full desired output period.",
            call. = FALSE,
            immediate. = TRUE
          )
        }
        # Check unit of pasture data. If necessary, test for compatible area
        # file.
        for (tmp_varname in manure_weighting_varname) {
          if (tmp_varname %in% names(tmp_nc$var)) {
            tmp_unit <- ncatt_get(tmp_nc, tmp_varname, "units")
            if (!tmp_unit$hasatt) {
              warning(
                "No unit attribute set in ", sQuote(filename),
                " for variable ", sQuote(tmp_varname),
                ". Make sure manure_weighting_unit ",
                sQuote(manure_weighting_unit),
                " is correct.",
                call. = FALSE,
                immediate. = TRUE
              )
              # Set to unit defined by user
              tmp_unit$value <- manure_weighting_unit
            }
            manure_weighting_is_fractional <- FALSE
            if (!ud.are.convertible(tmp_unit$value, "m2")) {
              # Manure weighting is not an absolute area.
              if (ud.are.convertible(tmp_unit$value, "1")) {
                manure_weighting_is_fractional <- TRUE
                if (is.null(manure_weighting_area_file) ||
                  !file.exists(manure_weighting_area_file)
                ) {
                  if (!is.null(maure_weighting_area_file)) {
                    warning(
                      "Defined manure_weighting_area_file ",
                      sQuote(filename),
                      " does not exist.",
                      call. = TRUE,
                      immediate. = TRUE
                    )
                  }
                  warning(
                    "Unit of manure weighting file ",
                    sQuote(filename),
                    " is fractional but no corresponding area is available.",
                    " Using internal calculation to derive cell area",
                    call. = FALSE,
                    immediate. = TRUE
                  )
                } else {
                  manure_area_raster <- raster(manure_weighting_area_file)
                  manure_area_raster <- crop(
                    manure_area_raster,
                    manure_weighting_raster
                  )
                  # Check alignment and whether resolution can be aggregated.
                  manure_area_res_check <- try(
                    match_admin_to_data(
                      manure_weighting_raster,
                      manure_area_raster,
                      fun = sum,
                      verbose = FALSE
                    )
                  )
                  if (class(manure_area_res_check) == "try-error") {
                    if (exists("fert_nc") && length(fert_nc) > 0)
                      sapply(fert_nc, nc_close)
                    if (exists("ha_weighting_nc") && length(ha_weighting_nc) > 0)
                      sapply(ha_weighting_nc, nc_close)
                    if (exists("pasture_weighting_nc") &&
                      length(pasture_weighting_nc) > 0
                    )
                      sapply(pasture_weighting_nc, nc_close)
                    stop(
                      paste(
                        "Manure weighting area",
                        sQuote(manure_weighting_area_file),
                        "does not align with manure weighting data.",
                        "Please provide compatible manure_weighting_area_file."
                      )
                    )
                  }
                  rm(manure_area_res_check, manure_area_raster)
                }
              } else {
                warning(
                  "Unit ", sQuote(tmp_unit$value), " for variable ",
                  sQuote(tmp_varname), " in file ", sQuote(filename),
                  " is neither fractional nor an absolute area.",
                  " This may lead to inaccuracies in case of weighted spatial",
                  " aggregation.",
                  call. = FALSE,
                  immediate. = TRUE
                )
              }
            }
          }
        }
        nc_close(tmp_nc)
      }
      cat(
        "Compatible time series", 
        toString(sQuote(manure_weighting_name)),
        "found as weighting dataset for manure time series in",
        toString(sQuote(fert_dir)), "\n"
      )
      rm(manure_weighting_raster)
      # Open NetCDF files for later use.
      manure_weighting_nc <- manure_weighting_years <- list()
      for (findex in seq_along(manure_weighting_name)) {
        if (is.null(names(manure_weighting_name))) {
          name <- findex
        } else {
          name <- names(manure_weighting_name)[findex]
        }
        manure_weighting_nc[[name]] <- nc_open(manure_weighting_name[name])
        manure_weighting_years[[name]] <-
          nc_file_years(manure_weighting_nc[[name]])
      }
    } else {
      if (exists("fert_nc") && length(fert_nc) > 0)
        sapply(fert_nc, nc_close)
      if (exists("ha_weighting_nc") && length(ha_weighting_nc) > 0)
        sapply(ha_weighting_nc, nc_close)
      if (exists("pasture_weighting_nc") && length(pasture_weighting_nc) > 0)
        sapply(pasture_weighting_nc, nc_close)
      stop(
        paste(
          "No compatible time series found to use as weighting",
          "dataset for fertilizer time series"
        )
      )
    }
  } else if (any(cft_bands_get_manure)) {
    if (exists("fert_nc") && length(fert_nc) > 0)
      sapply(fert_nc, nc_close)
    if (exists("ha_weighting_nc") && length(ha_weighting_nc) > 0)
      sapply(ha_weighting_nc, nc_close)
    if (exists("pasture_weighting_nc") && length(pasture_weighting_nc) > 0)
      sapply(pasture_weighting_nc, nc_close)
    stop(
      paste(
        "You have set no cropland weighting dataset to use for",
        "spatial aggregation of manure data."
      )
    )
  }
  # If there is more than one valid source dataset use the one with coarsest
  # resolution.
  if (length(manure_dir) > 1) {
    manure_dir <- names(which.max(lapply(manure_res, prod)))
    manure_res <- manure_res[[manure_dir]]
    manure_names <- manure_names[[manure_dir]]
    cat("Manure time series in", sQuote(manure_dir), "selected for use.\n")
  }
  # Open NetCDF files for later use.
  manure_nc <- manure_years <- list()
  i <- 1
  for (filename in manure_names[[manure_dir]]) {
    manure_nc[[i]] <- nc_open(filename)
    manure_years[[i]] <- nc_file_years(manure_nc[[i]])
    i <- i + 1
  }
}
################################################################################


################################################################################
## Set up generated files                                                     ##
cat("*** Set up files generated by this script ***\n")
cft_output_mass_unit <- regmatches(
    cft_output_unit,
    regexpr("^[a-zA-Z]+", cft_output_unit)
)
cft_output_area_unit <- ifelse(
  grepl("km-2|/[ ]?km2", cft_output_unit),
  "km2",
  ifelse(
    grepl("m-2|/[ ]?m2", cft_output_unit),
    "m2",
    ifelse(
      grepl("ha-1|/[ ]?ha", cft_output_unit),
      "ha",
      stop(
        paste(
          "Cannot detect area unit from",
          sQuote(cft_output_unit)
        )
      )
    )
  )
)
fert_output_name <- paste0(
  "fert_",
  ifelse(
    process_manure && combine_fertilizer_manure && any(cft_bands_get_manure),
    "manure_",
    ""
  ),
  cft_nut,
  ifelse(
    nchar(aggregation_name) > 0,
    paste0("_", aggregation_name, "_CFT_aggregation_"),
    "_"
  ),
  ifelse(nchar(version_string) > 0, paste0(version_string, "_"), ""),
  cft_res_string, "_",
  paste(cft_output_period, collapse = "-"),
  switch(cft_format, NetCDF = ".nc", CLM = ".clm", stop("Invalid cft_format"))
)
manure_output_name <- paste0(
  "manure_", cft_nut,
  ifelse(
    nchar(aggregation_name) > 0,
    paste0("_", aggregation_name, "_CFT_aggregation_"),
    "_"
  ),
  ifelse(nchar(version_string) > 0, paste0(version_string, "_"), ""),
  cft_res_string, "_",
  paste(cft_output_period, collapse = "-"),
  switch(cft_format, NetCDF = ".nc", CLM = ".clm", stop("Invalid cft_format"))
)
manure_noalloc_global_name <- paste0(
  "manure_noalloc_", cft_nut,
  ifelse(
    nchar(aggregation_name) > 0,
    paste0("_", aggregation_name, "_CFT_aggregation_"),
    "_"
  ),
  ifelse(nchar(version_string) > 0, paste0(version_string, "_"), ""),
  cft_res_string, "_",
  paste(cft_output_period, collapse = "-"),
  ".csv"
)
if (cft_format == "CLM") {
  # Manure not allocated and fertilizer not allocated are included in
  # fert_output_name or manure_output_name in case of NetCDF format.
  manure_noalloc_name <- paste0(
    "manure_noalloc_", cft_nut,
    ifelse(
      nchar(aggregation_name) > 0,
      paste0("_", aggregation_name, "_CFT_aggregation_"),
      "_"
    ),
    ifelse(nchar(version_string) > 0, paste0(version_string, "_"), ""),
    cft_res_string, "_",
    paste(cft_output_period, collapse = "-"),
    switch(cft_format, NetCDF = ".nc", CLM = ".clm", stop("Invalid cft_format"))
  )
  fert_noalloc_name <- paste0(
    "fert_noalloc_", cft_nut,
    ifelse(
      nchar(aggregation_name) > 0,
      paste0("_", aggregation_name, "_CFT_aggregation_"),
      "_"
    ),
    ifelse(nchar(version_string) > 0, paste0(version_string, "_"), ""),
    cft_res_string, "_",
    paste(cft_output_period, collapse = "-"),
    switch(cft_format, NetCDF = ".nc", CLM = ".clm", stop("Invalid cft_format"))
  )
}
if (cft_format == "NetCDF") {
  # Set up dimensions and variables
  lon_dim <- ncdim_def(
    name = "longitude",
    units = "degrees_east",
    vals = xFromCol(cft_raster),
    longname = "Longitude"
  )
  lat_dim <- ncdim_def(
    name = "latitude",
    units = "degrees_north",
    vals = yFromRow(cft_raster),
    longname = "Latitude"
  )
  # CFT dimension. Note: default name is chosen to be compatible with LPJmL.
  cft_dim <- ncdim_def(
    name = "pft",
    units = "",
    vals = seq_along(cft_bands),
    create_dimvar = FALSE
  )
  time_dim <- ncdim_def(
    name = "time",
    units = "year",
    vals = seq(min(cft_output_period), max(cft_output_period)),
    unlim = TRUE
  )
  len_dim <- ncdim_def(
    name = "len",
    units = "",
    vals = seq_len(max(nchar(cft_bands))),
    create_dimvar = FALSE
  )
  name_var <- ncvar_def(
    name = "NamePFT",
    units = "",
    dim = list(len_dim, cft_dim),
    longname = "CFT name",
    prec = "char"
  )
  if (process_fertilizer ||
    (process_manure && combine_fertilizer_manure && any(cft_bands_get_manure))
  ) {
    included <- character(0)
    if (process_fertilizer)
      included <- c(included, "Fertilizer")
    if (process_manure && combine_fertilizer_manure && any(cft_bands_get_manure))
      included <- c(included, "Manure")
    fert_output_var <- ncvar_def(
      name = ifelse(process_fertilizer, "fert", "manu"),
      units = cft_output_unit,
      dim = list(lon_dim, lat_dim, cft_dim, time_dim),
      missval = missval_float,
      longname = paste0(
        paste(included, collapse = " & "),
        " ", cft_nut, " application rate",
        ifelse(
          "manure" %in% included & manure_availability_scalar != 1,
          paste0(
            " (assuming manure_availability_scalar of ",
            manure_availability_scalar,
            ")"
          ),
          ""
        )
      ),
      compression = 5
    )
  }
  if (process_fertilizer && is.finite(fert_threshold) && fert_noalloc_account) {
    fert_noalloc_var <- ncvar_def(
      name = "fert_noalloc",
      units = cft_output_unit,
      dim = list(lon_dim, lat_dim, cft_dim, time_dim),
      missval = missval_float,
      longname = paste("Fertilizer", cft_nut, "rate not allocated"),
      compression = 5
    )
  }
  if (process_manure && !combine_fertilizer_manure) {
    manure_output_var <- ncvar_def(
      name = "manu",
      units = cft_output_unit,
      dim = list(lon_dim, lat_dim, cft_dim, time_dim),
      missval = missval_float,
      longname = paste("Manure", cft_nut, "application rate"),
      compression = 5
    )
  }
  if (process_manure && manure_noalloc_account &&
    (is.finite(manure_apply_threshold) ||
    (!tmp_is_rate || (!is.null(tmp_ref_area) && tmp_ref_area == "grid")))
  ) {
    # Additional variable collecting manure not allocated either due to scaling
    # or due to exceeding a maximum application rate.
    manure_noalloc_var <- ncvar_def(
      name = "manure_noalloc",
      units = cft_output_mass_unit,
      dim = list(lon_dim, lat_dim, time_dim),
      missval = missval_float,
      longname = paste("Manure", cft_nut, "amount not allocated"),
      compression = 5
    )
    manure_noalloc_global <- array(
      0,
      dim = c(time_dim$len, 3),
      dimnames = list(time_dim$vals, c("preprocessing", "threshold", "applied"))
    )
  }
  if (exists("manure_output_var")) {
    # Manure goes to separate file
    if (exists("manure_noalloc_var")) {
      # Include manure application rate and manure not allocated.
      varlist <- list(manure_output_var, manure_noalloc_var, name_var)
      cat(
        "Manure application rate and manure not allocated saved to",
        manure_output_name, "\n"
      )
      if (is.finite(manure_apply_threshold) &&
        manure_apply_threshold_res == "target"
      ) {
        cat(
          "Applying upper application threshold of",
          ud.convert(
            manure_apply_threshold,
            manure_apply_threshold_unit,
            cft_output_unit
          ),
          cft_output_unit, "to manure.\n"
        )
      }
    } else {
      # Include only manure application rate.
      varlist <- list(manure_output_var, name_var)
      cat(
        "Manure application rate saved to",
        manure_output_name, "\n"
      )
    }
    if (file.exists(manure_output_name)) {
      stop(
        paste(
          "Manure file", sQuote(manure_output_name), "exists already.",
          "Please delete or rename existing file to create it again."
        )
      )
    }
    manure_output_nc <- nc_create(
      filename = manure_output_name,
      vars = varlist
    )
    # Write CFT names to file.
    ncvar_put(
      nc = manure_output_nc,
      varid = name_var$name,
      vals = cft_bands
    )
    for (tmp_var in varlist) {
      if (tmp_var$name != name_var$name) {
        # ncvar_def only sets "_FillValue" attribute. Also set "missing_value"
        # attribute
        if (!ncatt_get(manure_output_nc, tmp_var$name, "missing_value")$hasatt) {
          ncatt_put(
            nc = manure_output_nc,
            varid = tmp_var$name,
            attname = "missing_value",
            attval = tmp_var$missval,
            prec = "float"
          )
        }
      }
    }
    nc_sync(manure_output_nc)
  }
  if (exists("fert_output_var")) {
    varlist <- list(fert_output_var)
    varstring <- "Fertilizer application rate"
    if (exists("fert_noalloc_var")) {
      varlist <- c(varlist, list(fert_noalloc_var))
      varstring <- paste(varstring, "and fertilizer not allocated")
    }
    if (exists("manure_noalloc_var") && !exists("manure_output_var")) {
      # Include fertilizer and manure not allocated (because manure is included
      # in fertilizer).
      varlist <- c(varlist, list(manure_noalloc_var))
      varstring <- paste(varstring, "and manure not allocated")
    }
    varlist <- c(varlist, list(name_var))
    cat(varstring, "saved to", fert_output_name, "\n")
    if (is.finite(fert_threshold)) {
      cat(
        "Applying upper application threshold of",
        fert_threshold, cft_output_unit,
        "to fertilizer.\n"
      )
    }
    if (grepl("manure not allocated", varstring) &&
      is.finite(manure_apply_threshold) &&
      manure_apply_threshold_res == "target"
    ) {
      cat(
        "Applying upper application threshold of",
        ud.convert(
          manure_apply_threshold,
          manure_apply_threshold_unit,
          cft_output_unit
        ),
        cft_output_unit, "to manure.\n"
      )
    }
    if (process_manure && combine_fertilizer_manure) {
      cat(
        "Manure is combined with fertilizer application rate assuming",
        ifelse(
          manure_availability_scalar > 1,
          "higher", # Does not really make sense.
          ifelse(manure_availability_scalar < 1, "lower", "full")
        ),
        "plant availability with manure_availability_scalar",
        manure_availability_scalar, "\n"
      )
    }
    if (file.exists(fert_output_name)) {
      stop(
        paste(
          "Fertilizer file", sQuote(fert_output_name), "exists already.",
          "Please delete or rename existing file to create it again."
        )
      )
    }
    fert_output_nc <- nc_create(
      filename = fert_output_name,
      vars = varlist
    )
    # Write CFT names to file.
    ncvar_put(
      nc = fert_output_nc,
      varid = name_var$name,
      vals = cft_bands
    )
    for (tmp_var in varlist) {
      if (tmp_var$name != name_var$name) {
        # ncvar_def only sets "_FillValue" attribute. Also set "missing_value"
        # attribute
        if (!ncatt_get(fert_output_nc, tmp_var$name, "missing_value")$hasatt) {
          ncatt_put(
            nc = fert_output_nc,
            varid = tmp_var$name,
            attname = "missing_value",
            attval = tmp_var$missval,
            prec = "float"
          )
        }
      }
    }
    nc_sync(fert_output_nc)
  }
} else if (cft_format == "CLM") {
  if (process_fertilizer ||
    (process_manure && combine_fertilizer_manure && any(cft_bands))
  ) {
    if (file.exists(fert_output_name)) {
      stop(
        paste(
          "Fertilizer file", sQuote(fert_output_name), "exists already.",
          "Please delete or rename existing file to create it again."
        )
      )
    }
    cat(
      "Fertilizer ",
      ifelse(process_manure & combine_fertilizer_manure, "and manure ", ""),
      "application rate [", cft_output_unit, "] saved to ",
      sQuote(fert_output_name), "\n",
      sep = ""
    )
    fert_output_header <- create_header(
      name = "LPJFERT",
      version = 3,
      firstyear = min(cft_output_period),
      nyear = max(cft_output_period) - min(cft_output_period) + 1,
      ncell = cft_gridheader$header["ncell"],
      nbands = length(cft_bands),
      cellsize_lon = cft_gridheader$header["cellsize_lon"],
      scalar = 1.0,
      cellsize_lat = cft_gridheader$header["cellsize_lat"],
      datatype = 3
    )
    write_header(fert_output_name, fert_output_header)
    fert_output_fp <- file(fert_output_name, "ab")
    
    if (process_fertilizer && is.finite(fert_threshold)) {
      cat(
        "Applying upper application threshold of",
        fert_threshold, cft_output_unit,
        "to fertilizer.\n"
      )
      if (fert_noalloc_account) {
        if (file.exists(fert_noalloc_name)) {
          stop(
            paste(
              "File containing fertilizer not allocated",
              sQuote(fert_output_name), "exists already.",
              "Please delete or rename existing file to create it again."
            )
          )
        }
        cat(
          "Fertilizer not allocated [", cft_output_unit, "] saved to ",
          sQuote(fert_noalloc_name), "\n",
          sep = ""
        )
        fert_noalloc_header <- create_header(
          name = "LPJFERT",
          version = 3,
          firstyear = min(cft_output_period),
          nyear = max(cft_output_period) - min(cft_output_period) + 1,
          ncell = cft_gridheader$header["ncell"],
          nbands = length(cft_bands),
          cellsize_lon = cft_gridheader$header["cellsize_lon"],
          scalar = 1.0,
          cellsize_lat = cft_gridheader$header["cellsize_lat"],
          datatype = 3
        )
        write_header(fert_noalloc_name, fert_noalloc_header)
        fert_noalloc_fp <- file(fert_noalloc_name, "ab")
      }
    }
  }
  if (process_manure) {
    if (!combine_fertilizer_manure) {
      if (file.exists(manure_output_name)) {
        stop(
          paste(
            "Manure file", sQuote(manure_output_name), "exists already.",
            "Please delete or rename existing file to create it again."
          )
        )
      }
      cat(
        "Manure application rate [", cft_output_unit, "] saved to ",
        sQuote(manure_output_name), "\n",
        sep = ""
      )
      if (is.finite(manure_apply_threshold) &&
        manure_apply_threshold_res == "target"
      ) {
        cat(
          "Applying upper application threshold of",
          ud.convert(
            manure_apply_threshold,
            manure_apply_threshold_unit,
            cft_output_unit
          ),
          cft_output_unit, "to manure.\n"
        )
      }
      manure_output_header <- create_header(
        name = "LPJMANU",
        version = 3,
        firstyear = min(cft_output_period),
        nyear = max(cft_output_period) - min(cft_output_period) + 1,
        ncell = cft_gridheader$header["ncell"],
        nbands = length(cft_bands),
        cellsize_lon = cft_gridheader$header["cellsize_lon"],
        scalar = 1.0,
        cellsize_lat = cft_gridheader$header["cellsize_lat"],
        datatype = 3
      )
      write_header(manure_output_name, manure_output_header)
      manure_output_fp <- file(manure_output_name, "ab")
    } else {
      cat(
        "Manure is combined with fertilizer application rates assuming",
        ifelse(
          manure_availability_scalar > 1,
          "higher", # Does not really make sense.
          ifelse(manure_availability_scalar < 1, "lower", "full")
        ),
        "plant availability with manure_availability_scalar",
        manure_availability_scalar, "\n"
      )
    }
      
    if (is.finite(manure_apply_threshold) ||
      (!tmp_is_rate || (!is.null(tmp_ref_area) && tmp_ref_area == "grid"))
    ) {
      if (file.exists(manure_noalloc_name)) {
        stop(
          paste(
            "File containing manure not allocated",
            sQuote(manure_noalloc_name), "exists already.",
            "Please delete or rename existing file to create it again."
          )
        )
      }
      cat(
        "Manure not allocated [", cft_output_mass_unit, "] saved to ",
        sQuote(manure_noalloc_name), "\n",
        sep = ""
      )
      manure_noalloc_header <- create_header(
        name = "LPJMANU",
        version = 3,
        firstyear = min(cft_output_period),
        nyear = max(cft_output_period) - min(cft_output_period) + 1,
        ncell = cft_gridheader$header["ncell"],
        nbands = 1,
        cellsize_lon = cft_gridheader$header["cellsize_lon"],
        scalar = 1.0,
        cellsize_lat = cft_gridheader$header["cellsize_lat"],
        datatype = 3
      )
      write_header(manure_noalloc_name, manure_noalloc_header)
      manure_noalloc_fp <- file(manure_noalloc_name, "ab")
    }
    manure_noalloc_global <- array(
      0,
      dim = c(max(cft_output_period) - min(cft_output_period) + 1, 3),
      dimnames = list(
        seq(min(cft_output_period), max(cft_output_period)),
        c("preprocessing", "threshold", "applied")
      )
    )
  }
}
################################################################################


################################################################################
## Process years                                                              ##
#stop("Before year loop")
cat("*** Processing time series ***\n")
for (year in seq(min(cft_output_period), max(cft_output_period))) {
  cat("***", year, "***\n")
  if (process_fertilizer) {
    # Array collecting CFT fertilizer data for one year. Set all cells (incl.
    # oceans) to zero to avoid problem with different land-sea masks in source
    # datasets.
    fert_output_yeardata <- array(
      0,
      dim = c(ncol(cft_raster), nrow(cft_raster), length(cft_bands)),
      dimnames = list(NULL, NULL, cft_bands)
    )
    fert_year_missing_src <- fert_year_missing_weight <- FALSE
    for (cft in cft_bands) {
      cft_weight_sum <- array(0, dim = c(ncol(cft_raster), nrow(cft_raster)))
      src_r <- which(fert_weighting_table$cft_band == cft &
        !is.na(fert_weighting_table$weighting)
      )
      for (src in src_r) {
        # Check if year is covered by src data
        tmp_nc <- fert_nc[[fert_weighting_table$fert[src]]]
        tmp_unit <- ncatt_get(
          tmp_nc,
          paste0(fert_weighting_table$fert[src], cft_nut, "_timeseries"),
          "units"
        )
        if (!tmp_unit$hasatt) {
          # Use fertilizer_pattern_unit defined in fertilizer_setup.R if NetCDF
          # does not have unit attribute.
          tmp_unit$value <- fertilizer_pattern_unit
        }
        src_years <- nc_file_years(tmp_nc)
        if (!year %in% src_years) {
          if (!fert_year_missing_src) {
            message(
              "Year ", year, " is missing in fertilizer source data.",
              ifelse(
                extend_source_period == "zero",
                " Setting fertilizer application rate to 0.",
                " Using closest year available in source."
              )
            )
            # Show message only once, not for each crop (assuming that all crops
            # cover the same period)
            fert_year_missing_src <- TRUE
          }
          load_year <- switch(
            extend_source_period,
            zero = NA,
            replicate = src_years[which.min(abs(src_years - year))]
          )
        } else {
          load_year <- year
        }
        if (is.finite(load_year)) {
          filedata <- ncvar_get(
            tmp_nc,
            paste0(fert_weighting_table$fert[src], cft_nut, "_timeseries"),
            start = c(1, 1, which(src_years == load_year)),
            count = c(-1, -1, 1)
          )
          tmp_flip <- (tmp_nc$dim$lat$vals[1] < tmp_nc$dim$lat$vals[2]) !=
            (yFromRow(cft_raster, 1) < yFromRow(cft_raster, 2))
          if (tmp_flip) {
            filedata <- filedata[, seq(tmp_nc$dim$lat$len, 1)]
          }
          # Convert to output unit
          filedata <- ud.convert(filedata, tmp_unit$value, cft_output_unit)
        } else {
          filedata <- array(0, dim = c(tmp_nc$dim$lon$len, tmp_nc$dim$lat$len))
          tmp_flip <- FALSE
        }
        # Crop to spatial extent of output raster
        lon_index <- which(tmp_nc$dim$lon$vals > xmin(cft_raster) &
          tmp_nc$dim$lon$vals < xmax(cft_raster)
        )
        if (tmp_flip) {
          lat_index <- which(rev(tmp_nc$dim$lat$vals) > ymin(cft_raster) &
            rev(tmp_nc$dim$lat$vals) < ymax(cft_raster)
          )
        } else {
          lat_index <- which(tmp_nc$dim$lat$vals > ymin(cft_raster) &
            tmp_nc$dim$lat$vals < ymax(cft_raster)
          )
        }
        filedata <- filedata[lon_index, lat_index, drop = FALSE]
        rm(lon_index, lat_index)
        # Rainfed or irrigated status of current cft
        tmp_irr <- unlist(regmatches(cft, regexec("rainfed|irrigated", cft)))
        # Weighting
        if (!any(filedata > 0, na.rm = TRUE)) {
          # No need to do any weighting, jump to next src
          next
        }
        if (cft %in% cft_bands[ha_weighting_bands]) {
          # Find which NetCDF file covers year
          findex <- max(which(names(ha_weighting_nc) <= year))
          if (length(findex) == 0) {
            # Year is before harvested area time series, use first file
            findex <- 1
          }
          tmp_nc <- ha_weighting_nc[[findex]]
          tmp_varname <- ifelse(
            is.null(names(ha_weighting_varname)),
            ha_weighting_varname,
            ha_weighting_varname[tmp_irr]
          )
          src_years <- nc_file_years(tmp_nc)
          if (!year %in% src_years) {
            if (!fert_year_missing_weight) {
              message(
                "Year ", year, " is missing in harvested area data.",
                " Using closest year available in source."
              )
              # Show message only once, not for each crop (assuming that all crops
              # cover the same period)
              fert_year_missing_weight <- TRUE
            }
            load_year <- src_years[which.min(abs(src_years - year))]
          } else {
            load_year <- year
          }
          if (mapping_irr_spec) {
            crop_index <- which(ha_weighting_crop_names ==
              fert_weighting_table$weighting[src]
            )
          } else {
            crop_index <- which(ha_weighting_crop_names == sub(
              "rainfed |irrigated ", "", fert_weighting_table$weighting[src]
            ))
          }
          if (length(crop_index) != 1) {
            # Should normally work. Stop if not.
            stop("Unexpected error finding crop_index")
          }
          tmp_unit <- ncatt_get(tmp_nc, tmp_varname, "units")
          if (!tmp_unit$hasatt) {
            # Assume here that default unit for harvested area time series is ha
            tmp_unit$value <- "ha"
          }
          if (exists("weight_unit")) {
            if (!ud.are.convertible(weight_unit, tmp_unit$value) ||
              ud.convert(1, weight_unit, tmp_unit$value) != 1
            ) {
              # weightdata for different src datasets has different units which
              # probably causes errors in weighted aggregation.
              stop(
                paste0(
                  "Unit of weightdata for ",
                  fert_weighting_table$weighting[src],
                  " (", tmp_unit$value, ") differs from unit of other ",
                  "weightdata (", weight_unit, "). Please ensure that all ",
                  "weightdata has same unit for correct weighted aggregation."
                )
              )
            }
          } else {
            weight_unit <- tmp_unit$value
          }
          weightdata <- ncvar_get(
            tmp_nc,
            tmp_varname,
            start = c(1, 1, crop_index, which(src_years == load_year)),
            count = c(-1, -1, 1, 1)
          )
          tmp_flip <- (tmp_nc$dim$lat$vals[1] < tmp_nc$dim$lat$vals[2]) !=
            (yFromRow(cft_raster, 1) < yFromRow(cft_raster, 2))
          if (tmp_flip) {
            weightdata <- weightdata[, seq(tmp_nc$dim$lat$len, 1)]
          }
          # Convert weight_unit to cft_output_area_unit if they are convertible
          if (ud.are.convertible(weight_unit, cft_output_area_unit)) {
            weightdata <- ud.convert(
              weightdata,
              weight_unit,
              cft_output_area_unit
            )
          }
        } else if (cft %in% cft_bands[pasture_weighting_bands]) {
          if (!is.null(pasture_weighting_name)) {
            if (is.null(names(pasture_weighting_nc))) {
              tmp_nc <- pasture_weighting_nc[[1]]
            } else {
              tmp_nc <- pasture_weighting_nc[[tmp_irr]]
            }
            tmp_varname <- ifelse(
              is.null(names(pasture_weighting_varname)),
              pasture_weighting_varname,
              pasture_weighting_varname[tmp_irr]
            )
            if (!is.na(tmp_varname) && tmp_varname %in% names(tmp_nc$var)) {
              src_years <- nc_file_years(tmp_nc)
              if (!year %in% src_years) {
                if (!fert_year_missing_weight) {
                  message(
                    "Year ", year, " is missing in pasture weighting",
                    " data. Using closest year available in source."
                  )
                }
                fert_year_missing_weight <- TRUE
                load_year <- src_years[which.min(abs(src_years - year))]
              } else {
                load_year <- year
              }
              weightdata <- ncvar_get(
                tmp_nc,
                tmp_varname,
                start = c(1, 1, which(src_years == load_year)),
                count = c(-1, -1, 1)
              )
              tmp_flip <- (tmp_nc$dim$lat$vals[1] < tmp_nc$dim$lat$vals[2]) !=
                (yFromRow(cft_raster, 1) < yFromRow(cft_raster, 2))
              if (tmp_flip) {
                weightdata <- weightdata[, seq(tmp_nc$dim$lat$len, 1)]
              }
              # Check if unit conversion is necessary
              tmp_unit <- ncatt_get(tmp_nc, tmp_varname, "units")
              if (!tmp_unit$hasatt) {
                tmp_unit$value <- pasture_weighting_unit
              }
              if (ud.are.convertible(tmp_unit$value, "1") ) {
                # weightdata is fractional. Load area
                if (!exists("pasture_weighting_area")) {
                  # Only load once, do not reload every year or for every
                  # pasture_weighting_nc. This requires that
                  # pasture_weighting_area is the same for all
                  # pasture_weighting_nc. If they do differ, change code to 
                  # reload pasture_weighting_area or save several versions of
                  # the variable.
                  tmp_x <- abs(tmp_nc$dim$lon$vals[1] - tmp_nc$dim$lon$vals[2])
                  tmp_y <- abs(tmp_nc$dim$lat$vals[1] - tmp_nc$dim$lat$vals[2])
                  pasture_weighting_extent <- extent(
                    min(tmp_nc$dim$lon$vals) - tmp_x / 2,
                    max(tmp_nc$dim$lon$vals) + tmp_x / 2,
                    min(tmp_nc$dim$lat$vals) - tmp_y / 2,
                    max(tmp_nc$dim$lat$vals) + tmp_x / 2
                  )
                  tmp_raster <- raster(
                    pasture_weighting_extent,
                    resolution = c(tmp_x, tmp_y)
                  )
                  pasture_weighting_area <- load_hyde_area(
                    filename = pasture_weighting_area_file,
                    fileunits = pasture_weighting_area_file_unit,
                    return_units = cft_output_area_unit,
                    return_raster = tmp_raster,
                    gextent = pasture_weighting_extent
                  )
                  pasture_weighting_area <- pasture_weighting_area$area
                  # Crop area to spatial extent
                  pasture_weighting_area <- crop(
                    pasture_weighting_area,
                    pasture_weighting_extent
                  )
                  rm (tmp_raster, pasture_weighting_extent, tmp_x, tmp_y)
                }
                if (ncell(pasture_weighting_area) != length(weightdata)) {
                  # Spatial resolution and extent should match at this point.
                  stop("Unexpected mismatch between weightdata and area data")
                }
                # Convert fractional unit into absolute unit
                weightdata <- ud.convert(weightdata, tmp_unit$value, "1") *
                  values(pasture_weighting_area)
                # Reset unit of weightdata
                tmp_unit$value <- cft_output_area_unit
              }
              if (exists("weight_unit")) {
                if (!ud.are.convertible(weight_unit, tmp_unit$value) ||
                  ud.convert(1, weight_unit, tmp_unit$value) != 1
                ) {
                  # weightdata for different src datasets has different units
                  # which probably causes errors in weighted aggregation.
                  stop(
                    paste0(
                      "Unit of weightdata for ",
                      fert_weighting_table$weighting[src],
                      " (", tmp_unit$value, ") differs from unit of other ",
                      "weightdata (", weight_unit, "). Please ensure that all ",
                      "weightdata has same unit for correct weighted aggregation."
                    )
                  )
                }
              } else {
                weight_unit <- tmp_unit$value
              }
            } else {
              # User selected weighting, but no weights available. Use zero.
              if (!is.na(tmp_varname)) {
                # User provided variable name for weight but it is not available
                # in file.
                warning(
                  "Provided pasture_weighting_varname ",
                  sQuote(tmp_varname), " is not available in file ",
                  tmp_nc$filename, ". Setting weights to zero.",
                  call. = FALSE,
                  immediate. = TRUE
                )
              }
              weightdata <- array(0, dim = dim(filedata))
            }
                
          } else {
            # Do not use weighted aggregation
            weightdata <- array(1, dim = dim(filedata))
          }
        } else {
          # Fertilizer band with no corresponding weighting. Should not happen.
          stop(
            paste0(
              "No fertilizer weighting dataset set up for cft ", sQuote(cft),
              ". Make sure that all cft_bands that are supposed to receive ",
              "fertilizer are either included in ha_weighting_bands or ",
              "pasture_weighting_bands. Or set up a new weighting dataset."
            )
          )
        }
        if (any(dim(weightdata) != dim(filedata))) {
          # Crop to spatial extent of output raster
          lon_index <- which(tmp_nc$dim$lon$vals > xmin(cft_raster) &
          tmp_nc$dim$lon$vals < xmax(cft_raster)
          )
          if (tmp_flip) {
            lat_index <- which(rev(tmp_nc$dim$lat$vals) > ymin(cft_raster) &
            rev(tmp_nc$dim$lat$vals) < ymax(cft_raster)
            )
          } else {
            lat_index <- which(tmp_nc$dim$lat$vals > ymin(cft_raster) &
            tmp_nc$dim$lat$vals < ymax(cft_raster)
            )
          }
          weightdata <- weightdata[lon_index, lat_index, drop = FALSE]
          rm(lon_index, lat_index)
          # Compare resolution, aggregate weightdata if necessary
          weight2data <- round(dim(weightdata) / dim(filedata), 4)
          if (any(weight2data > 1)) {
            tmp_sum <- sum(weightdata, na.rm = TRUE)
            weightdata <- aggregate_array(weightdata, weight2data, "sum", FALSE)
            # Confirm that aggregation has not changed global sum.
            if (abs(sum(weightdata, na.rm = TRUE) / tmp_sum - 1) > 1e-14) {
              stop(
                paste(
                  "Error aggregating weightdata for",
                  fert_weighting_table$weighting[src]
                )
              )
            }
            rm(tmp_sum)
          }
        }
        if (length(weightdata) != length(filedata)) {
          # At this point, weightdata should be harmonized with filedata in
          # terms of resolution and spatial extent. Stop if not.
          stop(
            paste(
              "Unexpected mismatch between filedata and weightdata for",
              "fertilizer", fert_weighting_table$fert[src]
            )
          )
        }
        # Set missing values to zero in weightdata
        weightdata <- pmax(weightdata, 0, na.rm = TRUE)
        # Set weightdata to 0 in all cells where filedata is missing
        weightdata[which(is.na(filedata))] <- 0
        # Set missing values in filedata to zero
        filedata <- pmax(filedata, 0, na.rm = TRUE)
        # Aggregate data to output resolution if necessary
        file2output <- round(dim(filedata) / dim(cft_raster)[c(2, 1)], 4)
        if (any(file2output > 1)) {
          tmp_sum <- sum(filedata * weightdata)
          tmp_sum2 <- sum(weightdata)
          # Aggregate to output resolution
          filedata <- aggregate_array(
            filedata * weightdata,
            file2output,
            "sum",
            FALSE
          )
          weightdata <- aggregate_array(weightdata, file2output, "sum", FALSE)
          if (abs(sum(filedata) / tmp_sum - 1) > 1e-14) {
            stop(
              paste(
                "Error aggregating source data for",
                fert_weighting_table$fert[src],
                "to output resolution."
              )
            )
          }
          if (abs(sum(weightdata) / tmp_sum2 - 1) > 1e-14) {
            stop(
              paste(
                "Error aggregating weightdata for",
                fert_weighting_table$weighting[src]
              )
            )
          }
          rm(tmp_sum, tmp_sum2)
          # Add data to fert_output_yeardata
          fert_output_yeardata[, , cft] <- fert_output_yeardata[, , cft] +
            filedata
          # Add weightdata to weight sum
          cft_weight_sum <- cft_weight_sum + weightdata
        } else {
          # Add data to fert_output_yeardata
          fert_output_yeardata[, , cft] <- fert_output_yeardata[, , cft] +
            filedata * weightdata
          # Add weightdata to weight sum
          cft_weight_sum <- cft_weight_sum + weightdata
        }
        if (anyNA(cft_weight_sum) || anyNA(fert_output_yeardata[, , cft])) {
          stop(
            paste(
              "Unexpected missing values while calculating crop",
              fert_weighting_table$weighting[src]
            )
          )
        }
        rm(filedata, weightdata)
      } # end source loop for current cft
      # Divide fertilizer data by weight sum to finalize weighted aggregation.
      tmp_value <- fert_output_yeardata[, , cft] / cft_weight_sum
      no_sum <- which(cft_weight_sum == 0)
      tmp_value[no_sum] <- 0
      fert_output_yeardata[, , cft] <- tmp_value
      rm(no_sum, tmp_value)
      # Delete weight_unit to ensure only source data contributing to the
      # respective cft is checked.
      if (exists("weight_unit"))
        rm(weight_unit)
      rm(cft_weight_sum)
    } # end cft loop
    # Apply maximum application threshold (if requested by user)
    if (is.finite(fert_threshold)) {
      if (fert_noalloc_account) {
        fert_noalloc_yeardata <- pmax(fert_output_yeardata - fert_threshold, 0)
        gc(full = FALSE)
      }
      fert_output_yeardata <- pmin(fert_output_yeardata, fert_threshold)
      gc(full = FALSE)
    }
  }
  if (process_manure) {
    # Array collecting CFT fertilizer data for one year. Set all cells (incl.
    # oceans) to zero to avoid problem with different land-sea masks in source
    # datasets.
    manure_output_yeardata <- array(
      0,
      dim = c(ncol(cft_raster), nrow(cft_raster), length(cft_bands)),
      dimnames = list(NULL, NULL, cft_bands)
    )
    if (manure_noalloc_account && (is.finite(manure_apply_threshold) ||
      (!tmp_is_rate || (!is.null(tmp_ref_area) && tmp_ref_area == "grid")))
    ) {
      manure_noalloc_yeardata <- array(
        0,
        dim = c(ncol(cft_raster), nrow(cft_raster))
      )
    }
    manure_year_missing_src <- manure_year_missing_weight <- FALSE
    # Find index of file to use. Selects file with closest year match
    findex <- which.min(
      sapply(
        manure_years,
        function(indata, year) min(abs(indata - year)),
        year = year
      )
    )
    tmp_nc <- manure_nc[[findex]]
    src_years <- manure_years[[findex]]
    if (!year %in% src_years) {
      if (!manure_year_missing_src) {
        message(
          "Year ", year, " is missing in manure source data. ",
          ifelse(
            extend_source_period == "zero",
            "Setting manure application rate to 0.",
            "Using closest year available in source."
          )
        )
        # Show message only once
        manure_year_missing_src <- TRUE
      }
      load_year <- switch(
        extend_source_period,
        zero = NA,
        replicate = src_years[which.min(abs(src_years - year))]
      )
    } else {
      load_year <- year
    }
    if (is.finite(load_year) && any(cft_bands_get_manure)) {
      tmp_unit <- ncatt_get(tmp_nc, paste0("manure_", cft_nut, "_rate"), "units")
      filedata <- ncvar_get(
        tmp_nc,
        paste0("manure_", cft_nut, "_rate"),
        start = c(1, 1, which(src_years == load_year)),
        count = c(-1, -1, 1)
      )
      tmp_flip <- (tmp_nc$dim$lat$vals[1] < tmp_nc$dim$lat$vals[2]) !=
        (yFromRow(cft_raster, 1) < yFromRow(cft_raster, 2))
      if (tmp_flip) {
        filedata <- filedata[, seq(tmp_nc$dim$lat$len, 1)]
      }
      # Convert to output unit
      filedata <- ud.convert(filedata, tmp_unit$value, cft_output_unit)
      
      # Manure not allocated
      if (exists("manure_noalloc_yeardata")) {
        tmp_varname <- paste0("manure_", cft_nut, "_noalloc")
        # Only look in same NetCDF file as manure application rate and assume
        # same variable dimensions.
        if (tmp_varname %in% names(tmp_nc$var)) {
          tmp_unit <- ncatt_get(tmp_nc, tmp_varname, "units")
          if (!tmp_unit$hasatt) {
            # Assume mass component of default manure_rate_unit
            tmp_unit$value <- manure_apply_threshold_mass_unit
          }
          filedata_noalloc <- ncvar_get(
            tmp_nc,
            tmp_varname,
            start = c(1, 1, which(src_years == load_year)),
            count = c(-1, -1, 1)
          )
          if (tmp_flip) {
            filedata_noalloc <- filedata_noalloc[, seq(tmp_nc$dim$lat$len, 1)]
          }
          # Convert to output unit
          filedata_noalloc <- ud.convert(
            filedata_noalloc,
            tmp_unit$value,
            cft_output_mass_unit
          )
        } else {
          filedata_noalloc <- array(
            0,
            dim = c(tmp_nc$dim$lon$len, tmp_nc$dim$lat$len)
          )
        }
      }
    } else {
      filedata <- array(0, dim = c(tmp_nc$dim$lon$len, tmp_nc$dim$lat$len))
      tmp_flip <- FALSE
      if (exists("manure_noalloc_yeardata")) {
        filedata_noalloc <- array(
          0,
          dim = c(tmp_nc$dim$lon$len, tmp_nc$dim$lat$len)
        )
      }
    }
    # Crop to spatial extent of output raster
    lon_index <- which(tmp_nc$dim$lon$vals > xmin(cft_raster) &
      tmp_nc$dim$lon$vals < xmax(cft_raster)
    )
    if (tmp_flip) {
      lat_index <- which(rev(tmp_nc$dim$lat$vals) > ymin(cft_raster) &
        rev(tmp_nc$dim$lat$vals) < ymax(cft_raster)
      )
    } else {
      lat_index <- which(tmp_nc$dim$lat$vals > ymin(cft_raster) &
        tmp_nc$dim$lat$vals < ymax(cft_raster)
      )
    }
    filedata <- filedata[lon_index, lat_index, drop = FALSE]
    if (exists("filedata_noalloc")) {
      filedata_noalloc <- filedata_noalloc[lon_index, lat_index, drop = FALSE]
      filedata_noalloc <- pmax(filedata_noalloc, 0, na.rm = TRUE)
      tmp_sum <- sum(filedata_noalloc)
      manure_noalloc_global[as.character(year), "preprocessing"] <- tmp_sum
      # Aggregate data to output resolution if necessary
      file2output <- round(dim(filedata_noalloc) / dim(cft_raster)[c(2, 1)], 4)
      if (any(file2output > 1)) {
        # Aggregate to output resolution. This is absolute amount and needs no
        # weighting.
        filedata_noalloc <- aggregate_array(
          filedata_noalloc,
          file2output,
          "sum",
          FALSE
        )
        if (abs(sum(filedata_noalloc) / tmp_sum - 1) > 1e-14) {
          stop("Error aggregating manure not allocated to output resolution.")
        }
      }
      rm(tmp_sum)
      if (length(filedata_noalloc) != length(manure_noalloc_yeardata)) {
        stop(
          paste(
            "Unexpected mismatch between filedata_noalloc and",
            "manure_noalloc_yeardata"
          )
        )
      }
      manure_noalloc_yeardata <- filedata_noalloc
      rm(filedata_noalloc)
    }
    rm(lon_index, lat_index)
    if (any(filedata > 0, na.rm = TRUE)) {
      # Weighting
      for (manure_weighting_opt in manure_weighting_options) {
        if ( is.null(manure_weighting_nc[[manure_weighting_opt]])) {
          tmp_nc <- manure_weighting_nc[[1]]
        } else {
          tmp_nc <- manure_weighting_nc[[manure_weighting_opt]]
        }
        tmp_varname <- ifelse(
          is.null(names(manure_weighting_varname)),
          manure_weighting_varname,
          manure_weighting_varname[manure_weighting_opt]
        )
        # Check if manure_weighting_opt has any associated cft_bands
        if (
          # Unnamed manure_weighting_opt, assume all bands that receive
          # manure
          (manure_weighting_opt == "dummy" && any(cft_bands_get_manure)) ||
          # Named manure_weighting_opt, search for manure_weighting_opt in
          # cft_bands -> this assumes that manure_weighting_options are
          # "rainfed" and "irrigated", also used in cft_bands.
          any(grepl(manure_weighting_opt, cft_bands[cft_bands_get_manure]))
        ) {
          if (!tmp_varname %in% names(tmp_nc$var)) {
            stop(
              paste(
                "Unexpected error: manure weighting variable",
                sQuote(tmp_varname), "not found in manure weighting file",
                sQuote(tmp_nc$filename)
              )
            )
          }
          tmp_unit <- ncatt_get(tmp_nc, tmp_varname, "units")
          if (!tmp_unit$hasatt)
            tmp_unit$value <- pasture_weighting_unit
          src_years <- nc_file_years(tmp_nc)
          if (!year %in% src_years) {
            if (!manure_year_missing_weight) {
              message(
                "Year ", year, " is missing in manure weighting data.",
                " Using closest year available in source."
              )
              # Show message only once
              manure_year_missing_weight <- TRUE
            }
            load_year <- src_years[which.min(abs(src_years - year))]
          } else {
            load_year <- year
          }
          weightdata <- ncvar_get(
            tmp_nc,
            tmp_varname,
            start = c(1, 1, which(src_years == load_year)),
            count = c(-1, -1, 1)
          )
          tmp_flip <- (tmp_nc$dim$lat$vals[1] < tmp_nc$dim$lat$vals[2]) !=
            (yFromRow(cft_raster, 1) < yFromRow(cft_raster, 2))
          if (tmp_flip) {
            weightdata <- weightdata[, seq(tmp_nc$dim$lat$len, 1)]
          }
          if (ud.are.convertible(tmp_unit$value, "1") ) {
            # weightdata is fractional. Load area
            if (!exists("manure_weighting_area")) {
              # Only load once, do not reload every year or for every
              # manure_weighting_nc. This requires that manure_weighting_area is
              # the same for all manure_weighting_nc. If they do differ, change
              # code to reload manuree_weighting_area or save several versions
              # of the variable.
              tmp_x <- abs(tmp_nc$dim$lon$vals[1] - tmp_nc$dim$lon$vals[2])
              tmp_y <- abs(tmp_nc$dim$lat$vals[1] - tmp_nc$dim$lat$vals[2])
              manure_weighting_extent <- extent(
                min(tmp_nc$dim$lon$vals) - tmp_x / 2,
                max(tmp_nc$dim$lon$vals) + tmp_x / 2,
                min(tmp_nc$dim$lat$vals) - tmp_y / 2,
                max(tmp_nc$dim$lat$vals) + tmp_x / 2
              )
              tmp_raster <- raster(
                manure_weighting_extent,
                resolution = c(tmp_x, tmp_y)
              )
              manure_weighting_area <- load_hyde_area(
                filename = manure_weighting_area_file,
                fileunits = manure_weighting_area_file_unit,
                return_units = cft_output_area_unit,
                return_raster = tmp_raster,
                gextent = manure_weighting_extent
              )
              manure_weighting_area <- manure_weighting_area$area
              # Crop area to spatial extent
              manure_weighting_area <- crop(
                manure_weighting_area,
                manure_weighting_extent
              )
              rm (tmp_raster, manure_weighting_extent, tmp_x, tmp_y)
            }
            if (ncell(manure_weighting_area) != length(weightdata)) {
              # Spatial resolution and extent should match at this point.
              stop("Unexpected mismatch between weightdata and area data")
            }
            # Convert fractional unit into absolute unit
            weightdata <- ud.convert(weightdata, tmp_unit$value, "1") *
              values(manure_weighting_area)
              # Reset unit of weightdata
              tmp_unit$value <- cft_output_area_unit
          } else {
            # Convert to cft_output_area_unit directly
            weightdata <- ud.convert(
              weightdata,
              tmp_unit$value,
              cft_output_area_unit
            )
          }
          if (any(dim(weightdata) != dim(filedata))) {
            # Crop to spatial extent of output raster
            lon_index <- which(tmp_nc$dim$lon$vals > xmin(cft_raster) &
              tmp_nc$dim$lon$vals < xmax(cft_raster)
            )
            if (tmp_flip) {
              lat_index <- which(rev(tmp_nc$dim$lat$vals) > ymin(cft_raster) &
              rev(tmp_nc$dim$lat$vals) < ymax(cft_raster)
              )
            } else {
              lat_index <- which(tmp_nc$dim$lat$vals > ymin(cft_raster) &
              tmp_nc$dim$lat$vals < ymax(cft_raster)
              )
            }
            weightdata <- weightdata[lon_index, lat_index, drop = FALSE]
            rm(lon_index, lat_index)
            # Compare resolution, aggregate weightdata if necessary
            weight2data <- round(dim(weightdata) / dim(filedata), 4)
            if (any(weight2data > 1)) {
              tmp_sum <- sum(weightdata, na.rm = TRUE)
              weightdata <- aggregate_array(
                weightdata,
                weight2data,
                "sum",
                FALSE
              )
              # Confirm that aggregation has not changed global sum.
              if (abs(sum(weightdata, na.rm = TRUE) / tmp_sum - 1) > 1e-14) {
                stop(
                  paste(
                    "Error aggregating weightdata for",
                    fert_weighting_table$weighting[src]
                  )
                )
              }
              rm(tmp_sum)
            }
          }
          if (length(weightdata) != length(filedata)) {
            # At this point, weightdata should be harmonized with filedata in
            # terms of resolution and spatial extent. Stop if not.
            stop(
              paste(
                "Unexpected mismatch between filedata and weightdata for",
                "manure and",
                ifelse(manure_weighting_opt != "dummy", manure_weighting_opt, ""),
                "manure weighting data"
              )
            )
          }
          # Set missing values to zero in weightdata
          weightdata <- pmax(weightdata, 0, na.rm = TRUE)
          # Set weightdata to 0 in all cells where filedata is missing
          weightdata[which(is.na(filedata))] <- 0
          # Do not set missing values in filedata to zero because filedata may
          # be reused with different weighting option.
          # filedata <- pmax(filedata, 0, na.rm = TRUE)
          # Aggregate data to output resolution if necessary
          file2output <- round(dim(filedata) / dim(cft_raster)[c(2, 1)], 4)
          if (any(file2output > 1)) {
            tmp_sum <- sum(filedata * weightdata, na.rm = TRUE)
            tmp_sum2 <- sum(weightdata)
            # Aggregate to output resolution
            filedata_weighted <- aggregate_array(
              filedata * weightdata,
              file2output,
              "sum",
              FALSE
            )
            weightdata <- aggregate_array(weightdata, file2output, "sum", FALSE)
            if (abs(sum(filedata_weighted, na.rm = TRUE) / tmp_sum - 1) > 1e-14) {
              stop(
                paste(
                  "Error aggregating source data for",
                  ifelse(
                    manure_weighting_opt != "dummy",
                    paste(manure_weighting_opt, "manure"),
                    ""
                  ),
                  "to output resolution."
                )
              )
            }
            if (abs(sum(weightdata) / tmp_sum2 - 1) > 1e-14) {
              stop(
                paste(
                  "Error aggregating weightdata for",
                  ifelse(
                    manure_weighting_opt != "dummy",
                    paste(manure_weighting_opt, "manure"),
                    ""
                  ),
                  "to output resolution."
                )
              )
            }
            rm(tmp_sum, tmp_sum2)
            # Convert back to application rate.
            filedata_weighted <- filedata_weighted / weightdata
            filedata_weighted[which(weightdata == 0)] <- 0
          } else {
            # Use raw source data as weighted aggregation.
            filedata_weighted <- filedata
          }
          # Set missing values in filedata_weighted to 0
          filedata_weighted <- pmax(filedata_weighted, 0, na.rm = TRUE)
          if (length(filedata_weighted) != prod(dim(manure_output_yeardata)[-3])) {
            stop("Unexpected mismatch between filedata and manure_output_yeardata")
          }
          # Apply manure_apply_threshold if necessary
          # General note on accounting of manure not allocated: 
          # (1) The code below assumes that weighting datasets used for manure
          # weighting sum up to the total cropland area upon which manure is
          # applied.
          # (2) The code below assumes that the areas of all cft_bands upon
          # which manure is applied sum up to total cropland. This implies no
          # multiple cropping (which would lead to harvested area sums larger
          # than cropland), but also no left-over cropland assigned to no
          # cft_bands. The latter may not be true unless fallow bands are added
          # to the dataset.
          if (is.finite(manure_apply_threshold) &&
            manure_apply_threshold_res == "target"
          ) {
            tmp_threshold <- ud.convert(
              manure_apply_threshold,
              manure_apply_threshold_unit,
              cft_output_unit
            )
            # Any manure application rates above thresholds are cut off.
            # Excess manure application converted into absolute amount using
            # weightdata (cropland area).
            if (manure_noalloc_account) {
              tmp_noalloc <- pmax(filedata_weighted - tmp_threshold, 0) *
                weightdata
              manure_noalloc_yeardata <-  manure_noalloc_yeardata + tmp_noalloc
              manure_noalloc_global[as.character(year), "threshold"] <-
                manure_noalloc_global[as.character(year), "threshold"] +
                sum(tmp_noalloc)
            }
            # Reduce to tmp_threshold
            filedata_weighted <- pmin(filedata_weighted, tmp_threshold)
          }
          # Add data to manure_output_yeardata
          if (manure_weighting_opt == "dummy") {
            tmp_bands <- which(cft_bands_get_manure)
          } else {
            tmp_bands <- grep(
              manure_weighting_opt,
              cft_bands[which(cft_bands_get_manure)],
              value = TRUE
            )
          }
          manure_output_yeardata[, , tmp_bands] <-
            manure_output_yeardata[, , tmp_bands] + c(filedata_weighted)
          if (manure_noalloc_account) {
            # Note: This total sum assumes that manure is applied to all
            # cropland. If fallow land is not included in cft_bands and
            # crop-specific growing areas are smaller than total cropland (i.e.
            # there would be fallow land), manure that would be applied on
            # fallow land is not included in manure_output_yeardata but is
            # included in manure_noalloc_global[, "applied"]. Because of that,
            # global sums of manure_output_yeardata will be inconsistent with
            # global data in manure_noalloc_global[, "applied"]. 
            manure_noalloc_global[as.character(year), "applied"] <-
              manure_noalloc_global[as.character(year), "applied"] +
              sum(filedata_weighted * weightdata)
          }
          rm(weightdata, filedata_weighted)
        }
      } # end loop manure_weighting_options
    }
    rm(filedata)
  } # end process_manure
  gc()
  

  # Write data to file(s)
  max_table <- array(
    dim = c(length(cft_bands), 0),
    dimnames = list(cft_bands, NULL)
  )
  if (process_fertilizer) {
    if (process_manure && combine_fertilizer_manure) {
      # Combine fertilizer and manure using manure_availability_scalar
      fert_output_yeardata <- fert_output_yeardata + manure_output_yeardata *
        manure_availability_scalar
      rm(manure_output_yeardata)
      gc(full = FALSE)
    }
  } else if (process_manure && combine_fertilizer_manure) {
    # Write manure to fertilizer file using manure_availability_scalar
    fert_output_yeardata <-  manure_output_yeardata * manure_availability_scalar
    rm(manure_output_yeardata)
    gc(full = FALSE)
  }
  if (exists("fert_output_yeardata")) {
    if (cft_format == "NetCDF") {
      fert_max <- apply(fert_output_yeardata, 3, max)
      max_table <- cbind(max_table, fert_max)
      rm(fert_max)
      colnames(max_table)[ncol(max_table)] <- fert_output_var$name
      ncvar_put(
        nc = fert_output_nc,
        varid = fert_output_var$name,
        vals = c(fert_output_yeardata),
        start = c(1, 1, 1, which(time_dim$vals == year)),
        count = c(-1, -1, -1, 1)
      )
      # Make sure all data is actually written to file.
      nc_sync(fert_output_nc)
      rm(fert_output_yeardata)
      gc(full = FALSE)
      if (exists("fert_noalloc_yeardata")) {
        ncvar_put(
          nc = fert_output_nc,
          varid = fert_noalloc_var$name,
          vals = c(fert_noalloc_yeardata),
          start = c(1, 1, 1, which(time_dim$vals == year)),
          count = c(-1, -1, -1, 1)
        )
        # Make sure all data is actually written to file.
        nc_sync(fert_output_nc)
        rm(fert_noalloc_yeardata)
        gc(full = FALSE)
      }
    } else {
      # Extract data for cells included in cft_griddata
      dim(fert_output_yeardata) <- c(ncell(cft_raster), length(cft_bands))
      fert_output_yeardata <-
        fert_output_yeardata[cft_raster_gridindex, , drop = FALSE]
      if (exists("fert_noalloc_yeardata")) {
        dim(fert_noalloc_yeardata) <- c(ncell(cft_raster), length(cft_bands))
        fert_noalloc_yeardata <-
          fert_noalloc_yeardata[cft_raster_gridindex, , drop = FALSE]
      }
      # Prepare data for writing
      fert_max <- apply(fert_output_yeardata, 2, max)
      max_table <- cbind(max_table, fert_max)
      rm(fert_max)
      colnames(max_table)[ncol(max_table)] <-
        ifelse(process_fertilizer, "fert", "manu")
      if (fert_output_header$header["order"] == 1) {
        fert_output_yeardata <- t(fert_output_yeardata)
      }
      if (typeof(get_datatype(fert_output_header)$type) == "double") {
        tmpdata <- c(fert_output_yeardata / fert_output_header$header["scalar"])
      } else if (typeof(get_datatype(fert_output_header)$type) == "integer") {
        tmpdata <- as.integer(
          round(fert_output_yeardata / fert_output_header$header["scalar"])
        )
      } else {
        stop(
          paste(
            "Unexpected datatype",
            sQuote(typeof(get_datatype(fert_output_header)$type)),
            "in fert_output_header. Set datatype to one of the integer of",
            "floating point data types."
          )
        )
      }
      rm(fert_output_yeardata)
      writeBin(
        tmpdata, fert_output_fp,
        size = get_datatype(fert_output_header)$size,
        endian = fert_output_header$endian
      )
      rm(tmpdata)
      gc(full = FALSE)
      if (exists("fert_noalloc_yeardata")) {
        if (fert_noalloc_header$header["order"] == 1) {
          fert_noalloc_yeardata <- t(fert_noalloc_yeardata)
        }
        if (typeof(get_datatype(fert_noalloc_header)$type) == "double") {
          tmpdata <-
            c(fert_noalloc_yeardata / fert_noalloc_header$header["scalar"])
        } else if (typeof(get_datatype(fert_noalloc_header)$type) == "integer") {
          tmpdata <- as.integer(
            round(fert_noalloc_yeardata / fert_noalloc_header$header["scalar"])
          )
        } else {
          stop(
            paste(
              "Unexpected datatype",
              sQuote(typeof(get_datatype(fert_noalloc_header)$type)),
              "in fert_noalloc_header. Set datatype to one of the integer of",
              "floating point data types."
            )
          )
        }
        rm(fert_noalloc_yeardata)
        writeBin(
          tmpdata, fert_noalloc_fp,
          size = get_datatype(fert_noalloc_header)$size,
          endian = fert_noalloc_header$endian
        )
        rm(tmpdata)
        gc(full = FALSE)
      }
    }
  }
  if (exists("manure_output_yeardata")) {
    if (cft_format == "NetCDF") {
      manure_max <- apply(manure_output_yeardata, 3, max)
      max_table <- cbind(max_table, manure_max)
      rm(manure_max)
      colnames(max_table)[ncol(max_table)] <- manure_output_var$name
      ncvar_put(
        nc = manure_output_nc,
        varid = manure_output_var$name,
        vals = c(manure_output_yeardata),
        start = c(1, 1, 1, which(time_dim$vals == year)),
        count = c(-1, -1, -1, 1)
      )
      # Make sure all data is actually written to file.
      nc_sync(manure_output_nc)
      rm(manure_output_yeardata)
      gc(full = FALSE)
    } else {
      # Extract data for cells included in cft_griddata
      dim(manure_output_yeardata) <- c(ncell(cft_raster), length(cft_bands))
      manure_output_yeardata <-
        manure_output_yeardata[cft_raster_gridindex, , drop = FALSE]
      # Prepare data for writing
      manure_max <- apply(manure_output_yeardata, 2, max)
      max_table <- cbind(max_table, manure_max)
      rm(manure_max)
      colnames(max_table)[ncol(max_table)] <- "manu"
      if (manure_output_header$header["order"] == 1) {
        manure_output_yeardata <- t(manure_output_yeardata)
      }
      if (typeof(get_datatype(manure_output_header)$type) == "double") {
        tmpdata <-
          c(manure_output_yeardata / manure_output_header$header["scalar"])
      } else if (typeof(get_datatype(manure_output_header)$type) == "integer") {
        tmpdata <- as.integer(
          round(manure_output_yeardata / manure_output_header$header["scalar"])
        )
      } else {
        stop(
          paste(
            "Unexpected datatype",
            sQuote(typeof(get_datatype(fert_output_header)$type)),
            "in manure_output_header. Set datatype to one of the integer of",
            "floating point data types."
          )
        )
      }
      rm(manure_output_yeardata)
      writeBin(
        tmpdata, manure_output_fp,
        size = get_datatype(manure_output_header)$size,
        endian = manure_output_header$endian
      )
      rm(tmpdata)
      gc(full = FALSE)
    }
  }
  if (exists("manure_noalloc_yeardata")) {
    if (cft_format == "NetCDF") {
      # Data is saved to fertilizer file if no separate manure file is created,
      # otherwise to manure file.
      if (exists("manure_output_var")) {
        ncvar_put(
          nc = manure_output_nc,
          varid = manure_noalloc_var$name,
          vals = c(manure_noalloc_yeardata),
          start = c(1, 1, which(time_dim$vals == year)),
          count = c(-1, -1, 1)
        )
        # Make sure all data is actually written to file.
        nc_sync(manure_output_nc)
      } else {
        ncvar_put(
          nc = fert_output_nc,
          varid = manure_noalloc_var$name,
          vals = c(manure_noalloc_yeardata),
          start = c(1, 1, which(time_dim$vals == year)),
          count = c(-1, -1, 1)
        )
        # Make sure all data is actually written to file.
        nc_sync(fert_output_nc)
      }
    } else {
      # Extract data for cells included in cft_griddata
      manure_noalloc_yeardata <- manure_noalloc_yeardata[cft_raster_gridindex]
      # Prepare data for writing
      if (typeof(get_datatype(manure_noalloc_header)$type) == "double") {
        tmpdata <-
          c(manure_noalloc_yeardata / manure_noalloc_header$header["scalar"])
      } else if (typeof(get_datatype(manure_noalloc_header)$type) == "integer") {
        tmpdata <- as.integer(
          round(manure_noalloc_yeardata / manure_noalloc_header$header["scalar"])
        )
      } else {
        stop(
          paste(
            "Unexpected datatype",
            sQuote(typeof(get_datatype(fert_output_header)$type)),
            "in manure_noalloc_header. Set datatype to one of the integer of",
            "floating point data types."
          )
        )
      }
      writeBin(
        tmpdata, manure_noalloc_fp,
        size = get_datatype(manure_noalloc_header)$size,
        endian = manure_noalloc_header$endian
      )
      rm(tmpdata)
    }
    rm(manure_noalloc_yeardata)
  }
      
  colnames(max_table) <- paste0(
    "Max. ",
    sub("fert", "fertilizer", sub("manu", "manure", colnames(max_table))),
    " rate [", cft_output_unit, "]"
  )
  saved_width <- options()$width
  width <- max(nchar(rownames(max_table))) + sum(nchar(colnames(max_table))) + 3
  options(width = width)
  print(max_table)
  options(width = saved_width)
  gc(reset = TRUE)
}
################################################################################


################################################################################
## Final clean up                                                             ##
if (exists("manure_noalloc_global")) {
  manure_noalloc_global <- data.frame(
    Year = rownames(manure_noalloc_global),
    manure_noalloc_global
  )
  colnames(manure_noalloc_global) <- sub(
    "preprocessing",
    paste0("Manure amount lost in preprocessing [", cft_output_mass_unit, "]"),
    colnames(manure_noalloc_global)
  )
  colnames(manure_noalloc_global) <- sub(
    "threshold",
    paste0(
      "Manure amount lost by application of threshold [",
      cft_output_mass_unit, "]"
    ),
    colnames(manure_noalloc_global)
  )
  colnames(manure_noalloc_global) <- sub(
    "applied",
    paste0("Total global amount of applied manure [", cft_output_mass_unit, "]"),
    colnames(manure_noalloc_global)
  )
  write.csv(
    manure_noalloc_global,
    file = manure_noalloc_global_name,
    row.names = FALSE
  )
}
# Finalize files created by this script
if (cft_format == "NetCDF") {
  if (exists("fert_output_nc")) {
    cat(time_dim$len, "years saved to", fert_output_nc$filename, "\n")
    nc_close(fert_output_nc)
  }
  if (exists("manure_output_nc")) {
    cat(time_dim$len, "years saved to", manure_output_nc$filename, "\n")
    nc_close(manure_output_nc)
  }
} else {
  if (exists("fert_output_fp")) {
    cat(
      fert_output_header$header["nyear"], "years saved to",
      fert_output_name, "\n"
    )
    close(fert_output_fp)
  }
  if (exists("manure_output_fp")) {
    cat(
      manure_output_header$header["nyear"], "years saved to",
      manure_output_name, "\n"
    )
    close(manure_output_fp)
  }
  if (exists("manure_noalloc_fp")) {
    cat(
      manure_noalloc_header$header["nyear"], "years saved to",
      manure_noalloc_name, "\n"
    )
    close(manure_noalloc_fp)
  }
  if (exists("fert_noalloc_fp")) {
    cat(
      fert_noalloc_header$header["nyear"], "years saved to",
      fert_noalloc_name, "\n"
    )
    close(fert_noalloc_fp)
  }
}
# Close NetCDF files opened by this script
if (exists("fert_nc") && length(fert_nc) > 0)
  invisible(sapply(fert_nc, nc_close))
if (exists("ha_weighting_nc") && length(ha_weighting_nc) > 0)
  invisible(sapply(ha_weighting_nc, nc_close))
if (exists("pasture_weighting_nc") && length(pasture_weighting_nc) > 0)
  invisible(sapply(pasture_weighting_nc, nc_close))
if (exists("manure_nc") && length(manure_nc) > 0)
  invisible(sapply(manure_nc, nc_close))
if (exists("manure_weighting_nc") && length(manure_weighting_nc) > 0)
  invisible(sapply(manure_weighting_nc, nc_close))
################################################################################
