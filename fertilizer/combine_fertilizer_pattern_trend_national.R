################################################################################
## Copyright (C) 2022 Potsdam Institute for Climate Impact Research (PIK),    ##
## see COPYRIGHT file.                                                        ##
##                                                                            ##
## This file is part of LandInG and licensed under GNU AGPL Version 3 or      ##
## later. See LICENSE file or go to http://www.gnu.org/licenses/              ##
## Contact: https://github.com/PIK-LPJmL/LandInG/                             ##
################################################################################

################################################################################
## This script combines spatial fertilizer application patterns with national ##
## time series of fertilizer application trends. Do not use this script if    ##
## trend time series has subnational data.                                    ##
## This script usually takes gap-filled spatial patterns processed by         ##
## gapfill_fertilizer_pattern.R and combines them with gap-filled trends      ##
## processed by gapfill_fertilizer_trend.R.                                   ##
## Script run can be parallelized to speed up processing of crops. The        ##
## parallelization mechanism is implemented through foreach which has         ##
## backends for several parallelization mechanisms. This script has options   ##
## for the doMPI backend (using MPI) and the doParallel backend. Further      ##
## backends are possible. The example below may not work on your system. Try  ##
## to adjust parameters or set "cluster <- FALSE" to switch off               ##
## parallelization and run in sequential mode.                                ##
################################################################################

# Clean up memory
rm(list = ls(all = TRUE))

################################################################################
## Setup of variables valid across all scripts related to fertilizer data     ##
## processing.                                                                ##
## - sets many directories and file names                                     ##
source("fertilizer_setup.R")
## Try parallelization                                                        ##
cluster <- TRUE
## Missing value used in NetCDF files generated by this script.               ##
missval_float <- 1e20
missval_integer <- -5
################################################################################


################################################################################
## Optional ISO code replacement list                                         ##
## This allows to assign cells with a specific ISO code in fertilizer pattern ##
## to a different ISO code. Use this if countries in fertilizer patterns do   ##
## not match countries in fertilizer trend data. Replacement_iso should be a  ##
## country included in fertilizer trend data.                                 ##
pattern_admin_replacement <- rbind(
  # Dummy row illustrating format
  data.frame(source = character(0), replacement = character(0)),
  # Add any replacement rules here.
  # LUH2 uses Former Soviet Union for all successor countries. Make sure this
  # matches helper/fix_admin_masks.R
  data.frame(source = "ARM", replacement = "SUN"),
  data.frame(source = "AZE", replacement = "SUN"),
  data.frame(source = "BLR", replacement = "SUN"),
  data.frame(source = "EST", replacement = "SUN"),
  data.frame(source = "GEO", replacement = "SUN"),
  data.frame(source = "KAZ", replacement = "SUN"),
  data.frame(source = "KGZ", replacement = "SUN"),
  data.frame(source = "LVA", replacement = "SUN"),
  data.frame(source = "LTU", replacement = "SUN"),
  data.frame(source = "MDA", replacement = "SUN"),
  data.frame(source = "RUS", replacement = "SUN"),
  data.frame(source = "TJK", replacement = "SUN"),
  data.frame(source = "TKM", replacement = "SUN"),
  data.frame(source = "UKR", replacement = "SUN"),
  data.frame(source = "UZB", replacement = "SUN"),
  # LUH2 uses former Yugoslavia for all successor countries.
  data.frame(source = "BIH", replacement = "YUG"),
  data.frame(source = "HRV", replacement = "YUG"),
  data.frame(source = "MKD", replacement = "YUG"),
  data.frame(source = "MNE", replacement = "YUG"),
  data.frame(source = "SRB", replacement = "YUG"),
  data.frame(source = "SVN", replacement = "YUG"),
  # LUH2 uses former Netherland Antilles for successor countries.
  data.frame(source = "BES", replacement = "ANT"),
  data.frame(source = "CUW", replacement = "ANT"),
  data.frame(source = "SXM", replacement = "ANT"),
  # LUH2 Czechoslovakia for Czechia and Slovakia.
  data.frame(source = "CZE", replacement = "CSK"),
  data.frame(source = "SVK", replacement = "CSK"),
  # LUH2 uses Sudan before secession of South Sudan for both countries.
  data.frame(source = "SDN", replacement = "XSD"),
  data.frame(source = "SSD", replacement = "XSD"),
  # LUH2 uses Ethiopia for both Ethiopia and Eritrea.
  data.frame(source = "ERI", replacement = "ETH"),
  # Assign Guernsey, Isle of Man and Jersey to Great Britain.
  data.frame(source = "GGY", replacement = "GBR"),
  data.frame(source = "IMN", replacement = "GBR"),
  data.frame(source = "JEY", replacement = "GBR"),
  # The only land cells in the Caspian Sea according to current HYDE cropland
  # dataset are along the Russian shoreline. Use LUH2 trend for Former Soviet
  # Union.
  data.frame(source = "XCA", replacement = "SUN"),
  stringsAsFactors = FALSE
)
################################################################################


################################################################################
## Trying to set up cluster using MPI interface or doParallel.                ##
## The implementation using the MPI interface has been developed for a high   ##
## performance cluster. If Rmpi and doMPI are installed and cluster == TRUE   ##
## the script tries to use this combination of packages.                      ##
## If Rmpi is not available but cluster == TRUE the script attempts to use    ##
## parallelization through the "parallel" package and doParallel.             ##
##                                                                            ##
## This part may need to be tweaked for your system set up.                   ##
parallel_mpi <- parallel_local <- FALSE # Not to be set by user
if (cluster) {
  # Try parallelization
  if (require(Rmpi)) {
    # Rmpi = R implementation of MPI interface
    # This is intended for parallelization on high-performance cluster.
    if (require(doMPI)) {
      # doMPI = interface for foreach construct to run in MPI parallel mode
       # Start MPI cluster (link R instances together)
      cl <- doMPI::startMPIcluster()
      # Number of R instances linked together
      num_cluster <- doMPI::clusterSize(cl)
      if (num_cluster > 1) {
        # Script is using more than 1 CPU, so really run in parallel mode
        # Tell foreach to use MPI backend for parallelization
        doMPI::registerDoMPI(cl)
        cat("Running in parallel mode on", num_cluster, "worker nodes.\n")
        parallel_mpi <- TRUE
      } else {
        # Only one task
        # Tell foreach to use sequential mode
        registerDoSEQ()
        cat("Running in sequential mode because only one node is available.\n")
        num_cluster <- 1
      }
    } else {
      # doMPI package is missing
      warning(
        "It seems that you have Rmpi installed. This script requires ",
        "both Rmpi and doMPI package to run in parallel mode.",
        call. = FALSE,
        immediate. = TRUE
      )
      registerDoSEQ() # Tell foreach to use sequential mode
      cat("Falling back to running in sequential mode.\n")
      num_cluster <- 1
    }
  } else if (require(doParallel)) {
    # Try parallelization through parallel package.
    # This is probably more suitable to run in parallel on a local machine
    # Get number of CPU cores
    ncores <- parallel::detectCores()
    # It is probably a good idea not to use all CPUs on your computer.
    # The number of usable CPUs may also be limited by the memory requirement
    # of each task. Test thoroughly in order not to cripple your system.
    if (is.finite(ncores)) {
      num_cluster <- ceiling(ncores / 2)
    } else {
      # parallel::detectCores() could not detect number of CPUs. Fall back to 1.
      num_cluster <- 1
    }
    if (num_cluster > 1) {
      # Start cluster on local machine
      cl <- parallel::makeCluster(num_cluster)
      # Tell foreach to use this cluster
      registerDoParallel(num_cluster)
      parallel_local <- TRUE
      cat("Running in parallel mode on", num_cluster, "CPUs\n")
    } else {
      # Only one task
      registerDoSEQ() # Tell foreach to use sequential mode
      cat("Running in sequential mode because only one CPU is available.\n")
    }
  } else {
    # Rmpi and doParallel package are missing
    warning(
      "This script requires Rmpi and doMPI or",
      " parallel and doParallel to run in parallel mode.",
      " Please install missing packages or set cluster to FALSE.",
      call. = FALSE,
      immediate. = TRUE
    )
    registerDoSEQ() # Tells foreach to use sequential mode
    cat("Falling back to running in sequential mode.\n")
    num_cluster <- 1
  }
} else {
  # Do not try parallelization
  library(foreach)
  registerDoSEQ() # Tells foreach to use sequential mode
  cat("Running in sequential mode.\n")
  num_cluster <- 1
}
################################################################################


################################################################################
## Load spatial units                                                         ##
# Fertilizer patterns
if (fertilizer_pattern_admin == "gadm") {
  cat("Admin units for patterns loaded from", sQuote(gadmlevel_file), "\n")
  pattern_admin_raster <- brick(gadmlevel_file)
  pattern_admin_names <- read.csv(
    gadmlevel_names_file,
    stringsAsFactors = FALSE,
    comment.char = "#"
  )
  if (ncol(pattern_admin_names) != nlayers(pattern_admin_raster) * 3) {
    stop(
      paste(
        "Admin unit names from", gadmlevel_names_file, "do not seem to match",
        "admin unit layers from", gadmlevel_file
      )
    )
  }
  # Spatial resolution of admin mask.
  pattern_admin_res <- res(pattern_admin_raster)
  # Column name in country grouping that contains matching codes
  pattern_country_grouping_col <- gadm_country_col
} else if (fertilizer_pattern_admin == "luh2") {
  cat("Admin units for patterns loaded from", sQuote(luh2country_file), "\n")
  pattern_admin_raster <- brick(
    luh2country_file,
    varname = luh2country_variable,
    band = luh2country_layer
  )
  pattern_admin_names <- NULL
  # Spatial resolution of admin mask.
  pattern_admin_res <- res(pattern_admin_raster)
  # Column name in country grouping that contains matching codes
  pattern_country_grouping_col <- luh2_country_col
} else {
    stop(
    paste(
      "Undefined fertilizer_pattern_admin", sQuote(fertilizer_pattern_admin),
      "\nCheck fertilizer_setup.R"
    )
  )
}
if (!is.null(pattern_admin_names)) {
  # Note this is currently only supported for the GADM level 0-2 raster and
  # the corresponding unit name table.
  # Find column with country codes used in raster
  pattern_id_col <- grep(
    "level0.id",
    colnames(pattern_admin_names),
    ignore.case = TRUE,
    value = TRUE
  )
  if (length(pattern_id_col) != 1) {
    stop("Cannot detect country ID column in pattern_admin_names")
  }
  # Find column with country ISO codes
  pattern_iso_col <- grep(
    "level0.code",
    colnames(pattern_admin_names),
    ignore.case = TRUE,
    value = TRUE
  )
  if (length(pattern_iso_col) != 1) {
    stop(
      "Cannot detect country ISO code column in pattern_admin_names"
    )
  }
  pattern_name_col <- grep(
    "country",
    colnames(pattern_admin_names),
    ignore.case = TRUE,
    value = TRUE
  )
  if (length(pattern_name_col) != 1) {
    stop(
      "Cannot detect country name column in pattern_admin_names"
    )
  }
}
if (nlayers(pattern_admin_raster) == 1) {
  # Reduce brick to raster layer in case of only one layer because single-layer
  # bricks cause problems in raster package code.
  pattern_admin_raster <- subset(pattern_admin_raster, 1)
} else {
  # Try to find country layer. Assumption is that country layer has lowest
  # number of unique admin unit codes
  pattern_national_band <- find_national_band(pattern_admin_raster)
  # Reduce to country layer
  cat(
    "Extracting layer ", pattern_national_band, " from ",
    nlayers(pattern_admin_raster), "-band ",
    "pattern_admin_raster as national band.",
    sep = ""
  )
  pattern_admin_raster <- subset(
    pattern_admin_raster,
    pattern_national_band
  )
  if (!is.null(pattern_admin_names)) {
    # Reduce name table to national columns
    col <- c(pattern_id_col, pattern_iso_col, pattern_name_col)
    pattern_admin_names <- pattern_admin_names[, col]
  }
}

# Fertilizer trends
if (!fertilizer_trend_is_national) {
  stop(
    paste(
      "This script is intended for national fertilizer trend data but",
      "fertilizer_trend_is_national is FALSE.",
      "\nUse combine_fertilizer_pattern_trend_subnational.R or switch",
      "fertilizer_trend_is_national setting and rerun",
      "gapfill_fertilizer_trend.R"
    )
  )
}
if (fertilizer_trend_admin == "gadm") {
  cat("Admin units for trends loaded from", sQuote(gadmlevel_file), "\n")
  trend_admin_raster <- brick(gadmlevel_file)
  trend_admin_names <- read.csv(
    gadmlevel_names_file,
    stringsAsFactors = FALSE,
    comment.char = "#"
  )
  # Spatial resolution of admin mask.
  trend_admin_res <- res(trend_admin_raster)
  # Column name in country grouping that contains matching codes
  trend_country_grouping_col <- gadm_country_col
} else if (fertilizer_trend_admin == "luh2") {
  cat("Admin units for trends loaded from", sQuote(luh2country_file), "\n")
  trend_admin_raster <- brick(
    luh2country_file,
    varname = luh2country_variable,
    band = luh2country_layer
  )
  trend_admin_names <- NULL
  # Spatial resolution of admin mask.
  trend_admin_res <- res(trend_admin_raster)
  # Column name in country grouping that contains matching codes
  trend_country_grouping_col <- luh2_country_col
} else {
  stop(
    paste(
      "Undefined fertilizer_trend_admin", sQuote(fertilizer_trend_admin),
      "\nCheck fertilizer_setup.R"
    )
  )
}
# Number of admin unit levels. Used to interpret gapfill_level in gap-filled
# trend data. By default, gapfill_pattern() assumes 3 admin units. Set higher if
# you used more admin levels during gap-filling. Do not set lower.
trend_unit_levels <- max(3, nlayers(trend_admin_raster))

if (!is.null(trend_admin_names)) {
  # Note this is currently only supported for the GADM level 0-2 raster and
  # the corresponding unit name table.
  # Find column with country codes used in raster
  trend_id_col <- grep(
    "level0.id",
    colnames(trend_admin_names),
    ignore.case = TRUE,
    value = TRUE
  )
  if (length(trend_id_col) != 1) {
    stop("Cannot detect country ID column in trend_admin_names")
  }
  # Find column with country ISO codes
  trend_iso_col <- grep(
    "level0.code",
    colnames(trend_admin_names),
    ignore.case = TRUE,
    value = TRUE
  )
  if (length(trend_iso_col) != 1) {
    stop(
      "Cannot detect country ISO code column in trend_admin_names"
    )
  }
  trend_name_col <- grep(
    "country",
    colnames(trend_admin_names),
    ignore.case = TRUE,
    value = TRUE
  )
  if (length(trend_name_col) != 1) {
    stop(
      "Cannot detect country name column in trend_admin_names"
    )
  }
}
if (nlayers(trend_admin_raster) == 1) {
  # Reduce brick to raster layer in case of only one layer because single-layer
  # bricks cause problems in raster package code.
  trend_admin_raster <- subset(trend_admin_raster, 1)
} else {
  # Try to find country layer. Assumption is that country layer has lowest
  # number of unique admin unit codes
  trend_national_band <- find_national_band(trend_admin_raster)
  # Reduce to country layer
  cat(
    "Extracting layer ", trend_national_band, " from ",
    nlayers(trend_admin_raster), "-band ",
    "trend_admin_raster as national band.",
    sep = ""
  )
  trend_admin_raster <- subset(
    trend_admin_raster,
    trend_national_band
  )
  if (!is.null(trend_admin_names)) {
    # Reduce name table to national columns
    col <- c(trend_id_col, trend_iso_col, trend_name_col)
    trend_admin_names <- trend_admin_names[, col]
  }
}
if (!anyNA(values(pattern_admin_raster)) && fertilizer_pattern_strip_zero) {
  message(
    "Info: pattern_admin_raster does not contain any NAs and",
    "fertilizer_pattern_strip_zero is TRUE. Replacing 0 with NA in admin",
    "data."
  )
  pattern_admin_raster <- mask(
    pattern_admin_raster,
    pattern_admin_raster,
    maskvalue = 0
  )
}
if (!anyNA(values(trend_admin_raster)) && fertilizer_trend_strip_zero) {
  message(
    "Info: trend_admin_raster does not contain any NAs and ",
    "fertilizer_trend_strip_zero is TRUE. Replacing 0 with NA in admin ",
    "data."
  )
  trend_admin_raster <- mask(
    trend_admin_raster,
    trend_admin_raster,
    maskvalue = 0
  )
}
################################################################################


################################################################################
## Load country grouping and crop list                                        ##
# Country grouping
if (file.exists(country_group_file)) {
  cat("Country groups loaded from", sQuote(country_group_file), "\n")
  country_group_data <- read.csv(country_group_file, stringsAsFactors = FALSE)
} else {
  stop(
    paste(
      "Country groups file", country_group_file, "does not exist.",
      "\nPlease check fertilizer_setup.R"
    )
  )
}
# Find column containing 3-letter ISO codes in country_group_data
country_group_iso3_col <- grep(
  "iso.alpha3", colnames(country_group_data), ignore.case = TRUE, value = TRUE
)
if (length(country_group_iso3_col) != 1) {
  stop(
    paste(
      "Cannot detect column containing 3-letter ISO code in data loaded from",
      country_group_file
    )
  )
}
# Find country name column in country_group_data
country_group_name_col <- grep(
  "country", colnames(country_group_data), ignore.case = TRUE
)
if (length(country_group_name_col) != 1) {
  stop(
    paste(
      "Cannot detect column containing country name in data loaded from",
      country_group_file
    )
  )
}

# Apply user-defined code additions to country_group_data.
if (fertilizer_pattern_admin == "gadm" || fertilizer_trend_admin == "gadm" &&
  exists("add_list_gadm")
) {
  # Apply user-defined code additions. 
  # add_list_gadm defined in helper/fix_admin_masks.R
  country_group_data <- add_to_country_list(country_group_data, add_list_gadm)
}
if (fertilizer_pattern_admin == "luh2" || fertilizer_trend_admin == "luh2" &&
  exists("add_list_luh2")
) {
  # Apply user-defined code additions. 
  # add_list_luh2 defined in helper/fix_admin_masks.R
  country_group_data <- add_to_country_list(country_group_data, add_list_luh2)
}

# Check that country_group_data has columns matching codes used in fertilizer
# patterns and fertilizer trend data.
if (!pattern_country_grouping_col %in% colnames(country_group_data)) {
  # Try to match name using grep
  if (length(
    grep(
      pattern_country_grouping_col,
      colnames(country_group_data),
      ignore.case = TRUE
    )
  ) == 1
  ) {
    message(
      "Replace pattern_country_grouping_col ",
      sQuote(pattern_country_grouping_col),
      " with ",
      sQuote(
        grep(
          pattern_country_grouping_col,
          colnames(country_group_data),
          ignore.case = TRUE,
          value = TRUE
        )
      )
    )
    pattern_country_grouping_col <- grep(
      pattern_country_grouping_col,
      colnames(country_group_data),
      ignore.case = TRUE,
      value = TRUE
    )
  } else {
    stop(
      paste(
        "Column pattern_country_grouping_col",
        sQuote(pattern_country_grouping_col),
        "missing in country_group_data"
      )
    )
  }
}
if (!trend_country_grouping_col %in% colnames(country_group_data)) {
  # Try to match name using grep
  if (length(
    grep(
      trend_country_grouping_col,
      colnames(country_group_data),
      ignore.case = TRUE
    )
  ) == 1
  ) {
    message(
      "Replace trend_country_grouping_col ",
      sQuote(trend_country_grouping_col),
      " with ",
      sQuote(
        grep(
          trend_country_grouping_col,
          colnames(country_group_data),
          ignore.case = TRUE,
          value = TRUE
        )
      )
    )
    trend_country_grouping_col <- grep(
      trend_country_grouping_col,
      colnames(country_group_data),
      ignore.case = TRUE,
      value = TRUE
    )
  } else {
    stop(
      paste(
        "Column trend_country_grouping_col",
        sQuote(trend_country_grouping_col),
        "missing in country_group_data"
      )
    )
  }
}
# Check that all admin codes in fertilizer pattern data are in
# country_group_data
if (
  length(
    unique(na.omit(country_group_data[, pattern_country_grouping_col]))
  ) != nrow(country_group_data)
) {
  # Not all rows have unique value
  stop(
    paste(
      "Not all rows in country_group_data have unique value for column",
      "pattern_country_grouping_col", sQuote(pattern_country_grouping_col)
    )
  )
}

if (!is.null(pattern_admin_names)) {
  if (!all(na.omit(values(pattern_admin_raster)) %in%
    pattern_admin_names[, pattern_id_col])
  ) {
    # Mismatch between pattern_admin_raster and pattern_admin_names
    stop(
      paste(
        "Codes used in pattern_admin_raster do not match codes in",
        "pattern_admin_names"
      )
    )
  }
  # Determine ISO codes of countries
  iso_r <- match(
    unique(na.omit(values(pattern_admin_raster))),
    pattern_admin_names[, pattern_id_col]
  )
  pattern_admin_iso <- pattern_admin_names[iso_r, pattern_iso_col]
  rm(iso_r)
  # Check which country codes are missing in country_group_data
  pattern_admin_mismatch <- setdiff(
    pattern_admin_iso,
    country_group_data[, country_group_iso3_col]
  )
  if (fertilizer_pattern_admin == "gadm" && exists("ccode_replacement_gadm")) {
    # Include any replacement rules that may be set up in
    # helper/fix_admin_masks.R
    pattern_admin_mismatch <- union(
      pattern_admin_mismatch,
      ccode_replacement_gadm$source
    )
  }
  # Also do any replacements set up in pattern_admin_replacement in this script
  pattern_admin_mismatch <- union(
    pattern_admin_mismatch,
    pattern_admin_replacement$source
  )
  for (isocode in pattern_admin_mismatch) {
    # Determine country name
    iso_r <- match(isocode, pattern_admin_names[, pattern_iso_col])
    source_name <- pattern_admin_names[iso_r, pattern_name_col]
    source_code <- pattern_admin_names[iso_r, pattern_id_col]
    # First check ccode_replacement_gadm for possible replacement entry.
    if (fertilizer_pattern_admin == "gadm" &&
      exists("ccode_replacement_gadm") &&
      isocode %in% ccode_replacement_gadm$source
    ) {
      # Check that replacement exists in pattern_admin_names
      source_r <- match(isocode, ccode_replacement_gadm$source)
      replacement_iso <- ccode_replacement_gadm$replacement[source_r]
      if (replacement_iso %in% pattern_admin_names[, pattern_iso_col]) {
        # Find replacement_iso in pattern_admin_names
        iso_r <- match(replacement_iso, pattern_admin_names[, pattern_iso_col])
      } else {
        rm(replacement_iso)
      }
    }
    # Second, check pattern_admin_replacement for possible replacement entry.
    # This may overwrite replacement rule from ccode_replacement_gadm
    if (isocode %in% pattern_admin_replacement$source) {
      # Check that replacement exists in pattern_admin_names
      source_r <- match(isocode, pattern_admin_replacement$source)
      replacement_iso <- pattern_admin_replacement$replacement[source_r]
      if (replacement_iso %in% pattern_admin_names[, pattern_iso_col]) {
        # Find replacement_iso in pattern_admin_names
        iso_r <- match(replacement_iso, pattern_admin_names[, pattern_iso_col])
      } else {
        rm(replacement_iso)
      }
    }
    if (exists("replacement_iso")) {
      message(
        "User-defined country replacement ",
        isocode,
        " (", source_name, ") -> ",
        replacement_iso,
        " (", pattern_admin_names[iso_r, pattern_name_col], ")"
      )
    } else {      
      # Find all countries in fao_gadm_country_mapping that contain isocode and
      # also contain country codes actually found in country_group_data. May be
      # more than one.
      country_match <- which(
        sapply(
          fao_gadm_country_mapping,
          function(codes, search, all_valid) {
            search %in% codes && any(all_valid %in% codes)
          },
          search = isocode,
          all_valid = country_group_data[, country_group_iso3_col]
        )
      )
      if (length(country_match) > 0) {
        replacement_name <- names(
          sort(sapply(fao_gadm_country_mapping[country_match], length))
        )[1]
        # Country in fao_gadm_country_mapping consists of several ISO codes.
        # Replace with first ISO code that is included in country_group_data,
        # assuming that main ISO code is listed first.
        replacement_iso <- intersect(
          fao_gadm_country_mapping[[replacement_name]],
          country_group_data[, country_group_iso3_col]
        )[1]
        # Find replacement_iso in pattern_admin_names
        if (isocode == replacement_iso) {
          # No need to replace with identical value.
          rm(replacement_iso)
        } else {
          iso_r <- match(
            replacement_iso,
            pattern_admin_names[, pattern_iso_col]
          )
          message(
            "Automatically determined country replacement ",
            isocode,
            " (", source_name, ") -> ",
            replacement_iso,
            " (", pattern_admin_names[iso_r, pattern_name_col], ")"
          )
        }
      }
    }
    if (exists("replacement_iso")) {
      # Find corresponding country ID in pattern_admin_raster
      iso_r <- match(replacement_iso, pattern_admin_names[, pattern_iso_col])
      replacement_code <- pattern_admin_names[iso_r, pattern_id_col]
      pattern_admin_raster <- mask(
        pattern_admin_raster,
        pattern_admin_raster,
        maskvalue = source_code,
        updatevalue = replacement_code
      )
      rm(replacement_iso)
    }
  }
  # Check once more if all ISO codes in pattern_admin_raster are covered
  iso_r <- match(
    unique(na.omit(values(pattern_admin_raster))),
    pattern_admin_names[, pattern_id_col]
  )
  pattern_admin_iso <- pattern_admin_names[iso_r, pattern_iso_col]
  rm(iso_r)
  # Check which country codes are missing in country_group_data
  pattern_admin_mismatch <- setdiff(
    pattern_admin_iso,
    country_group_data[, country_group_iso3_col]
  )
  if (exists("pattern_admin_replacement")) {
    # Also allow rules from pattern_admin_replacement.
    pattern_admin_mismatch <- setdiff(
      pattern_admin_mismatch,
      pattern_admin_replacement$source
    )
  }
  if (length(pattern_admin_mismatch) > 0) {
    # There are grid cells in pattern_admin_raster in countries not accounted
    # for in country_group_data or pattern_admin_replacement
    stop(
      paste(
        "The following countries found in pattern_admin_raster need to be",
        "added either to country_group_data via an entry in",
        switch(
          fertilizer_pattern_admin,
          gadm = sQuote("add_list_gadm"),
          luh2 = sQuote("add_list_luh2"),
          stop(
            paste(
              "Unexpected fertilizer_pattern_admin",
              sQuote(fertilizer_pattern_admin)
            )
          )
        ),
        "or to 'pattern_admin_replacement':",
        toString(sQuote(pattern_admin_mismatch))
      )
    )
  }
} else if (fertilizer_pattern_admin == "luh2") {
  # All country codes in admin unit mask
  ccodes <- na.omit(unique(values(pattern_admin_raster)))
  # User-defined country replacements set up in this script
  if (exists("pattern_admin_replacement")) {
    # Try to match ISO codes in pattern_admin_replacement to codes used by
    # LUH2
    source_r <- match(
      pattern_admin_replacement$source,
      country_group_data[, country_group_iso3_col]
    )
    replacement_r <- match(
      pattern_admin_replacement$replacement,
      country_group_data[, country_group_iso3_col]
    )
    for (r in which(!is.na(source_r) & !is.na(replacement_r))) {
      # LUH2 country code corresponding to source ISO code
      ccode_source <-
        country_group_data[source_r[r], pattern_country_grouping_col]
      # LUH2 country code corresponding to replacement ISO code
      ccode_replacement <- 
        country_group_data[replacement_r[r], pattern_country_grouping_col]
      pattern_admin_raster <- mask(
        pattern_admin_raster,
        pattern_admin_raster,
        maskvalue = ccode_source,
        updatevalue = ccode_replacement
      )
      message(
        "User-defined country replacement ",
        sQuote(ccode_source),
        " (", country_group_data[source_r[r], country_group_name_col], ")",
        " -> ",
        sQuote(ccode_replacement),
        " (", country_group_data[replacement_r[r], country_group_name_col],
        ")"
      )
    }
  }
  rm(ccodes)
  if (exists("ccode_replacement_luh2")) {
    for (r in seq_len(nrow(ccode_replacement_luh2))) {
      if (!ccode_replacement_luh2[r, "source"] %in%
        country_group_data[, pattern_country_grouping_col] &&
        ccode_replacement_luh2[r, "replacement"] %in%
        country_group_data[, pattern_country_grouping_col]
      ) {
        replacement_r <- match(
          ccode_replacement_luh2[r, "replacement"],
          country_group_data[, pattern_country_grouping_col]
        )
        message(
          "User-defined country replacement ",
          sQuote(ccode_replacement_luh2[r, "source"]), " -> ",
          sQuote(ccode_replacement_luh2[r, "replacement"]),
          "(",
          sQuote(country_group_data[replacement_r, country_group_name_col]),
          ")"
        )
        pattern_admin_raster <- mask(
          pattern_admin_raster,
          pattern_admin_raster,
          maskvalue = ccode_replacement_luh2[r, "source"],
          updatevalue = ccode_replacement_luh2[r, "replacement"]
        )
      }
    }
  }
  # Check country codes in admin unit mask again
  ccodes <- na.omit(unique(values(pattern_admin_raster)))
  if (!all(ccodes %in% country_group_data[, pattern_country_grouping_col]) &&
    fertilizer_trend_admin != fertilizer_pattern_admin
  ) {
    # Cannot ensure that all admin units in fertilizer patterns can be matched
    # to an admin unit in trend data.
    stop(
      paste(
        "The following countries found in pattern_admin_raster need to be",
        "added to country_group_data via an entry in 'add_list_luh2'",
        "or need to be replaced by a different country code via an entry in",
        "'ccode_replacement_luh2':",
        toString(
          sQuote(
            setdiff(ccodes, country_group_data[, pattern_country_grouping_col])
          )
        )
      )
    )
  }
  rm(ccodes)
} else {
  stop(
    paste(
      "Unsupported fertilizer_pattern_admin", sQuote(fertilizer_pattern_admin),
      "without corresponding names file."
    )
  )
}

# Crop list
if (file.exists(mapping_file)) {
  cat("Crop type mapping loaded from", sQuote(mapping_file), "\n")
  crop_type_mapping <- read.csv(mapping_file, stringsAsFactors = FALSE)
} else {
  stop(
    paste(
      "Mapping file", mapping_file, "does not exist.",
      "\nPlease check fertilizer_setup.R"
    )
  )
}
# Convert any special characters to ASCII
for (table in c("country_group_data", "crop_type_mapping")) {
  if (exists(table)) {
    table_data <- get(table)
    for (col in colnames(table_data)) {
      if (typeof(table_data[, col]) == "character") {
        if (!all(stri_enc_isascii(table_data[, col]), na.rm = TRUE)) {
          # String has non-ASCII characters
          if (!all(stri_enc_isutf8(table_data[, col]), na.rm = TRUE)) {
            # String has non-UTF8 characters -> assume windows-1252 encoding and
            # convert to UTF-8
            message(
              "Converting column ", sQuote(col),
              " from windows-1252 to UTF-8 encoding in ",
              table
            )
            table_data[, col] <- stri_encode(
              table_data[, col],
              "windows-1252",
              "UTF-8"
            )
          }
          # Convert UTF-8 strings to ASCII strings, if necessary translating
          # special characters
          message(
            "Converting column ", sQuote(col),
            " from UTF-8 to ASCII encoding in ",
            table
          )
          table_data[, col] <- stri_encode(table_data[, col], "UTF-8", "UTF-8")
          table_data[, col] <- stri_trans_general(
            table_data[, col],
            "latin-ascii"
          )
        }
      }
    }
    assign(table, table_data)
    rm(table_data)
  }
}
################################################################################


################################################################################
## Process time series per nutrient and crop                                  ##
# Check nutrient availability for both trends and patterns. Only process
# nutrients for which patterns and trends are available.
if (!identical(
  sort(fertilizer_trend_nutrients),
  sort(fertilizer_pattern_nutrients)
)) {
  warning(
    "Nutrients for fertilizer patterns (",
    toString(fertilizer_pattern_nutrients),
    ") do not match nutrients for fertilizer trends (",
    toString(fertilizer_trend_nutrients),
    "). Processing: ",
    toString(
      intersect(fertilizer_pattern_nutrients, fertilizer_trend_nutrients)
    ),
    call. = FALSE,
    immediate. = TRUE
  )
}
if (length(fertilizer_pattern_refyear) != 1) {
  # Multiple reference years currently not supported by this script version.
  stop(
    paste(
      "Error: this script currently only supports fertilizer_pattern_refyear",
      "of length 1. You provided:",
      toString(fertilizer_pattern_refyear)
    )
  )
}
for (nut in intersect(
  fertilizer_pattern_nutrients,
  fertilizer_trend_nutrients
)) {
  # Determine crops
  cat("Nutrient:", nut, "\n")
  pattern_crops <- na.omit(crop_type_mapping[, fertilizer_pattern_map_col])
  pattern_crops <- unique(pattern_crops[which(nchar(pattern_crops) > 0)])
  trend_crops <- na.omit(crop_type_mapping[, fertilizer_trend_map_col])
  trend_crops <- unique(trend_crops[which(nchar(trend_crops) > 0)])
  # Check that each pattern_crop has corresponding trend_crop
  p_rows <- match(
    pattern_crops,
    crop_type_mapping[, fertilizer_pattern_map_col]
  )
  crop_mismatch <- which(
    is.na(crop_type_mapping[p_rows, fertilizer_trend_map_col]) |
    !crop_type_mapping[p_rows, fertilizer_trend_map_col] %in% trend_crops
  )
  if (length(crop_mismatch) > 0) {
    warning(
      "No corresponding crop trend available for crop(s)",
      toString(sQuote(pattern_crops[crop_mismatch])),
      ". Please check crop_type_mapping in ",
      mapping_file,
      call. = FALSE,
      immediate. = TRUE
    )
  }
  cat(
    "Processing", length(pattern_crops), "crops",
    ifelse(num_cluster > 1, paste("on", num_cluster, "CPUs\n"), "\n")
  )
  crop_loop <- foreach(
    pcrop = pattern_crops,
    .inorder = FALSE,
    .combine = c
  ) %dopar% {
    # Log gap-filling into temporary file
    logfile <- tempfile(
      paste0(pcrop, nut, "_"),
      tmpdir = getwd(),
      fileext = ".txt"
    )
    fp <- file(logfile, "wt")
    sink(fp, type = "output")
    sink(fp, type = "message")
    # Determine working directories for gap-filled patterns.
    tmp_res <- ifelse(pattern_admin_res < 1 / 60, 3600, 60) *
      pattern_admin_res
    tmp_string <- paste(
      unique(round(tmp_res)),
      unique(ifelse(pattern_admin_res < 1 / 60, "sec", "min")),
      sep = "",
      collapse = "_by_"
    )
    working_dir_pattern <- file.path("tmp", paste0("work_", tmp_string))
    rm(tmp_res, tmp_string)
    if (!fertilizer_pattern_admin_resmatch || !dir.exists(working_dir_pattern)) {
      # If resolution of fertilizer patterns does not correspond to resolution
      # of admin unit dataset determine working directory from source
      # resolutions.
      # File names of source data files. Expected pattern used in Mueller et al.
      # dataset: [CROP][NUTRIENT]apprate.nc
      tmp_filenames <- file.path(
        fertilizer_pattern_dir,
        paste0(pcrop, nut, "apprate.nc")
      )
      tmp_filenames <- tmp_filenames[which(file.exists(tmp_filenames))]
      if (length(tmp_filenames) > 0) {
        tmp_raster <- raster(tmp_filenames[1], band = 1)
        # Note: If different crops have different resolutions you need to save
        # a backup copy of pattern_admin_raster here and restore it after this
        # crop has finished processing.
        pattern_admin_raster <- match_admin_to_data(
          tmp_raster,
          pattern_admin_raster,
          fun = modal_ties_first,
          verbose = TRUE
        )
        rm(tmp_raster)
        # Update resolution and working_dir_pattern
        pattern_admin_res <- res(pattern_admin_raster)
        tmp_res <- ifelse(pattern_admin_res < 1 / 60, 3600, 60) *
          pattern_admin_res
        tmp_string <- paste(
          unique(round(tmp_res)),
          unique(ifelse(pattern_admin_res < 1 / 60, "sec", "min")),
          sep = "",
          collapse = "_by_"
        )
        working_dir_pattern <- file.path("tmp", paste0("work_", tmp_string))
        rm(tmp_res, tmp_string)
      } else {
        # Cannot use stop() in foreach loop
        message(
          "Error: Cannot determine working directory for gap-filled patterns",
          " automatically and no matching crop pattern source file found in ",
          fertilizer_pattern_dir,
          ". Skipping ", sQuote(pcrop)
        )
        # Stop logging to temporary file.
        sink(type = "output")
        sink(type = "message")
        close(fp)
        return(NULL)
      }
    }
    cat("***", pcrop, "***\n")
    # Gap-filled pattern file
    # Expected filename pattern: 
    # [CROP][NUTRIENT]apprate_[ADMIN_DATASET]_[national|subnational].nc
    pattern_filename <- file.path(
      working_dir_pattern,
      paste0(
        pcrop, nut, "apprate_",
        fertilizer_pattern_admin,
        ifelse(
          fertilizer_pattern_is_national,
          "_national",
          "_subnational"
        ),
        ".nc"
      )
    )
    # Expected variable name
    pattern_varname <- paste0(pcrop, nut, "apprate")
    if (file.exists(pattern_filename)) {
      # Corresponding crop for trend
      p_row <- match(pcrop, crop_type_mapping[, fertilizer_pattern_map_col])
      tcrop <- crop_type_mapping[p_row, fertilizer_trend_map_col]
      # Working directory for fertilizer trend data
      tmp_res <- ifelse(trend_admin_res < 1 / 60, 3600, 60) *
        trend_admin_res
      tmp_string <- paste(
        unique(round(tmp_res)),
        unique(ifelse(trend_admin_res < 1 / 60, "sec", "min")),
        sep = "",
        collapse = "_by_"
      )
      working_dir_trend <- file.path("tmp", paste0("work_", tmp_string))
      rm(tmp_res, tmp_string)
      if (!fertilizer_trend_admin_resmatch || !dir.exists(working_dir_trend)) {
        # If resolution of fertilizer trends does not correspond to resolution
        # of admin unit dataset determine working directory from source
        # resolutions. File names of source data files.
        if(!is.null(fertilizer_trend_src_name)) {
          tmp_filename <- fertilizer_trend_src_name
          trend_varname <- paste0("fertl_", tcrop)
        } else {
          stop(
            paste(
              "You have not specified a filename for fertilizer trends",
              "source data. Please supply fertilizer_trend_src_name in",
              "fertilizer_setup.R or add logic to determine filename to this",
              "script."
            )
          )
        }
        if (file.exists(tmp_filename)) {
          tmp_raster <- raster(tmp_filename, varname = trend_varname, band = 1)
          # Note: If different crops have different resolutions you need to save
          # a backup copy of trend_admin_raster here and restore it after this
          # crop has finished processing.
          trend_admin_raster <- match_admin_to_data(
            tmp_raster,
            trend_admin_raster,
            fun = modal_ties_first,
            verbose = TRUE
          )
          rm(tmp_raster)
          # Update resolution and working_dir_trend
          trend_admin_res <- res(trend_admin_raster)
          tmp_res <- ifelse(trend_admin_res < 1 / 60, 3600, 60) *
            trend_admin_res
          tmp_string <- paste(
            unique(round(tmp_res)),
            unique(ifelse(trend_admin_res < 1 / 60, "sec", "min")),
            sep = "",
            collapse = "_by_"
          )
          working_dir_trend <- file.path("tmp", paste0("work_", tmp_string))
          rm(tmp_res, tmp_string)
        } else {
          # Cannot use stop() in foreach loop
          message(
            "Error: Cannot determine working directory for gap-filled trends",
            " automatically and source data file for trend data ",
            tmp_filename, " not found.\n",
            "Skipping", sQuote(pcrop)
          )
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
      }
      trend_filename <- file.path(
        working_dir_trend,
        paste0(
          tcrop, nut, "_relative_ts_",
          fertilizer_trend_admin,
          ifelse(
            fertilizer_trend_is_national,
            "_national",
            "_subnational"
          ),
          ".RData"
        )
      )
      if (file.exists(trend_filename)) {
        cat("Corresponding trend taken from", sQuote(tcrop), "\n")
        # Load pattern
        pattern_nc <- nc_open(pattern_filename)
        try(
          pattern_years <- nc_file_years(pattern_nc)
        )
        if (class(pattern_years) == "try-error") {
          # Error occurred determining file years.
          nc_close(file_nc)
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
        pattern_unit <- ncatt_get(pattern_nc, pattern_varname, "units")
        nc_close(pattern_nc)
        if (!all(fertilizer_pattern_refyear %in% pattern_years)) {
          # Cannot use stop() in foreach loop
          message(
            "Error: reference year(s) ",
            toString(setdiff(fertilizer_pattern_refyear, pattern_years)),
            " missing in pattern file ", pattern_filename
          )
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
        # This part only works for single fertilizer_pattern_refyear
        pattern_ref <- raster(
          pattern_filename,
          varname = pattern_varname,
          band = which(pattern_years == fertilizer_pattern_refyear)
        )
        if (extent(pattern_ref) != extent(pattern_admin_raster) ||
          any(res(pattern_ref) != res(pattern_admin_raster))
        ) {
          # Unexpected error. Cannot use stop() in foreach loop
          message(
            "Error: spatial mismatch between pattern_ref and",
            " pattern_admin_raster.\n",
            "Have you changed pattern_admin_raster between",
            " gap-filling and now? This should not happen."
          )
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
        # Load trend data
        load(trend_filename)
        trend_years <- as.integer(dimnames(gapfilled_ts)[[1]])
        # Try to harmonize admin codes used in pattern and trend data
        pattern_vals <- values(pattern_admin_raster)
        # Unique admin unit codes in pattern_admin_raster
        pattern_ccodes <- na.omit(unique(pattern_vals))
        if (!is.null(pattern_admin_names)) {
          iso_r <- match(pattern_ccodes, pattern_admin_names[, pattern_id_col])
          pattern_isocodes <- pattern_admin_names[iso_r, pattern_iso_col]
        } else {
          # Use country_group_data to translate to ISO codes
          iso_r <- match(
            pattern_ccodes,
            country_group_data[, pattern_country_grouping_col]
          )
          pattern_isocodes <- country_group_data[iso_r, country_group_iso3_col]
        }
        if (is.null(trend_admin_names)) {
          # Replace country codes used for trend data with ISO codes
          trend_ccodes <- dimnames(gapfilled_ts)[[2]]
          if (!all(
            trend_ccodes %in% country_group_data[, trend_country_grouping_col] |
            trend_ccodes %in% pattern_admin_replacement$replacement
          )) {
            warning(
              "Gap-filled trend data contains countries not ",
              "available in country_group_data. These cannot be used:\n",
              toString(
                sQuote(
                  setdiff(
                    trend_ccodes,
                    country_group_data[, trend_country_grouping_col]
                  )
                )
              ),
              call. = FALSE,
              immediate. = TRUE
            )
            # Only keep country codes that can be translated into ISO codes.
            keep_ccodes <- intersect(
              trend_ccodes,
              country_group_data[, trend_country_grouping_col]
            )
            gapfilled_ts <- gapfilled_ts[, keep_ccodes, drop = FALSE]
          }
          # Rename country codes to ISO codes.
          iso_r <- match(
            dimnames(gapfilled_ts)[[2]],
            country_group_data[, trend_country_grouping_col]
          )
          dimnames(gapfilled_ts)[[2]] <-
            country_group_data[iso_r, country_group_iso3_col]
          # Same for gapfilled_level
          trend_ccodes <- dimnames(gapfilled_level)[[2]]
          if (!all(
            trend_ccodes %in% country_group_data[, trend_country_grouping_col]
          )) {
            warning(
              "Gap-filling metadata for trend data contains ",
              "countries not available in country_group_data. ",
              "These cannot be used:\n",
              toString(
                sQuote(
                  setdiff(
                    trend_ccodes,
                    country_group_data[, trend_country_grouping_col]
                  )
                )
              ),
              call. = FALSE,
              immediate. = TRUE
            )
            # Only keep country codes that can be translated into ISO codes.
            keep_ccodes <- intersect(
              trend_ccodes,
              country_group_data[, trend_country_grouping_col]
            )
            gapfilled_level <- gapfilled_level[, keep_ccodes, drop = FALSE]
          }
          # Rename country codes to ISO codes.
          iso_r <- match(
            dimnames(gapfilled_level)[[2]],
            country_group_data[, trend_country_grouping_col]
          )
          dimnames(gapfilled_level)[[2]] <-
            country_group_data[iso_r, country_group_iso3_col]
          # Select codes from gapfilled_ts, should normally be identical
          gapfilled_level <- gapfilled_level[, dimnames(gapfilled_ts)[[2]]]
          # Same for gapfilled_sources
          trend_ccodes <- dimnames(gapfilled_sources)[[2]]
          if (!all(
            trend_ccodes %in% country_group_data[, trend_country_grouping_col]
          )) {
            warning(
              "Gap-filling metadata for trend data contains ",
              "countries not available in country_group_data. ",
              "These cannot be used:\n",
              toString(
                sQuote(
                  setdiff(
                    trend_ccodes,
                    country_group_data[, trend_country_grouping_col]
                  )
                )
              ),
              call. = FALSE,
              immediate. = TRUE
            )
            # Only keep country codes that can be translated into ISO codes.
            keep_ccodes <- intersect(
              trend_ccodes,
              country_group_data[, trend_country_grouping_col]
            )
            gapfilled_sources <-
              gapfilled_sources[, keep_ccodes, drop = FALSE]
          }
          # Rename country codes to ISO codes.
          iso_r <- match(
            dimnames(gapfilled_sources)[[2]],
            country_group_data[, trend_country_grouping_col]
          )
          dimnames(gapfilled_sources)[[2]] <-
            country_group_data[iso_r, country_group_iso3_col]
          # Select codes from gapfilled_ts, should normally be identical
          gapfilled_sources <-
            gapfilled_sources[, dimnames(gapfilled_ts)[[2]]]
        }
        trend_isocodes <- dimnames(gapfilled_ts)[[2]]
        # Pattern ISO codes missing in trend data
        iso_mismatch <- setdiff(pattern_isocodes, trend_isocodes)
        # Check if these can be filled with pattern_admin_replacement rules
        valid_replacement <- intersect(
          pattern_admin_replacement$replacement,
          trend_isocodes
        )
        iso_r <- which(
          pattern_admin_replacement$replacement %in% valid_replacement
        )
        iso_mismatch <- setdiff(
          iso_mismatch,
          pattern_admin_replacement[iso_r, "source"]
        )
        if (length(iso_mismatch) > 0) {
          warning(
            length(iso_mismatch),
            ifelse(length(iso_mismatch) > 1, " countries", " country"),
            " in pattern_admin_raster without corresponding data in",
            " trend time series and without country replacement rule.",
            " Attempting to gap-fill.",
            call. = FALSE,
            immediate. = TRUE
          )
          gapfilled_data <- gapfill_country_trend(
            gapfilled_ts,
            gapfilled_level,
            gapfilled_sources,
            max_national_fill_level = trend_unit_levels + 1,
            add_list = iso_mismatch,
            country_grouping = country_group_data,
            country_grouping_col = country_group_iso3_col,
            # Dummy level value assigned in gapfill_fertilizer_trend.R when no
            # country has non-zero fertilizer rate.
            global_fill_code <- -1,
            assign_country_threshold = fertilizer_trend_assign_country_threshold
          )
        } else if (
          anyNA(gapfilled_ts[, intersect(pattern_isocodes, trend_isocodes)])
        ) {
          warning(
            length(
              which(
                is.na(gapfilled_ts[, intersect(pattern_isocodes, trend_isocodes)])
              )
            ),
            " missing value(s) in gapfilled_ts.",
            " This should not normally happen.",
            " Please check diagnostics output by gapfill_fertilizer_trend.R",
            call. = FALSE,
            immediate. = TRUE
          )
          gapfilled_data <- gapfill_country_trend(
            gapfilled_ts,
            gapfilled_level,
            gapfilled_sources,
            max_national_fill_level = trend_unit_levels + 1,
            add_list = character(0),
            country_grouping = country_group_data,
            country_grouping_col = country_group_iso3_col,
            # Dummy level value assigned in gapfill_fertilizer_trend.R when no
            # country has non-zero fertilizer rate.
            global_fill_code <- -1,
            assign_country_threshold = fertilizer_trend_assign_country_threshold
          )
        }
        if (exists("gapfilled_data") &&
          !identical(gapfilled_data$data_ts, gapfilled_ts)
        ) {
          # Save gap-filled data to file because, by default, several crop
          # fertilizer patterns use the same crop trend.
          # First back up original data
          bak_trend_filename <- paste0(
            file_path_sans_ext(trend_filename), "_",
            Sys.Date(),
            ".", file_ext(trend_filename),
            ".bak"
          )
          if (num_cluster > 1) {
            # Wait a moment to avoid parallel tasks trying to copy
            # simultaneously.
            Sys.sleep(which(pattern_crops == pcrop))
          }
          if (!file.exists(bak_trend_filename)) {
            tmp_envir <- new.env()
            if (is.null(trend_admin_names)) {
              # Need to restore original admin unit codes used in trend data
              iso_r <- match(
                trend_isocodes,
                country_group_data[, country_group_iso3_col]
              )
              ccode <- country_group_data[iso_r, trend_country_grouping_col]
              tmp_envir$gapfilled_ts <- gapfilled_ts[, which(!is.na(ccode))]
              tmp_envir$gapfilled_level <-
                gapfilled_level[, which(!is.na(ccode))]
              tmp_envir$gapfilled_sources <-
                gapfilled_sources[, which(!is.na(ccode))]
              dimnames(tmp_envir$gapfilled_ts)[[2]] <- na.omit(ccode)
              dimnames(tmp_envir$gapfilled_level)[[2]] <- na.omit(ccode)
              dimnames(tmp_envir$gapfilled_sources)[[2]] <- na.omit(ccode)
            } else {
              tmp_envir$gapfilled_ts <- gapfilled_ts
              tmp_envir$gapfilled_level <- gapfilled_level
              tmp_envir$gapfilled_sources <- gapfilled_sources
            }
            save(
              gapfilled_ts,
              gapfilled_level,
              gapfilled_sources,
              file = bak_trend_filename,
              envir = tmp_envir
            )
            rm(tmp_envir)
            cat(
              "Backup of original time series saved to",
              sQuote(bak_trend_filename), "\n"
            )
          }
          # Replace original data with gap-filled versions.
          gapfilled_ts <- gapfilled_data$data_ts
          gapfilled_level <- gapfilled_data$data_level
          gapfilled_sources <- gapfilled_data$data_sources
          trend_isocodes <- dimnames(gapfilled_ts)[[2]]
          cat("Updating fertilizer trend time series in", trend_filename, "\n")
          tmp_envir <- new.env()
          if (is.null(trend_admin_names)) {
            # Need to restore original admin unit codes used in trend data
            iso_r <- match(
              trend_isocodes,
              country_group_data[, country_group_iso3_col]
            )
            ccode <- country_group_data[iso_r, trend_country_grouping_col]
            tmp_envir$gapfilled_ts <- gapfilled_ts[, which(!is.na(ccode))]
            tmp_envir$gapfilled_level <- gapfilled_level[, which(!is.na(ccode))]
            tmp_envir$gapfilled_sources <-
              gapfilled_sources[, which(!is.na(ccode))]
            dimnames(tmp_envir$gapfilled_ts)[[2]] <- na.omit(ccode)
            dimnames(tmp_envir$gapfilled_level)[[2]] <- na.omit(ccode)
            dimnames(tmp_envir$gapfilled_sources)[[2]] <- na.omit(ccode)
          } else {
            tmp_envir$gapfilled_ts <- gapfilled_ts
            tmp_envir$gapfilled_level <- gapfilled_level
            tmp_envir$gapfilled_sources <- gapfilled_sources
          }
          save(
            gapfilled_ts,
            gapfilled_level,
            gapfilled_sources,
            file = trend_filename,
            envir = tmp_envir
          )
          rm(tmp_envir)
        }
        rm(list = intersect("gapfilled_data", ls()))
        # Output years
        ts_output_years <- c(
          max(min(trend_years), min(output_period)),
          min(max(trend_years), max(output_period))
        )
        if (!all(seq(min(output_period), max(output_period)) %in% trend_years)) {
          missing_years <- setdiff(
            seq(min(output_period), max(output_period)),
            trend_years
          )
          warning(
            "Trend data from ", sQuote(trend_filename),
            " does not fully cover requested output_period ",
            paste(output_period, collapse = "-"),
            ".\nRealized output period: ",
            paste(ts_output_years, collapse = "-"),
            ifelse(
              length(missing_years) > 0,
              paste0(" (missing", toString(missing_years), ")"),
              ""
            ),
            call. = FALSE,
            immediate. = TRUE
          )
        }
        if (!all(ts_output_years %in% trend_years)) {
          # Cannot have gaps in time series. Cannot use stop() in foreach loop.
          message(
            "Error: trend time series gapfilled_ts has gaps. ",
            "Missing year(s): ",
            toString(setdiff(ts_output_years, trend_years)),
            ". Make sure that gapfilled_ts covers all years in requested ",
            "output period. Skipping ", sQuote(pcrop)
          )
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
        y <- as.character(ts_output_years)
        if (
          anyNA(gapfilled_ts[y, intersect(pattern_isocodes, trend_isocodes)])
        ) {
          message(
            "Error: ",
            length(
              which(
                is.na(
                  gapfilled_ts[y, intersect(pattern_isocodes, trend_isocodes)]
                )
              )
            ),
            " missing values in country trend time series after gap-filling.",
            " Make sure that gap-filling of trend data creates complete time",
            " series for all required crops, countries and years.\n",
            "Skipping ", sQuote(pcrop)
          )
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
        rm(y)
        # Generate list with all cells per admin unit in pattern data
        pattern_admin_celllist <- list()
        for (isocode in pattern_isocodes) {
          # Corresponding code in pattern_admin_raster
          ccode <- pattern_ccodes[which(pattern_isocodes == isocode)]
          # Check for replacement rules
          if (isocode %in% pattern_admin_replacement$source) {
            iso_r <- match(isocode, pattern_admin_replacement$source)
            if (pattern_admin_replacement$replacement[iso_r] %in%
              trend_isocodes
            ) {
              # Assign cells to ISO code of replacement country
              isocode <- pattern_admin_replacement$replacement[iso_r]
            }
          }
          # Country replacement may have set several codes in
          # pattern_admin_raster to the same ISO replacement code.
          if (is.null(pattern_admin_celllist[[isocode]])) {
            pattern_admin_celllist[[isocode]] <- which(pattern_vals == ccode)
          } else {
            # Add to existing ISO entry.
            pattern_admin_celllist[[isocode]] <- union(
              pattern_admin_celllist[[isocode]],
              which(pattern_vals == ccode)
            )
          }
        }
        # Consistency checks.
        # 1. All admin units in pattern_admin_celllist have trends in trend data
        if (!all(names(pattern_admin_celllist) %in% trend_isocodes)) {
          iso_mismatch <- setdiff(names(pattern_admin_celllist), trend_isocodes)
          iso_r <- match(
            iso_mismatch,
            country_group_data[, country_group_iso3_col]
          )
          message(
            "Error: no trend available for the following admin unit(s):"
          )
          print(
            data.frame(
              ISO = iso_mismatch,
              name = country_group_data[iso_r, country_group_name_col]
            )
          )
          message(
            "Gap-filling and country replacement rules were not successful ",
            "in securing trends for all countries.\nSkipping ", sQuote(pcrop)
          )
          rm(iso_mismatch, iso_r)
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
        # 2. All non-missing cells in pattern_admin_raster are assigned to
        # exactly one admin unit.
        if (length(unlist(pattern_admin_celllist)) !=
          length(unique(unlist(pattern_admin_celllist)))
        ) {
          freq <- data.frame(table(unlist(pattern_admin_celllist)))
          multiple_factor <- freq[which(freq$Freq > 1), "Var1"]
          multiple_cellindex <- as.integer(
            levels(multiple_factor)[multiple_factor]
          )
          multiple_ccode <- pattern_vals[multiple_cellindex]
          multiple_iso <- pattern_isocodes[match(multiple_ccode, pattern_ccodes)]
          message(
            "Error: ", length(multiple_factor),
            " cell(s) assigned more than once in ",
            length(multiple_iso), " country/countries.\nSkipping ",
            sQuote(pcrop)
          )
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
        if (
          !all(which(!is.na(pattern_vals)) %in% unlist(pattern_admin_celllist))
        ) {
          missing_cells <- setdiff(
            which(!is.na(pattern_vals)),
            unlist(pattern_admin_celllist)
          )
          message(
            "Error: ", length(missing_cells), " cell(s) from ",
            "pattern_admin_raster not assigned to any country in ",
            "pattern_admin_celllist.\nSkipping ", sQuote(pcrop)
          )
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
        # Set up NetCDF file for crop time series
        output_filename <- file.path(
          working_dir_pattern,
          paste0(
            pcrop, nut, "_timeseries_pattern_",
            fertilizer_pattern_admin,
            ifelse(fertilizer_pattern_is_national, "_national", "_subnational"),
            "_trend_",
            fertilizer_trend_admin,
            ifelse(
              fertilizer_trend_is_national,
              "_national_",
              "_subnational_"
            ),
            paste(ts_output_years, collapse = "-"),
            ".nc"
          )
        )
        cat("Setting up output file", sQuote(output_filename), "\n")
        if (!pattern_unit$hasatt) {
          if (exists("fertilizer_pattern_unit") &&
            !is.null(fertilizer_pattern_unit) &&
            nchar(fertilizer_pattern_unit) > 0
          ) {
            warning(
              "Unit not set in ", sQuote(pattern_filename),
              ", assuming fertilizer_pattern_unit set in fertilizer_setup.R ",
              sQuote(fertilizer_pattern_unit),
              call. = FALSE,
              immediate. = TRUE
            )
            pattern_unit$value <- fertilizer_pattern_unit
          } else {
            warning(
              "Unit not set in ", sQuote(pattern_filename),
              " and no fertilizer_pattern_unit defined in fertilizer_setup.R",
              call. = FALSE,
              immediate. = TRUE
            )
            pattern_unit$value <- ""
          }
        } else if (pattern_unit$value != fertilizer_pattern_unit) {
          warning(
            "Unit set in ", pattern_filename, " ",
            sQuote(pattern_unit$value),
            " does not match fertilizer_pattern_unit ",
            sQuote(fertilizer_pattern_unit),
            " defined in fertilizer_setup.R.\n",
            "Please make sure to set correct unit.",
            call. = FALSE,
            immediate. = TRUE
          )
        }
        lon_dim <- ncdim_def(
          name = "longitude",
          units = "degrees_east",
          vals = xFromCol(pattern_admin_raster),
          longname = "longitude"
        )
        lat_dim <- ncdim_def(
          name = "latitude",
          units = "degrees_north",
          vals = yFromRow(pattern_admin_raster),
          longname = "latitude"
        )
        time_dim <- ncdim_def(
          name = "time",
          units = "year",
          vals = seq(min(ts_output_years), max(ts_output_years)),
          unlim = TRUE
        )
        fert_var <- ncvar_def(
          name = paste0(pcrop, nut, "_timeseries"),
          units = pattern_unit$value,
          dim = list(lon_dim, lat_dim, time_dim),
          missval = missval_float,
          longname = paste(
            nut,
            "fertilizer application rate time series for",
            pcrop
          ),
          compression = 5
        )
        # Create output file
        output_nc <- nc_create(output_filename, fert_var)
        ncatt_put(
          output_nc,
          paste0(pcrop, nut, "_timeseries"),
          "missing_value",
          missval_float,
          prec = "float"
        )
        nc_sync(output_nc)
        # Load spatial pattern into memory to speed up processing.
        if (!inMemory(pattern_ref)) {
          pattern_ref <- readAll(pattern_ref)
        }
        for (year in seq(min(ts_output_years), max(ts_output_years))) {
          cat("+", year, "+\n")
          yeardata <- double(length(pattern_vals))
          yeardata[] <- NA
          for (country in names(pattern_admin_celllist)) {
            yeardata[pattern_admin_celllist[[country]]] <-
              pattern_ref[pattern_admin_celllist[[country]]] *
              gapfilled_ts[as.character(year), country]
          }
          writedata <- as.double(yeardata)
          writedata[which(is.na(writedata))] <- missval_float
          ncvar_put(
            output_nc,
            paste0(pcrop, nut, "_timeseries"),
            writedata,
            start = c(1, 1, which(time_dim$vals == year)),
            count = c(-1, -1, 1)
          )
          rm(writedata, yeardata)
        }
        # Close output NetCDF
        nc_close(output_nc)
      } else {
        warning(
          "*** File containing corresponding trend ",
          trend_filename, " not found.\nSkipping ", sQuote(pcrop), " ***",
          call. = FALSE,
          immediate. = TRUE
        )
        # Stop logging to temporary file.
        sink(type = "output")
        sink(type = "message")
        close(fp)
        return(NULL)
      }
    } else {
      warning(
        "*** Fertilizer pattern file ", pattern_filename,
        " not found.\nSkipping ", sQuote(pcrop), " ***",
        call. = FALSE,
        immediate. = TRUE
      )
      # Stop logging to temporary file.
      sink(type = "output")
      sink(type = "message")
      close(fp)
      return(NULL)
    }
    # Stop logging to temporary file.
    sink(type = "output")
    sink(type = "message")
    close(fp)
    # Move gap-fill log file to location of NetCDF file.
    logfile_final <- file.path(
      working_dir_pattern,
      paste0(
        pcrop, nut, "_timeseries_pattern_",
        fertilizer_pattern_admin,
        ifelse(fertilizer_pattern_is_national, "_national", "_subnational"),
        "_trend_", fertilizer_trend_admin,
        ifelse(fertilizer_trend_is_national, "_national_",  "_subnational_"),
        paste(ts_output_years, collapse = "-"),
        ".log"
      )
    )
    file.rename(logfile, logfile_final)
    pcrop
  }
  if (length(crop_loop) != length(pattern_crops)) {
    warning(
      "Time series or the following crops could not be created for ",
      "nutrient ", sQuote(nut), ": ",
      toString(sQuote(setdiff(pattern_crops, crop_loop))),
      call. = FALSE,
      immediate. = TRUE
    )
  } else {
    cat(
      "Time series for", length(pattern_crops),
      "crops processed successfully for nutrient", sQuote(nut), "\n"
    )
  }
}
################################################################################


################################################################################
## If running in parallel mode do some clean-up.                              ##
if (parallel_mpi) {
  # Release linked R instances and close MPI cluster.
  doMPI::closeCluster(cl)
  Rmpi::mpi.quit()
}
if (parallel_local) {
  # Release parallel cluster
  parallel::stopCluster(cl)
}
################################################################################
