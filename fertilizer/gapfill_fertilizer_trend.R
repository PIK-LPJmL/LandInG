################################################################################
## Copyright (C) 2022 Potsdam Institute for Climate Impact Research (PIK),    ##
## see COPYRIGHT file.                                                        ##
##                                                                            ##
## This file is part of LandInG and licensed under GNU AGPL Version 3 or      ##
## later. See LICENSE file or go to http://www.gnu.org/licenses/              ##
## Contact: https://github.com/PIK-LPJmL/LandInG/                             ##
################################################################################

################################################################################
## This script can be used to fill gaps in the spatial patterns of fertilizer ##
## trends that may result from cropland patterns used in the creation of the  ##
## source dataset. It will ensure that fertilizer patterns contain            ##
## non-missing values in all cells with land according to the land mask.      ##
## Gap-filling is carried out either at the national scale if                 ##
## fertilizer_trend_is_national == TRUE or at the subnational scale using     ##
## level-2 administrative units as smallest units.                            ##
## Script run can be parallelized to speed up processing of crops. The        ##
## parallelization mechanism is implemented through foreach which has         ##
## backends for several parallelization mechanisms. This script has options   ##
## for the doMPI backend (using MPI) and the doParallel backend. Further      ##
## backends are possible. The example below may not work on your system. Try  ##
## to adjust parameters or set "cluster <- FALSE" to switch off               ##
## parallelization and run in sequential mode.                                ##
################################################################################

# Clean up memory
rm(list = ls(all = TRUE))

################################################################################
## Setup of variables valid across all scripts related to fertilizer data     ##
## processing.                                                                ##
## - sets many directories and file names                                     ##
source("fertilizer_setup.R")
## Try parallelization                                                        ##
cluster <- TRUE
## Missing value used in NetCDF files generated by this script.               ##
missval_float <- 1e20
missval_integer <- -5
################################################################################


################################################################################
## Trying to set up cluster using MPI interface or doParallel.                ##
## The implementation using the MPI interface has been developed for a high   ##
## performance cluster. If Rmpi and doMPI are installed and cluster == TRUE   ##
## the script tries to use this combination of packages.                      ##
## If Rmpi is not available but cluster == TRUE the script attempts to use    ##
## parallelization through the "parallel" package and doParallel.             ##
##                                                                            ##
## This part may need to be tweaked for your system set up.                   ##
parallel_mpi <- parallel_local <- FALSE # Not to be set by user
if (cluster) {
  # Try parallelization
  if (require(Rmpi)) {
    # Rmpi = R implementation of MPI interface
    # This is intended for parallelization on high-performance cluster.
    # It does not make sense to request more CPUs than number of crops + 1.
    if (require(doMPI)) {
      # doMPI = interface for foreach construct to run in MPI parallel mode
       # Start MPI cluster (link R instances together)
      cl <- doMPI::startMPIcluster()
      # Number of R instances linked together
      num_cluster <- doMPI::clusterSize(cl)
      if (num_cluster > 1) {
        # Script is using more than 1 CPU, so really run in parallel mode
        # Tell foreach to use MPI backend for parallelization
        doMPI::registerDoMPI(cl)
        cat("Running in parallel mode on", num_cluster, "worker nodes.\n")
        parallel_mpi <- TRUE
      } else {
        # Only one task
        # Tell foreach to use sequential mode
        registerDoSEQ()
        cat("Running in sequential mode because only one node is available.\n")
        num_cluster <- 1
      }
    } else {
      # doMPI package is missing
      warning(
        "It seems that you have Rmpi installed. This script requires ",
        "both Rmpi and doMPI package to run in parallel mode.",
        call. = FALSE,
        immediate. = TRUE
      )
      registerDoSEQ() # Tell foreach to use sequential mode
      cat("Falling back to running in sequential mode.\n")
      num_cluster <- 1
    }
  } else if (require(doParallel)) {
    # Try parallelization through parallel package.
    # This is probably more suitable to run in parallel on a local machine
    # Get number of CPU cores
    ncores <- parallel::detectCores()
    # It is probably a good idea not to use all CPUs on your computer.
    # The number of usable CPUs may also be limited by the memory requirement
    # of each task. Test thoroughly in order not to cripple your system.
    # For this script it does not make sense to request more CPUs than number of
    # crops.
    if (is.finite(ncores)) {
      num_cluster <- ceiling(ncores / 2)
    } else {
      # parallel::detectCores() could not detect number of CPUs. Fall back to 1.
      num_cluster <- 1
    }
    if (num_cluster > 1) {
      # Start cluster on local machine
      cl <- parallel::makeCluster(num_cluster)
      # Tell foreach to use this cluster
      registerDoParallel(num_cluster)
      parallel_local <- TRUE
      cat("Running in parallel mode on", num_cluster, "CPUs\n")
    } else {
      # Only one task
      registerDoSEQ() # Tell foreach to use sequential mode
      cat("Running in sequential mode because only one CPU is available.\n")
    }
  } else {
    # Rmpi and doParallel package are missing
    warning(
      "This script requires Rmpi and doMPI or ",
      "parallel and doParallel to run in parallel mode.\n",
      "Please install missing packages or set cluster to FALSE.",
      call. = FALSE,
      immediate. = TRUE
    )
    registerDoSEQ() # Tells foreach to use sequential mode
    cat("Falling back to running in sequential mode.\n")
    num_cluster <- 1
  }
} else {
  # Do not try parallelization
  library(foreach)
  registerDoSEQ() # Tells foreach to use sequential mode
  cat("Running in sequential mode.\n")
  num_cluster <- 1
}
################################################################################


################################################################################
## Load spatial units                                                         ##
if (fertilizer_trend_admin == "gadm") {
  cat("Admin units loaded from", sQuote(gadmlevel_file), "\n")
  trend_admin_raster <- brick(gadmlevel_file)
  trend_admin_names <- read.csv(
    gadmlevel_names_file,
    stringsAsFactors = FALSE,
    comment.char = "#"
  )
  # Check spatial extent of GADM units
  if (matching_extent(
    extent(trend_admin_raster),
    global_extent,
    xres(trend_admin_raster),
    yres(trend_admin_raster)
  )) {
    trend_admin_raster <- setExtent(trend_admin_raster, global_extent)
  }
  # Number of countries in each cell used to determine border cells
  trend_border_raster <- brick(gadmborder_file)
  # Check spatial extent of border raster
  if (matching_extent(
    extent(trend_border_raster),
    global_extent,
    xres(trend_border_raster),
    yres(trend_border_raster)
  )) {
    trend_border_raster <- setExtent(trend_border_raster, global_extent)
  }
  # Column name in country grouping that contains matching codes
  country_grouping_col <- gadm_country_col
  # Find column containing 3-letter ISO code in trend_admin_names
  iso_col <- grep(
    "level0.code",
    colnames(trend_admin_names),
    ignore.case = TRUE,
  )
  if (length(iso_col) != 1) {
    stop("Error finding country ISO code column in trend_admin_names")
  }
  # Find column containing country IDs
  code_col <- grep(
    "level0.id",
    colnames(trend_admin_names),
    ignore.case = TRUE,
  )
  if (length(code_col) != 1) {
    stop("Error finding country ID column in trend_admin_names")
  }
} else if (fertilizer_trend_admin == "luh2") {
  cat("Admin units loaded from", sQuote(luh2country_file), "\n")
  trend_admin_raster <- brick(
    luh2country_file,
    varname = luh2country_variable,
    band = luh2country_layer
  )
  # No corresponding names or border file.
  trend_admin_names <- NULL
  trend_border_raster <- NULL
  country_grouping_col <- luh2_country_col
  # No names, therefore no columns with IDs and ISO codes
  iso_col <- NULL
  code_col <- NULL
} else {
  stop(
    paste(
      "Undefined fertilizer_trend_admin", sQuote(fertilizer_trend_admin),
      "\nCheck fertilizer_setup.R"
    )
  )
}
if (fertilizer_trend_is_national) {
  if (nlayers(trend_admin_raster) > 1) {
    print(
      paste(
        "Warning: You have specified that fertilizer trend data is national",
        "but have supplied admin data with",
        nlayers(trend_admin_raster),
        "levels. Subnational levels will be ignored."
      )
    )
  }
}
if (nlayers(trend_admin_raster) == 1) {
  # Reduce brick to raster layer in case of only one layer because single-layer
  # bricks cause problems in raster package code.
  trend_admin_raster <- subset(trend_admin_raster, 1)
}
if (!is.null(trend_border_raster) && nlayers(trend_border_raster) == 1) {
  # Reduce brick to raster layer in case of only one layer because single-layer
  # bricks cause problems in raster package code.
  trend_border_raster <- subset(trend_border_raster, 1)
}
  
if (!anyNA(values(trend_admin_raster)) && fertilizer_trend_strip_zero) {
  message(
    "Info: Admin data does not contain any NAs and ",
    "fertilizer_trend_strip_zero is TRUE. Replacing 0 with NA in admin data."
  )
  trend_admin_raster <- mask(
    trend_admin_raster,
    trend_admin_raster,
    maskvalue = 0
  )
}
################################################################################


################################################################################
## Load country grouping and crop list                                        ##
if (file.exists(country_group_file)) {
  cat("Country groups loaded from", sQuote(country_group_file), "\n")
  country_group_data <- read.csv(country_group_file, stringsAsFactors = FALSE)
} else {
  stop(
    paste(
      "Country groups file", country_group_file, "does not exist.",
      "\nPlease check fertilizer_setup.R"
    )
  )
}

if (file.exists(mapping_file)) {
  cat("Crop type mapping loaded from", sQuote(mapping_file), "\n")
  crop_type_mapping <- read.csv(mapping_file, stringsAsFactors = FALSE)
} else {
  stop(
    paste(
      "Mapping file", mapping_file, "does not exist.",
      "\nPlease check fertilizer_setup.R"
    )
  )
}

# Convert any special characters to ASCII
for (table in c("country_group_data", "crop_mapping")) {
  if (exists(table)) {
    table_data <- get(table)
    for (col in colnames(table_data)) {
      if (typeof(table_data[, col]) == "character") {
        if (!all(stri_enc_isascii(table_data[, col]), na.rm = TRUE)) {
          # String has non-ASCII characters
          if (!all(stri_enc_isutf8(table_data[, col]), na.rm = TRUE)) {
            # String has non-UTF8 characters -> assume windows-1252 encoding and
            # convert to UTF-8
            message(
              "Converting column ", sQuote(col),
              " from windows-1252 to UTF-8 encoding in ",
              table
            )
            table_data[, col] <- stri_encode(
              table_data[, col],
              "windows-1252",
              "UTF-8"
            )
          }
          # Convert UTF-8 strings to ASCII strings, if necessary translating
          # special characters
          message(
            "Converting column ", sQuote(col),
            " from UTF-8 to ASCII encoding in ",
            table
          )
          table_data[, col] <- stri_encode(table_data[, col], "UTF-8", "UTF-8")
          table_data[, col] <- stri_trans_general(
            table_data[, col],
            "latin-ascii"
          )
        }
      }
    }
    assign(table, table_data)
    rm(table_data)
  }
}
# Check that country_group_data has columns matching codes used in fertilizer
# trend data.
if (!country_grouping_col %in% colnames(country_group_data)) {
  # Try to match name using grep
  if (length(
    grep(country_grouping_col, colnames(country_group_data), ignore.case = TRUE)
  ) == 1
  ) {
    message(
      "Replace country_grouping_col ", sQuote(country_grouping_col), " with ",
      sQuote(
        grep(
          country_grouping_col,
          colnames(country_group_data),
          ignore.case = TRUE,
          value = TRUE
        )
      )
    )
    country_grouping_col <- grep(
      country_grouping_col,
      colnames(country_group_data),
      ignore.case = TRUE,
      value = TRUE
    )
  } else {
    stop(
      paste(
        "Column country_grouping_col", sQuote(country_grouping_col),
        "missing in country_group_data"
      )
    )
  }
}
# Check consistency between admin unit masks and country grouping
if (fertilizer_trend_admin == "luh2" && nlayers(trend_admin_raster) == 1) {
  # Check for countries used in LUH2 but missing in UNSD country_group_data.
  # Variable add_list_luh2 defined in helper/fix_admin_masks.R
  if (exists("add_list_luh2")) {
    country_group_data <- add_to_country_list(country_group_data, add_list_luh2)
  }

  # Try to fix country codes used in LUH2 country mask that are not in UNSD
  # country group listing.
  # ccode_replacement_luh2 defined in helper/fix_admin_masks.R
  if (exists("ccode_replacement_luh2")) {
    # All country codes in admin unit mask
    ccodes <- na.omit(unique(values(trend_admin_raster)))
    # Name column in country_group_data
    name_col <- grep(
      "country", colnames(country_group_data), ignore.case = TRUE
    )
    for (r in seq_len(nrow(ccode_replacement_luh2))) {
      if (!ccode_replacement_luh2[r, "source"] %in%
        country_group_data[, country_grouping_col] &&
        ccode_replacement_luh2[r, "replacement"] %in%
        country_group_data[, country_grouping_col]
      ) {
        r_replacement <- match(
          ccode_replacement_luh2[r, "replacement"],
          country_group_data[, country_grouping_col]
        )
        cat(
          "Replace country code", sQuote(ccode_replacement_luh2[r, "source"]),
          "with code", sQuote(ccode_replacement_luh2[r, "replacement"]),
          "for", sQuote(country_group_data[r_replacement, name_col]), "\n"
        )
        trend_admin_raster <- mask(
          trend_admin_raster,
          trend_admin_raster,
          maskvalue = ccode_replacement_luh2[r, "source"],
          updatevalue = ccode_replacement_luh2[r, "replacement"]
        )
      }
    }
  }
  # Update all country codes in admin unit mask and check if they are available
  # in country_group_data.
  ccodes <- na.omit(unique(values(trend_admin_raster)))
  if (!all(ccodes %in% country_group_data[, country_grouping_col])) {
    print(
      paste(
        "Warning: country code(s)",
        toString(setdiff(ccodes, country_group_data[, country_grouping_col])),
        "in trend_admin_raster not available in country_group_data.",
        "Consider adding them via an extry in 'add_list_luh2' or replacing",
        "them via an entry in 'ccode_replacement_luh2'"
      )
    )
  }
}
if (fertilizer_trend_admin == "gadm") {
  # Check for countries used in GADM but missing in UNSD country_group_data.
  # Variable add_list_gadm defined in helper/fix_admin_masks.R
  if (exists("add_list_gadm"))
    country_group_data <- add_to_country_list(country_group_data, add_list_gadm)

  # Try to fix country codes used in GADM country mask that are not in UNSD
  # country group listing.
  # ccode_replacement_gadm defined in helper/fix_admin_masks.R
  # This only works if GADM names have been provided. Note: subnational units
  # remain unchanged.
  if (!is.null(trend_admin_names) &&
    exists("ccode_replacement_gadm")
  ) {
    if (nlayers(trend_admin_raster) == 1) {
      ccodes <- na.omit(unique(values(trend_admin_raster)))
    } else {
      national_band <- find_national_band(trend_admin_raster)
      ccodes <- na.omit(
        unique(values(subset(trend_admin_raster, national_band)))
      )
    }
    iso_r <- match(ccodes, trend_admin_names[, code_col])
    iso_codes <- trend_admin_names[iso_r, iso_col]
    # Name column in trend_admin_names
    name_col <- grep(
      "country", colnames(trend_admin_names), ignore.case = TRUE
    )
    for (r in seq_len(nrow(ccode_replacement_gadm))) {
      if (!ccode_replacement_gadm[r, "source"] %in%
        country_group_data[, country_grouping_col] &&
        ccode_replacement_gadm[r, "replacement"] %in%
        country_group_data[, country_grouping_col] &&
        ccode_replacement_gadm[r, "replacement"] %in% iso_codes &&
        ccode_replacement_gadm[r, "source"] %in% iso_codes
      ) {
        r_source <- match(
          ccode_replacement_luh2[r, "source"],
          trend_admin_names[, iso_col]
        )
        r_replacement <- match(
          ccode_replacement_luh2[r, "replacement"],
          trend_admin_names[, iso_col]
        )
        print(
          paste(
            "Replace country code", sQuote(ccode_replacement_luh2[r, "source"]),
            "with code", sQuote(ccode_replacement_luh2[r, "replacement"]),
            "for", sQuote(trend_admin_names[r_replacement, name_col])
          )
        )
        if (nlayers(trend_admin_raster) == 1) {
          trend_admin_raster <- mask(
            trend_admin_raster,
            trend_admin_raster,
            maskvalue = trend_admin_names[r_source, code_col],
            updatevalue = trend_admin_names[r_replacement, code_col]
          )
        } else {
          # Extract band with national values
          national_raster <- subset(trend_admin_raster, national_band)
          # Only replace values in national band
          national_raster <- mask(
            national_raster,
            national_raster,
            maskvalue = trend_admin_names[r_source, code_col],
            updatevalue = trend_admin_names[r_replacement, code_col]
          )
          # Update values for national_band in trend_admin_raster
          trend_admin_raster <- setValues(
            trend_admin_raster,
            values(national_raster),
            layer = national_band
          )
          rm(national_raster)
        }
      }
    }
  } else if (exists("ccode_replacement_gadm")) {
    warning(
      "Cannot apply user-defined ccode_replacement_gadm because ",
      "trend_admin_names is missing.",
      call. = FALSE,
      immediate. = TRUE
    )
  }
}
################################################################################


################################################################################
## Gap-fill fertilizer trends for each crop                                 ##
crops <- na.omit(crop_type_mapping[, fertilizer_trend_map_col])
crops <- unique(crops[which(nchar(crops) > 0)])
if (length(fertilizer_pattern_refyear) != 1) {
  # Multiple reference years currently not supported by this script version.
  stop(
    paste(
      "Error: this script currently only supports fertilizer_pattern_refyear",
      "of length 1. You provided:",
      toString(fertilizer_pattern_refyear)
    )
  )
}
for (nut in fertilizer_trend_nutrients) {
  cat("Nutrient:", nut, "\n")
  crop_loop <- foreach(
    crop = crops,
    .inorder = FALSE,
    .combine = c
  ) %dopar% {
    # Log gap-filling into temporary file
    logfile <- tempfile(
      paste0(crop, nut, "_"),
      tmpdir = getwd(),
      fileext = ".txt"
    )
    fp <- file(logfile, "wt")
    sink(fp, type = "output")
    sink(fp, type = "message")
    if(!is.null(fertilizer_trend_src_name)) {
      filename <- fertilizer_trend_src_name
    } else {
      # Cannot use stop() in foreach loop
      message(
        "Error: You have not specified a filename for fertilizer trends ",
        "source data. Please supply fertilizer_trend_src_name in ",
        "fertilizer_setup.R or add logic to determine filename to this script."
      )
      # Stop logging to temporary file.
      sink(type = "output")
      sink(type = "message")
      close(fp)
      return(NULL)
    }
    # Variable name of crop in source file.
    # Default fertl_[CROP] is valid for LUH2.
    file_varname <- paste0("fertl_", crop)
    # Landuse pattern variable name in source file.
    # Default [CROP] is valid for LUH2.
    filelu_varname <- crop
    if (file.exists(filename)) {
      if (!is.null(fertilizer_trend_lu_name)) {
        if (file.exists(fertilizer_trend_lu_name)) {
          filename_lu <- fertilizer_trend_lu_name
        } else {
        warning(
          "*** Fertilizer trend landuse file ",
          fertilizer_trend_lu_name, " defined in fertilizer_setup.R ",
          "not found. ***",
          call. = FALSE,
          immediate. = TRUE
        )
        # Stop logging to temporary file.
        sink(type = "output")
        sink(type = "message")
        close(fp)
        return(NULL)
      }
      } else {
        filename_lu <- NULL
      }
      if (!grepl(".nc$", filename) && !grepl(".nc4$", filename)) {
        message(
          "This script expects a NetCDF file as source. Provided: ",
          filename
        )
        # Stop logging to temporary file.
        sink(type = "output")
        sink(type = "message")
        close(fp)
        return(NULL)
      }
      if (!is.null(filename_lu) && !grepl(".nc$", filename_lu) &&
        !grepl(".nc4$", filename_lu)
      ) {
        message(
          "This script expects a NetCDF file as landuse pattern source. ",
          "Provided:", filename_lu
        )
        # Stop logging to temporary file.
        sink(type = "output")
        sink(type = "message")
        close(fp)
        return(NULL)
      }
      file_nc <- nc_open(filename)
      # Check that crop variable is available in file.
      if (!file_varname %in% names(file_nc$var)) {
        message(
          "Error: variable ", sQuote(file_varname), " not available in file ",
          filename
        )
        nc_close(file_nc)
        # Stop logging to temporary file.
        sink(type = "output")
        sink(type = "message")
        close(fp)
        return(NULL)
      }
      if (!fertilizer_trend_admin_resmatch) {
        # Admin unit dataset has different resolution. Try to match.
        # Note: resolution is also checked in gapfill_pattern() and adjusted if
        # necessary. Aggregating here avoids having to redo it for every year.
        cat("Trying to match resolution of admin units to data resolution.\n")
        # Extract one year of data
        filedata <- raster(filename, varname = file_varname, band = 1)
        # Keep a copy of the orginal data
        trend_admin_raster_backup <- trend_admin_raster
        # Aggregate admin unit data if it has higher resolution than filedata.
        trend_admin_raster <- try(
          match_admin_to_data(
            filedata,
            trend_admin_raster,
            fun = modal_ties_first,
            verbose = TRUE
          )
        )
        if (class(trend_admin_raster) == "try-error") {
          # Matching resolution failed.
          nc_close(file_nc)
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
        if (!is.null(trend_border_raster)) {
          trend_border_raster_backup <- trend_border_raster
          trend_border_raster <- try(
            match_admin_to_data(
              filedata,
              trend_border_raster,
              fun = max,
              verbose = FALSE
            )
          )
          if (class(trend_border_raster) == "try-error") {
            # Matching resolution failed.
            nc_close(file_nc)
            # Stop logging to temporary file.
            sink(type = "output")
            sink(type = "message")
            close(fp)
            return(NULL)
          }
        }
        rm(filedata)
      }

      # Determine file years.
      try(
        file_years <- nc_file_years(file_nc)
      )
      if (class(file_years) == "try-error") {
        # Error occurred determining file years.
        nc_close(file_nc)
        # Stop logging to temporary file.
        sink(type = "output")
        sink(type = "message")
        close(fp)
        return(NULL)
      }
      if (!all(fertilizer_pattern_refyear %in% file_years)) {
        message(
          "Error: trend file ", filename, " does not cover reference year ",
          "of fertilizer patterns ",
          toString(setdiff(fertilizer_pattern_refyear, file_years))
        )
        nc_close(file_nc)
        # Stop logging to temporary file.
        sink(type = "output")
        sink(type = "message")
        close(fp)
        return(NULL)
      }
      file_process_years <- seq(
        max(min(file_years), min(output_period)),
        min(max(file_years), max(output_period))
      )
      # Make sure reference year of fertilizer patterns is included and is gap-
      # filled first.
      file_process_years <- union(
        fertilizer_pattern_refyear,
        file_process_years
      )
      if (!is.null(filename_lu)) {
        filelu_nc <- nc_open(filename_lu)
        # Check that file has same spatial attributes as file_nc.
        if (!identical(filelu_nc$dim$lon$vals, file_nc$dim$lon$vals) ||
          !identical(filelu_nc$dim$lat$vals, file_nc$dim$lat$vals)
        ) {
          message(
            "Error: Spatial mismatch between fertilizer pattern in ",
            filename,
            " and landuse pattern in ",
            filename_lu
          )
          nc_close(file_nc)
          nc_close(filelu_nc)
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
        # Check that crop variable is available in file.
        if (!filelu_varname %in% names(filelu_nc$var)) {
          message(
            "Error: variable ", sQuote(filelu_varname),
            " not available in file ",
            filename_lu
          )
          nc_close(file_nc)
          nc_close(filelu_nc)
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
        # Determine file years.
        try(
          filelu_years <- nc_file_years(filelu_nc)
        )
        if (class(filelu_years) == "try-error") {
          # Error occurred determining file years.
          nc_close(file_nc)
          nc_close(filelu_nc)
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
        if (!all(file_process_years %in% filelu_years)) {
          # Landuse patterns do not cover all years of fertilizer time series.
          message(
            "Error: landuse pattern file ", filename_lu,
            " does not cover all years to process. Missing: ",
            toString(setdiff(file_process_years, filelu_years))
          )
          nc_close(filelu_nc)
          nc_close(file_nc)
          # Stop logging to temporary file.
          sink(type = "output")
          sink(type = "message")
          close(fp)
          return(NULL)
        }
      }
      if (fertilizer_trend_is_national) {
        # Collect gap-filled data in table per country
        national_band <- find_national_band(trend_admin_raster)
        gapfilled_ts <- array(
          dim = c(
            length(file_process_years),
            length(
              na.omit(unique(values(subset(trend_admin_raster, national_band))))
            )
          ),
          dimnames = list(
            sort(file_process_years),
            na.omit(unique(values(subset(trend_admin_raster, national_band))))
          )
        )
        if (!is.null(trend_admin_names)) {
          # Rename dimnames(gapfilled_ts)[[2]] to country ISO codes
          if (
            !all(dimnames(gapfilled_ts)[[2]] %in% trend_admin_names[, code_col])
          ) {
            message(
              "Error: country ID(s) ",
              toString(
                setdiff(
                  dimnames(gapfilled_ts)[[2]],
                  trend_admin_names[, code_col]
                )
              ),
              " from trend_admin_raster missing in trend_admin_names."
            )
            nc_close(file_nc)
            if (!is.null(filename_lu))
              nc_close(filelu_nc)
            # Stop logging to temporary file.
            sink(type = "output")
            sink(type = "message")
            close(fp)
            return(NULL)
          }
          code_r <- match(
            dimnames(gapfilled_ts)[[2]],
            trend_admin_names[, code_col]
          )
          iso_codes <- trend_admin_names[code_r, iso_col]
          dimnames(gapfilled_ts)[[2]] <- iso_codes
        }
        # Arrays for gap-filling status information.
        gapfilled_level <- gapfilled_sources <- gapfilled_ts
      }
      for (year in file_process_years) {
        cat("***", year, "***\n")
        filedata <- raster(
          filename,
          varname = file_varname,
          band = which(file_years == year)
        )
        strip_zero <- fertilizer_trend_strip_zero
        if (!is.null(filename_lu) && strip_zero) {
          maskdata <- raster(
            filename_lu,
            varname = filelu_varname,
            band = which(filelu_years == year)
          )
          if (any(filedata[which(maskdata[] == 0)] != 0)) {
            warning(
              "Fertilizer source has non-zero values in ",
              length(which(filedata[which(maskdata[] == 0)] != 0)),
              " cells where landuse pattern is zero during year ", year,
              ".\nAre you sure that this is the corresponding landuse pattern?",
              call. = FALSE,
              immediate. = TRUE
            )
          }
          # Set cells where maskdata is 0 to NA in filedata.
          filedata <- mask(filedata, maskdata, maskvalue = 0)
          # No need to strip zeros in gap-filling
          strip_zero <- FALSE
          rm(maskdata)
        }
        if (cellStats(filedata, max) == 0) {
          cat("*** No non-zero source values in year", year, "***\n")
          if (fertilizer_trend_is_national) {
            # Can set all countries to zero directly, no need for full
            # processing.
            gapfilled_ts[as.character(year), ] <- 0
            # Dummy for global zero fertilizer rate in gapfilled_level
            gapfilled_level[as.character(year), ] <- -1
            # Skip to next year.
            next
          } else if (exists("ref_filedata") &&
            !year %in% fertilizer_pattern_refyear
          ) {
            # Put together filedata_filled and filedata_final to skip
            # gap-filling.
            filedata_final <- filedata_filled <- brick(
              # Data layer with 0 in all non-missing cells
              mask(
                subset(ref_filedata, 1),
                subset(ref_filedata, 1),
                maskvalue = NA,
                inverse = TRUE,
                updatevalue = 0
              ),
              # gapfill_level with dummy value -1
              mask(
                subset(ref_filedata, 2),
                subset(ref_filedata, 2),
                maskvalue = NA,
                inverse = TRUE,
                updatevalue = -1
              ),
              # gapfill_sources with NA in all cells
              mask(
                subset(ref_filedata, 3),
                subset(ref_filedata, 3),
                maskvalue = NA,
                inverse = TRUE,
                updatevalue = NA
              ),
              # country layer
              subset(ref_filedata, 4)
            )
          }
          # No non-zero values. Flush all land cells with 0.
          # Set all cells to 0 to avoid unnecessary gap-filling.
          filedata[] <- 0
        }
        if (!exists("filedata_filled")) {
          filedata_filled <- gapfill_pattern(
            filedata = filedata,
            strip_zero = strip_zero,
            unit_raster = trend_admin_raster,
            unit_raster_names = trend_admin_names,
            unit_border_raster = trend_border_raster,
            # GADM does not match admin units used in source data, so filter cells
            # that may be assigned to wrong country.
            assign_grid_threshold = fertilizer_trend_assign_grid_threshold,
            # Use multi-country regions to fill country with zero non-missing
            # cells.
            fill_regional_data = year %in% fertilizer_pattern_refyear,
            # This is the minimum number of countries required in a country group
            # to use that group's value.
            assign_country_threshold = fertilizer_trend_assign_country_threshold,
            country_grouping = country_group_data,
            country_grouping_col = country_grouping_col,
            is_national = fertilizer_trend_is_national,
            fert_band = fertilizer_trend_fert_band,
            source_band = fertilizer_trend_source_band,
            source_country_vals = c(3, 3.25, 5, 5.25, 5.5, 5.75, 6, 6.25, 6.5,
                                    6.75),
            verbose = TRUE
          )
        }
        if (year %in% fertilizer_pattern_refyear) {
          # Remember data in reference year
          ref_filedata <- filedata_filled
        }          
        # Express fertilizer rate relative to reference year
        filedata <- subset(filedata_filled, 1) / subset(ref_filedata, 1)
        # Mask out any cells which have no fertilizer rate during reference
        # year
        filedata <- mask(filedata, subset(ref_filedata, 1), maskvalue = 0)
        # Second gap-filling of relative rates
        if (!exists("filedata_final")) {
          cat("++ Second gap-fill pass of relative rates ++\n")
          filedata_final <- gapfill_pattern(
            filedata = filedata,
            strip_zero = FALSE,
            unit_raster = trend_admin_raster,
            unit_raster_names = trend_admin_names,
            unit_border_raster = trend_border_raster,
            # GADM does not match admin units used in source data, so filter
            # cells that may be assigned to wrong country.
            assign_grid_threshold = fertilizer_trend_assign_grid_threshold,
            # Use multi-country regions to fill country with zero non-missing
            # cells.
            fill_regional_data = TRUE,
            # This is the minimum number of countries required in a country
            # group to use that group's value.
            assign_country_threshold = fertilizer_trend_assign_country_threshold,
            country_grouping = country_group_data,
            country_grouping_col = country_grouping_col,
            is_national = fertilizer_trend_is_national,
            fert_band = fertilizer_trend_fert_band,
            source_band = fertilizer_trend_source_band,
            source_country_vals = c(3, 3.25, 5, 5.25, 5.5, 5.75, 6, 6.25, 6.5,
                                    6.75),
            verbose = TRUE
          )
        }
        # Determine resolution of gap-filled data to set working directory for
        # outputs. Resolution may not be the same as GADM raster set as working
        # directory in fertilizer_setup.R and also may not be the same as raw
        # source data. We advise to always use unit_raster at same resolution as
        # fertilizer trend data.
        tmp_res <- ifelse(res(filedata_final) < 1 / 60, 3600, 60) *
          res(filedata_final)
        tmp_string <- paste(
          unique(round(tmp_res)),
          unique(ifelse(res(filedata_final) < 1 / 60, "sec", "min")),
          sep = "",
          collapse = "_by_"
        )
        filled_working_dir <- file.path("tmp", paste0("work_", tmp_string))
        if (!dir.exists(filled_working_dir)) {
          dir.create(filled_working_dir, recursive = TRUE)
        }
        if (fertilizer_trend_is_national) {
          # Aggregate gridded data to countries. This assumes that last band in
          # filedata_final contains country codes.
          # Create cell list per country so that it does not need to be
          # recreated each year.
          if (!exists("country_cell_list")) {
            country_cell_list <- list()
            ccodes <- values(subset(filedata_final, nlayers(filedata_final)))
            for (ccode in dimnames(gapfilled_ts)[[2]]) {
              if (!is.null(trend_admin_names)) {
                # gapfilled_ts uses country ISO codes instead of country IDs
                # from trend_admin_raster.
                # Replace ISO by ID
                iso_r <- match(ccode, trend_admin_names[, iso_col])
                country_id <- trend_admin_names[iso_r, code_col]
              } else {
                # gapfilled_ts uses IDs from trend_admin_raster directly.
                country_id <- ccode
              }
              country_cell_list[[ccode]] <- which(ccodes == country_id)
            }
          }
          for (ccode in dimnames(gapfilled_ts)[[2]]) {
            ccells <- country_cell_list[[ccode]]
            if (is.na(gapfilled_ts[as.character(year), ccode]))
              gapfilled_ts[as.character(year), ccode] <- 
                median(subset(filedata_final, 1)[ccells], na.rm = TRUE)
            # Set country gapfilled_level to highest gridcell value.
            if (is.na(gapfilled_level[as.character(year), ccode])) {
              gapfilled_level[as.character(year), ccode] <-
                max(subset(filedata_final, 2)[ccells], na.rm = TRUE)
              # Check whether first pass had higher gapfilled_level
              first_pass <- max(subset(filedata_filled, 2)[ccells], na.rm = TRUE)
              if (first_pass > gapfilled_level[as.character(year), ccode]) {
                gapfilled_level[as.character(year), ccode] <- first_pass
                if (first_pass > 1) {
                  # Number of sources not applicable if no gap-filling took place.
                  gapfilled_sources[as.character(year), ccode] <-
                    max(subset(filedata_filled, 3)[ccells], na.rm = TRUE)
                }
              } else if (gapfilled_level[as.character(year), ccode] > 1) {
                gapfilled_sources[as.character(year), ccode] <-
                  max(subset(filedata_final, 3)[ccells], na.rm = TRUE)
              }
            }
            rm(ccells)
          }
        } else {
          # Grid-specific output
          if (!exists("fileout_nc")) {
            # Determine filename of gap-filled data.
            fileout_name <- file.path(
              filled_working_dir,
              paste0(
                crop, nut, "_relative_ts_",
                fertilizer_trend_admin,
                ifelse(
                  fertilizer_trend_is_national,
                  "_national",
                  "_subnational"
                ),
                ".nc"
              )
            )
            # Set up NetCDF variables
            lon_dim <- ncdim_def(
              name = "longitude",
              units = "degrees_east",
              vals = xFromCol(filedata_final),
              longname = "longitude"
            )
            lat_dim <- ncdim_def(
              name = "latitude",
              units = "degrees_north",
              vals = yFromRow(filedata_final),
              longname = "latitude"
            )
            time_dim <- ncdim_def(
              name = "time",
              units = "year",
              vals = sort(file_process_years),
              unlim = TRUE
            )
            fert_var <- ncvar_def(
              name = paste0(crop, nut, "_relative_ts"),
              units = "",
              dim = list(lon_dim, lat_dim, time_dim),
              missval = missval_float,
              longname = paste(
                nut,
                "fertilizer application rate relative to reference year for",
                crop
              ),
              compression = 5
            )
            gapfill_stats_var <- ncvar_def(
              name = "gapfill_level",
              units = "",
              dim = list(lon_dim, lat_dim, time_dim),
              missval = missval_float,
              longname = "Level at which gap-filling was performed",
              compression = 5
            )
            gapfill_source_var <- ncvar_def(
              name = "gapfill_sources",
              units = "",
              dim = list(lon_dim, lat_dim, time_dim),
              missval = missval_integer,
              longname = "Number of cells/countries used for gap-filling",
              prec = "integer",
              compression = 5
            )
            # Create output file
            fileout_nc <- nc_create(
              fileout_name,
              list(fert_var, gapfill_stats_var, gapfill_source_var)
            )
            ncatt_put(
              fileout_nc,
              paste0(crop, nut, "_relative_ts"),
              "missing_value",
              missval_float
            )
            ncatt_put(
              fileout_nc,
              "gapfill_level",
              "missing_value",
              missval_float
            )
            ncatt_put(
              fileout_nc,
              "gapfill_sources",
              "missing_value",
              missval_integer
            )
            nc_sync(fileout_nc)
          }
          # Write relative fertilizer rate
          writedata <- as.double(values(subset(filedata_final, 1)))
          writedata[which(is.na(writedata))] <- missval_float
          ncvar_put(
            fileout_nc,
            paste0(crop, nut, "_relative_ts"),
            writedata,
            start = c(1, 1, which(time_dim$vals == year)),
            count = c(-1, -1, 1)
          )
          # Write gapfill_level. Use higher value of first and second gap-fill
          # pass.
          writedata <- as.double(values(subset(filedata_final, 2)))
          use_first_pass <- which(
            values(subset(filedata_filled, 2)) > writedata
          )
          writedata[use_first_pass] <-
            subset(filedata_filled, 2)[use_first_pass]
          writedata[which(is.na(writedata))] <- missval_float
          ncvar_put(
            fileout_nc,
            "gapfill_level",
            writedata,
            start = c(1, 1, which(time_dim$vals == year)),
            count = c(-1, -1, 1)
          )
          # Write gapfill_sources. Make sure that gapfill_sources matches pass
          # used for gapfill_level.
          writedata <- as.integer(values(subset(filedata_final, 3)))
          writedata[use_first_pass] <-
            subset(filedata_filled, 3)[use_first_pass]
          writedata[which(is.na(writedata))] <- missval_integer
          ncvar_put(
            fileout_nc,
            "gapfill_sources",
            writedata,
            start = c(1, 1, which(time_dim$vals == year)),
            count = c(-1, -1, 1)
          )
          rm(writedata)
        }
        rm(filedata, filedata_filled, filedata_final)
      } # End year loop
      nc_close(file_nc)
      if (!is.null(filename_lu))
        nc_close(filelu_nc)
      if (exists("fileout_nc")) {
        nc_close(fileout_nc)
        rm(fileout_nc)
      }
      if (fertilizer_trend_is_national) {
        # Write country arrays to RData file
        fileout_name <- file.path(
          filled_working_dir,
          paste0(
            crop, nut, "_relative_ts_",
            fertilizer_trend_admin,
            ifelse(fertilizer_trend_is_national, "_national", "_subnational"),
            ".RData"
          )
        )
        save(
          gapfilled_ts,
          gapfilled_level,
          gapfilled_sources,
          file = fileout_name
        )
        rm(gapfilled_ts, gapfilled_level, gapfilled_sources)
      }
      rm(list = intersect(c("ccodes", "country_cell_list"), ls()))
      # Stop logging to temporary file.
      sink(type = "output")
      sink(type = "message")
      close(fp)
    } else {
      warning(
        "*** Fertilizer trend file", filename, "not found. ***",
        call. = FALSE,
        immediate. = TRUE
      )
      # Stop logging to temporary file.
      sink(type = "output")
      sink(type = "message")
      close(fp)
      return(NULL)
    }
    if (exists("fileout_name")) {
      # Move gap-fill log file to location of gap-filled time series.
      logfile_final <- file.path(
        filled_working_dir,
        paste0(
          crop, nut, "_relative_ts_",
          fertilizer_trend_admin,
          ifelse(fertilizer_trend_is_national, "_national", "_subnational"),
          ".log"
        )
      )
      file.rename(logfile, logfile_final)
      rm(fileout_name)
    }
    if (exists("trend_admin_raster_backup")) {
      # Restore backup copy just in case different crops have different
      # resolutions.
      trend_admin_raster <- trend_admin_raster_backup
      rm(trend_admin_raster_backup)
    }
    if (exists("trend_border_raster_backup")) {
      # Restore backup copy just in case different crops have different
      # resolutions.
      trend_border_raster <- trend_border_raster_backup
      rm(trend_border_raster_backup)
    }
    return(crop)
  }
  if (length(crop_loop) != length(crops)) {
    warning(
      "The following crops were not gap-filled correctly for ",
      "nutrient ", sQuote(nut), ": ",
      toString(sQuote(setdiff(crops, crop_loop))),
      call. = FALSE,
      immediate. = TRUE
    )
  } else {
    cat(length(crops), "crops gap-filled for nutrient", sQuote(nut), "\n")
  }
}
################################################################################


################################################################################
## If running in parallel mode do some clean-up.                              ##
if (parallel_mpi) {
  # Release linked R instances and close MPI cluster.
  doMPI::closeCluster(cl)
  Rmpi::mpi.quit()
}
if (parallel_local) {
  # Release parallel cluster
  parallel::stopCluster(cl)
}
################################################################################
