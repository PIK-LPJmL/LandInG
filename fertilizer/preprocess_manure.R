################################################################################
## Copyright (C) 2022 Potsdam Institute for Climate Impact Research (PIK),    ##
## see COPYRIGHT file.                                                        ##
##                                                                            ##
## This file is part of LandInG and licensed under GNU AGPL Version 3 or      ##
## later. See LICENSE file or go to http://www.gnu.org/licenses/              ##
## Contact: https://github.com/PIK-LPJmL/LandInG/                             ##
################################################################################

################################################################################
## This script can be used to preprocess manure source data from Zhang et al. ##
## The source data comes in individual files per year, using a non-standard   ##
## grid format. This script combines all years into one NetCDF file with      ##
## global extent to ease combination with other global source datasets.       ##
################################################################################

# Clean up memory
rm(list = ls(all = TRUE))

################################################################################
## Setup of variables valid across all scripts related to fertilizer data     ##
## processing.                                                                ##
## - sets many directories and file names                                     ##
source("fertilizer_setup.R")
## Missing value used in NetCDF files generated by this script.               ##
missval_float <- 1e20
################################################################################

################################################################################
## Missing ASCII header. Information taken from ReadMe included with data.    ##
ncols <- 4320
nrows <- 2124
xllcorner <- -180
yllcorner <- -88.5
cellsize <- 1/12
NODATA_value <- -9999
################################################################################


################################################################################
## Detect available files and extract year information.
# Zhang et al. (2017) data are for nutrient "N"
nut <- "N"
# Directory containing decompressed files.
# Note: By default, manure is only available for nitrogen, and manure_*
# parameters in fertilizer_setup.R all refer to nitrogen. However, this script
# technically supports setting values per nutrient by giving named vectors as
# manure_* settings.
data_dir <- file.path(
  ifelse(length(manure_dir) > 1, manure_dir[nut], manure_dir),
  "ManNitProCrpRd"
)
# Data source files. Check that pattern matches the data you downloaded.
data_files <- list.files(data_dir, "yy[0-9]{4}.txt")
if (length(data_files) == 0) {
  stop("No manure source data found in ", data_dir)
}
# Detect years in file names
data_years <- na.omit(
  as.integer(regmatches(data_files, regexpr("[0-9]{4}", data_files)))
)
if (length(data_years) != length(data_files)) {
  stop("Cannot detect data_years from data_files")
}
if (length(data_years) != length(seq(min(data_years), max(data_years)))) {
  warning("File years from source files are not continuous", immediate. = TRUE)
}
################################################################################


################################################################################
## Data conversion                                                            ##
# Set up spatial extent of source data based on ASCII header information above.
data_extent <- extent(
  xllcorner,
  xllcorner + ncols * cellsize,
  yllcorner,
  yllcorner + nrows * cellsize
)
# Set up dummy RasterLayer for source data and dummy raster with global extent
data_raster <- raster(data_extent, res = cellsize)
global_raster <- raster(global_extent, res = cellsize)
# Check if cell boundaries of data_raster and global_raster are aligned
x <- min(xres(data_raster), xres(global_raster))
y <- min(yres(data_raster), yres(global_raster))
if ((abs(xmin(global_raster) - xmin(data_raster)) / x) %% 1 > 0.01 ||
  (abs(ymin(global_raster) - ymin(data_raster)) / y) %% 1 > 0.01
) {
  stop("Cell boundaries of data_raster and global_raster are mis-aligned")
}

# Set up NetCDF dimensions and variable
lon_dim <- ncdim_def(
  name = "longitude",
  units = "degrees_east",
  vals = xFromCol(global_raster),
  longname = "Longitude"
)
lat_dim <- ncdim_def(
  name = "latitude",
  units = "degrees_north",
  vals = yFromRow(global_raster),
  longname = "Latitude"
)
time_dim <- ncdim_def(
  name = "time",
  units = "year",
  vals = sort(data_years),
  unlim = TRUE
)
manure_var <- ncvar_def(
  name = paste0("manure_", nut),
  units = ifelse(
    length(manure_src_unit) > 1,
    manure_src_name[nut],
    manure_src_unit
  ),
  dim = list(lon_dim, lat_dim, time_dim),
  missval = missval_float, 
  longname = paste0(
    "Manure ", nut, " application",
    ifelse(
      is.null(manure_ref_area) ||
        (!is.null(names(manure_ref_area)) && !nut %in% names(manure_ref_area)),
      "",
      paste(
        " rate on",
        ifelse(
          length(manure_ref_area) > 1, manure_ref_area[nut], manure_ref_area
        )
      )
    )
  ),
  compression = 5
)
# Set up NetCDF filename
fileout_name <- paste0(
  "manure_", nut, "_",
  paste(range(data_years), collapse = "-"),
  ".nc"
)
if (
  dirname(
    ifelse(length(manure_src_name) > 1, manure_src_name[nut], manure_src_name)
  ) != "."
) {
  fileout_name <- file.path(
    dirname(
      ifelse(length(manure_src_name) > 1, manure_src_name[nut], manure_src_name)
    ),
    fileout_name
  )
}
# Check if NetCDF filename matches pattern defined in fertilizer_setup.R
if (!grepl(
  ifelse(length(manure_src_name) > 1, manure_src_name[nut], manure_src_name),
  fileout_name
)) {
  stop(
    paste0(
      "Automatically generated file name fileout_name \n",
      sQuote(fileout_name),
      "\ndoes not match pattern defined in fertilizer_setup.R:\n",
      sQuote(
        gsub(
          "\\", "\\\\",
          ifelse(
            length(manure_src_name) > 1,
            manure_src_name[nut],
            manure_src_name
          ),
          fixed = TRUE
        )
      )
    )
  )
}
# Create NetCDF file
fileout_nc <- nc_create(fileout_name, manure_var)
ncatt_put(
  fileout_nc,
  paste0("manure_", nut),
  "missing_value",
  missval_float
)
nc_sync(fileout_nc)

cat(
  "Converting", length(data_files), "files spanning",
  paste(range(data_years), collapse = "-"),
  "to", sQuote(fileout_name), "\n"
)
for (findex in seq_along(data_files)) {
  # Read values from file.
  filevals <- scan(
    file.path(data_dir, data_files[findex]),
    sep = "",
    quiet = TRUE
  )
  if (length(filevals) != ncell(data_raster)) {
    warning(
      "Number of values read from ",
      sQuote(file.path(data_dir, data_files[findex])),
      " does not correspond to data_raster.\n",
      "Please check that header information provided in script is correct.",
      call. = FALSE,
      immediate. = TRUE
    )
  }
  # Replace missing values in data read from file.
  filevals[which(filevals == NODATA_value)] <- NA
  # Assign values to RasterLayer
  values(data_raster) <- filevals
  # Expand data_raster to global_extent if necessary. Fill up with missing data
  # value if source data contains cells with missing value. Otherwise, fill up
  # with zero.
  netcdf_raster <- extend(
    data_raster,
    global_extent,
    value = ifelse(any(is.na(filevals)), NA, 0)
  )
  # Save to NetCDF file
  ncvar_put(
    fileout_nc,
    paste0("manure_", nut),
    vals = values(netcdf_raster),
    start = c(1, 1, which(time_dim$vals == data_years[findex])),
    count = c(-1, -1, 1)
  )
}
nc_close(fileout_nc)
