################################################################################
## Copyright (C) 2022 Potsdam Institute for Climate Impact Research (PIK),    ##
## see COPYRIGHT file.                                                        ##
##                                                                            ##
## This file is part of LandInG and licensed under GNU AGPL Version 3 or      ##
## later. See LICENSE file or go to http://www.gnu.org/licenses/              ##
## Contact: https://github.com/PIK-LPJmL/LandInG/                             ##
################################################################################

################################################################################
## This script extracts information from the Global Reservoir and Dam (GRanD) ##
## database to generate reservoir input file required by LPJmL.               ##
################################################################################
# Clean up memory
rm(list = ls(all = TRUE))

################################################################################
## Basic setup:                                                               ##
## Working directory:                                                         ##
## This is where outputs from this script will be saved.                      ##
grand_dir <- ""
if (nchar(grand_dir) > 0) {
  setwd(grand_dir)
}
## GRanD database:                                                            ##
## The following variable refers to the attribute table of dams.              ##
## Default value assumes that GRanD version 1.3 has been downloaded to        ##
## grand_dir and unzipped.                                                    ##
grand_name <- "GRanD_Version_1_3/GRanD_dams_v1_3.dbf"
## LPJmL grid and upstream area:                                              ##
## Grid file in LPJmL input format:                                           ##
gridname <- "ENTER_PATH_TO_GRIDFILE_HERE"
## RData file containing matching upstream areas, as generated by script      ##
## river_routing.R
upstreamarea_RData <- "ENTER_PATH_TO_RDATA_FILE_WITH_UPSTREAM_AREAS_HERE"
## Version string (optional)
## Added to names of created files (resolution string added automatically)    ##
version_string <- ""
##                                                                            ##
## Positioning settings:                                                      ##
## Search radius when looking for matching upstream area (degrees in each     ##
## direction)                                                                 ##
search_rad <- 1
## Maximum allowed distance between original and assigned coordinates (set to ##
## NA in order to only use search radius (should be size of at least 1 grid   ##
## cell depending on grid resolution or NA). Distance in metres.              ##
max_dist <- 75000
## Weighting of cells in search radius:  Dams are assigned to grid cells by   ##
## optimizing two terms:                                                      ##
## - deviation weight is calculated as: 1 / (deviation^(deviation_penalty *   ##
##   pos_penalty|neg_penalty))                                                ##
## - distance weight is calculated as: 1 / (distance^(distance_penalty))      ##
## - total weighting = distance weight * deviation weight                     ##
## Using the same value for deviation_penalty and distance_penalty places     ##
## equal importance on both terms. Higher values of distance_penalty favour   ##
## cells in closer vicinity but may lead to larger deviations of upstream     ##
## area. Higher values of deviation_penalty favour a better match of upstream ##
## areas but may shift the position of the dam further away, with a risk of   ##
## placing dams on a different river. You can provide more than one value per ##
## parameter.                                                                 ##
deviation_penalty <- c(1, 1.5)
distance_penalty <- c(1, 1.5)
## Whether to place higher/lower penalty on upstream areas being over or      ##
## underestimated. You can provide more than one value per parameter.         ##
pos_penalty <- 1 # Applies if LPJmL upstream area exceeds GRanD catchment area
neg_penalty <- 1 # Applies if LPJmL upstream area below GRanD catchment area
## Note: All combinations of deviation_penalty, distance_penalty, neg_penalty ##
## and pos_penalty will be computed.                                          ##
##                                                                            ##
## Data corrections:                                                          ##
## Some reservoirs have capacity but no area. These may be fixed using area-  ##
## storage volume relationship from Lehner et. al 2011 paper.                 ##
fix_area <- TRUE
## Some dams are missing a start year (using -99 instead). You may set a      ##
## minimum start year which will be assigned to all dams with an earlier year ##
## (set to NA to enforce no minimum start year).                              ##
minimum_startyear <- 1
## You may opt not to exclude all dams built after a certain year. Set to very##
## high value to include all dams.                                            ##
last_includeyear <- 2100
## Unit conversion between LPJmL upstream area and GRanD catchment area. By   ##
## default LPJmL upstream area is in m2, GRanD catchment area is in km2.      ##
grand_area_unit <- "km2"
lpjml_area_unit <- "m2"
## Unit conversion between GRanD storage capacity and storage capacity in     ##
## LPJmL. By default, GRanD uses million cubic meters (check documentation)   ##
## while LPJmL uses cubic kilometres.                                         ##
grand_capacity_unit <- "1e6 m3"
lpjml_capacity_unit <- "km3"
## Special cases in GRanD: Database contains attribute column "TIMELINE" with ##
## additional information on dam/reservoir status. Additional rules how to    ##
## treat such dams/reservoirs can be added. At the moment, actions "drop" and ##
## "keep" are supported.                                                      ##
timeline_action <- c("Destroyed" = "drop",
                     "Modified" = "keep",
                     "Planned" = "drop",
                     "Removed" = "drop",
                     "Replaced" = "drop",
                     "Subsumed" = "drop",
                     "Under construction" = "drop"
                     )
## LPJmL input format settings:                                               ##
## Header version: only version 3 supports longitude and latitude resolution  ##
## to differ (default: 3)
bintype <- 3
## Header name: this must match header name defined in LPJmL source code.     ##
headername <- "LPJDAMS"
################################################################################


################################################################################
## Manual grid cell assignment. The automatic algorithm may not always find   ##
## the best cell assignment. This allows to assign dams to cells manually.    ##
## GRAND_ID refers to the unique ID in GRanD database, CELL_ID_CATCH is the   ##
## index of the assigned cell (starting at 1) in the grid file.               ##
manual_assignment <- data.frame(
  GRAND_ID = integer(0),
  CELL_ID_CATCH = integer(0)
)
################################################################################


################################################################################
## Helper functions for LPJmL input format                                    ##
## The script lpjml_format_helper_functions.R is saved in the parent          ##
## directory by default.                                                      ##
################################################################################
if (file.exists("../lpjml_format_helper_functions.R")) {
  source("../lpjml_format_helper_functions.R")
} else {
  stop("Please update path to script with LPJmL input format helper function")
}

################################################################################
## Load required R packages. These may need to be installed first.            ##
library(raster)
library(foreign)
library(geosphere)
library(udunits2)
# The following packages are only used for plotting diagnostics graphics
library(sf)
# Depending on the package version, function st_make_valid() is either available
# directly in package sf or provided by package lwgeom
if (!exists("st_make_valid"))
  library(lwgeom)

library(RColorBrewer)
library(maps)
################################################################################

# Use simple quotation marks
options(useFancyQuotes = FALSE)

################################################################################
## Read inputs:                                                               ##
## LPJmL grid file. Functions read_header(), get_headersize(), get_datatype() ##
## defined in lpjml_format_helper_functions.R                                 ##
cat("Reading LPJmL grid from", sQuote(gridname), "\n")
gridheader <- read_header(gridname)
gridfile <- file(gridname, "rb")
# Skip over header
seek(gridfile, get_headersize(gridheader))
griddata <- matrix(
  readBin(
    gridfile,
    what = get_datatype(gridheader)$type,
    size = get_datatype(gridheader)$size,
    n = gridheader$header["ncell"] * gridheader$header["nbands"],
    endian = gridheader$endian
  ) * gridheader$header["scalar"],
  ncol = gridheader$header["nbands"],
  byrow = TRUE,
  dimnames = list(NULL, c("lon", "lat"))
)
close(gridfile)
# Create raster object for upstream area
gridraster <- raster(
  xmn = min(griddata[, 1]) - gridheader$header["cellsize_lon"] / 2,
  xmx = max(griddata[, 1]) + gridheader$header["cellsize_lon"] / 2,
  ymn = min(griddata[, 2]) - gridheader$header["cellsize_lat"] / 2,
  ymx = max(griddata[, 2]) + gridheader$header["cellsize_lat"] / 2,
  resolution = gridheader$header[c("cellsize_lon", "cellsize_lat")]
)
# Try to correct numerical inaccuracies of grid settings
if (all(
  (1 / gridheader$header[c("cellsize_lon", "cellsize_lat")]) %% 1 < 1e-6 |
  (1 / gridheader$header[c("cellsize_lon", "cellsize_lat")]) %% 1 > 1 - 1e-6
)) {
  res(gridraster) <- 1 /
    round(1 / gridheader$header[c("cellsize_lon", "cellsize_lat")])
  extent(gridraster) <- alignExtent(
    extent(gridraster),
    raster(extent(-180, 180, -90, 90), res = res(gridraster))
  )
}
cat(
  "Grid has", gridheader$header["ncell"],
  "cells with a spatial resolution of",
  paste(format(res(gridraster), digits = 4), collapse = " by "), "degrees.\n"
)
# Set projection
proj4string(gridraster) <-
  "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"
# Assign grid cell indices of LPJmL grid file to raster
gridraster[cellFromXY(gridraster, griddata)] <-
  seq_len(gridheader$header["ncell"])
# Determine resolution string to be used in files created by this script
tmp_res <- unique(
  ifelse(
    gridheader$header[c("cellsize_lon", "cellsize_lat")] < 1 / 60,
    3600,
    60
  ) * gridheader$header[c("cellsize_lon", "cellsize_lat")]
)
lpj_res_string <- paste(
  round(tmp_res),
  unique(
    ifelse(
      gridheader$header[c("cellsize_lon", "cellsize_lat")] < 1 / 60,
      "arcsec",
      "arcmin"
    )
  ),
  sep = "",
  collapse = "_by_"
)
rm(tmp_res)
# Check version compatibility
if (xres(gridraster) != yres(gridraster) && bintype < 3) {
  stop("Only bintype 3 supports longitude and latitude resolution to differ")
}
# Upstream area, as computed by river_routing.R
cat("Reading pre-computed upstream areas from", sQuote(upstreamarea_RData), "\n")
load(upstreamarea_RData)
# Check if grids match
if (!identical(drainage_griddata, griddata)) {
  stop(
    "LPJmL grid ", sQuote(gridname),
    " does not match upstream area", sQuote(upstreamarea_RData)
  )
}
# Determine unit conversion factors using udunits2 package
conversion_factor_area <- ud.convert(1, lpjml_area_unit, grand_area_unit)
conversion_factor_capacity <-
  ud.convert(1, grand_capacity_unit, lpjml_capacity_unit)
# Convert unit of LPJmL upstream areas
drainage_upstreamarea <- drainage_upstreamarea * conversion_factor_area

## GRanD dams attribute table                                                 ##
cat("Reading GRanD attribute data from", sQuote(grand_name), "\n")
granddata <- read.dbf(grand_name)
grandcols <- c(
  "GRAND_ID",
  "RES_NAME",
  "DAM_NAME",
  "YEAR",
  "ALT_YEAR",
  "LONG_DD",
  "LAT_DD",
  "DAM_HGT_M",
  "AREA_SKM",
  "CAP_MCM",
  "CATCH_SKM",
  "USE_IRRI",
  "USE_ELEC",
  "USE_SUPP",
  "USE_FCON",
  "USE_RECR",
  "USE_NAVI",
  "USE_FISH",
  "USE_PCON",
  "USE_LIVE",
  "USE_OTHR",
  "MAIN_USE",
  "TIMELINE",
  "COMMENTS",
  "COUNTRY"
)
granddata <- granddata[, grandcols]
coordcols <- c("LONG_DD", "LAT_DD")
rownames(granddata) <- granddata$GRAND_ID
# Add columns for dam to grid cell assignment in LPJmL grid
# - column CELL_ID_GRID: grid cell ID based on GRanD coordinates
# - column CELL_ID_CATCH: grid cell ID based on best distance/deviation weight
# - column CATCH_AREA_LPJ_GRID: upstream area of cell CELL_ID_GRID
# - column CATCH_AREA_LPJ_BEST: upstream area of cell CELL_ID_CATCH
# - column DIST_LPJ_DAM: distance between dam coordinates and center of
#   CELL_ID_CATCH
cindex <- cellFromXY(gridraster, cbind(granddata$LONG_DD, granddata$LAT_DD))
granddata <- cbind(
  granddata,
  CELL_ID_GRID = gridraster[cindex],
  CATCH_AREA_LPJ_GRID = rep(NA, nrow(granddata))
)
rm(cindex)
# Prepare for parameter combinations of distance_penalty, deviation_penalty,
# neg_penalty, pos_penalty
parameter_setting <- array(
  dim = c(
    length(deviation_penalty) * length(distance_penalty) *
      length(neg_penalty) * length(pos_penalty),
    4
  ),
  dimnames = list(
    NULL,
    c("deviation_penalty", "distance_penalty", "neg_penalty", "pos_penalty")
  )
)
i <- 1
for (dev in deviation_penalty) {
  for (dis in distance_penalty) {
    for (neg in neg_penalty) {
      for (pos in pos_penalty) {
        parameter_setting[i, ] <- c(dev, dis, neg, pos)
        granddata <- cbind(
          granddata,
          rep(NA, nrow(granddata)),
          rep(NA, nrow(granddata)),
          rep(NA, nrow(granddata))
        )
        colindex <- seq(to = ncol(granddata), length.out = 3)
        colnames(granddata)[colindex] <- paste0(
          c("CELL_ID_CATCH", "CATCH_AREA_LPJ_BEST", "DIST_LPJ_DAM"),
          i
        )
        i <- i + 1
      }
    }
  }
}
# Check that LPJmL grid covers all dam locations
if (any(is.na(granddata$CELL_ID_GRID))) {
  warning(
    length(which(is.na(granddata$CELL_ID_GRID))),
    " dams are outside the range of grid file ", sQuote(gridname),
    call. = FALSE,
    immediate. = TRUE
  )
}
# Apply rules in timeline_action
cat("Applying filter rules in 'timeline_action' to GRanD attribute table:\n")
for (timeline in names(timeline_action)) {
  cat("Timeline attribute:", sQuote(timeline), "\n")
  if (timeline_action[timeline] == "drop") {
    for (r in which(granddata$TIMELINE == timeline)) {
      warning(
        "Dam ", granddata[r, "DAM_NAME"],
        " (", toString(round(granddata[r, coordcols], 2)), ")",
        " has timeline attribute ", sQuote(granddata$TIMELINE[r]),
        " and will be dropped. Review 'timeline_action' if necessary.",
        call. = FALSE,
        immediate. = TRUE
      )
    }
    # Remove dams with this timeline action
    granddata <- granddata[-which(granddata$TIMELINE == timeline), ]
  } else if (timeline_action[timeline] == "keep") {
    message(
      "Info: ", length(which(granddata$TIMELINE == timeline)),
      " dams have timeline attribute ", sQuote(timeline),
      " but will be kept regardless. Review 'timeline_action' if necessary."
    )
  } else {
    warning(
      length(which(granddata$TIMELINE == timeline)),
      " dams have timeline attribute ", sQuote(timeline),
      " but defined action ", sQuote(timeline_action[timeline]),
      " is not implemented.",
      call. = FALSE,
      immediate. = TRUE
    )
  }
}
# Further filtering
miss_cap <- which(is.na(granddata$CAP_MCM) | granddata$CAP_MCM <= 0)
if (length(miss_cap) > 0) {
  message("Missing storage capacity")
  for (r in miss_cap) {
    warning(
      "Dam ", granddata[r, "DAM_NAME"],
      " (", toString(round(granddata[r, coordcols], 2)), ")",
      " has no storage capacity and will be dropped.",
      call. = FALSE,
      immediate. = TRUE
    )
  }
  granddata <- granddata[-miss_cap, ]
}
rm(miss_cap)
################################################################################


################################################################################
## Fix reservoirs with missing area if fix_area == TRUE.                      ##
## This uses a reversed area-storage volume relationship from the Lehner et.  ##
## al 2011 paper. There are two versions in the paper:                        ##
## 1) based only on storage capacity                                          ##
## 2) based on storage capacity and dam height                                ##
# Function to estimate reservoir areas from storage capacity
area_from_cap <- function(cap) {
  return((cap / 30.684) ^ (1 / 0.9578))
}
# Function to estimate reservoir areas from storage capacity, dam height
area_from_cap_height <- function(cap, height) {
  return(1 / height * (cap / 0.678) ^ (1 / 0.9229))
}
miss_area <- which(
  (granddata$AREA_SKM <= 0 | is.na(granddata$AREA_SKM)) &
  granddata$CAP_MCM > 0
)
if (length(miss_area) > 0 && fix_area) {
  message(
    "Note: There are ", length(miss_area),
    " reservoirs which have a capacity, but are missing the area information.",
    " Using area-storage capacity relationship to fill in."
  )
  for (r in miss_area) {
    if (!is.na(granddata[r, "DAM_HGT_M"]) && granddata[r, "DAM_HGT_M"] > 0) {
      granddata[r, "AREA_SKM"] <- area_from_cap_height(
        granddata[r, "CAP_MCM"],
        granddata[r, "DAM_HGT_M"]
      )
    } else {
      granddata[r, "AREA_SKM"] <- area_from_cap(granddata[r, "CAP_MCM"])
    }
    message(
      "Fixing area for dam ", granddata[r, "DAM_NAME"],
      " (", toString(round(granddata[r, coordcols], 2)), ")"
    )
  }
}
################################################################################


################################################################################
## Check if LPJmL input files which will be created exist already or if       ##
## identical settings have been processed before.                             ##
# RData file with diagnostics (which includes information on run settings)
diagname <- paste0(
  "reservoir_diagnostics_",
  ifelse(nchar(version_string) > 0, paste0(version_string, "_"), ""),
  lpj_res_string, "_",
  ncol(parameter_setting), "_", "settings",
  ".RData"
)
# Check if previous run used identical settings
run_again <- TRUE
check_diag <- function(diagname, run_again) {
  if (file.exists(diagname)) {
    # Check if previous run used identical settings
    file_mismatch <- FALSE
    check_env <- new.env()
    load(diagname, envir = check_env)
    for (checkvar in c(
      "grand_name",
      "parameter_setting",
      "last_includeyear",
      "griddata",
      "minimum_startyear",
      "max_dist",
      "search_rad",
      "timeline_action",
      "upstreamarea_RData"
    )) {
      if (!identical(check_env[[checkvar]], get(checkvar))) {
        file_mismatch <- TRUE
        message("Mismatch ", checkvar)
      }
    }
    if (!file_mismatch) {
      cat(
        "Diagnostics file", sQuote(diagname), "exists already and",
        "appears to have used identical settings. Not processing data again.\n",
        "Delete or rename file", sQuote(diagname), "to force re-processing.\n"
      )
      run_again <- FALSE
      assign("diagname", diagname, pos = parent.frame())
      rm(check_env)
      return(run_again)
    } else {
      i <- 1
      while (file.exists(diagname1 <- sub(
        ".RData", paste0("_", i, ".RData"), diagname, ignore.case = TRUE
      )) && run_again) {
        run_again <- check_diag(diagname1, run_again)
        i <- i + 1
      }
    }
    if (!file.exists(diagname1) && !grepl("\\d+.RData", diagname)) {
      assign("diagname", diagname1, pos = parent.frame())
    }
  }
  if (!run_again) {
    assign("diagname", diagname, pos = parent.frame())
  }
  if (exists("check_env"))
    rm(check_env)
  return(run_again)
}
run_again <- check_diag(diagname, run_again)
if (!run_again) {
  # Reload processed data from previous script run with identical settings
  cat("Reloading data from", sQuote(diagname), "\n")
  load(diagname)
} else {
  # Input files created by this script
  for (i in seq_len(nrow(parameter_setting))) {
    lpjml_filename <- paste0(
      "reservoir_",
      ifelse(nchar(version_string) > 0, paste0(version_string, "_"), ""),
      lpj_res_string,
      "_par", i,
      ".bin"
    )
    if (file.exists(lpjml_filename)) {
      damheader <- read_header(lpjml_filename)
      check <- c("firstcell", "ncell", "cellsize_lon", "cellsize_lat")
      if (any(damheader$header[check] != gridheader$header[check])) {
        stop(
          "File dimensions of existing file ", sQuote(lpjml_filename),
          " do not match grid file ", sQuote(gridname),
          "\nRename existing file so that it can be recreated by this script."
        )
      }
      par_filename <- sub(".bin", "_settings.csv", lpjml_filename, fixed = TRUE)
      if (!file.exists(par_filename)) {
        stop(
          "File ", sQuote(lpjml_filename),
          " exists but parameter documentation file ", sQuote(par_filename),
          " is missing.\nDelete existing file to force re-processing."
        )
      } else {
        parameter_doc <- data.frame(
          Parameter = c(
            colnames(parameter_setting),
            "search_rad",
            "max_dist",
            "fix_area",
            "minimum_startyear",
            "last_includeyear"
          ),
          Value = c(
            parameter_setting[i, ],
            search_rad,
            max_dist,
            fix_area,
            minimum_startyear,
            last_includeyear
          )
        )
        filepar <- read.csv(par_filename)
        if (any(filepar != parameter_doc, na.rm = TRUE) ||
          !identical(which(is.na(filepar)), which(is.na(parameter_doc)))
        ) {
          message(
            "Error: Parameter settings in ", sQuote(par_filename),
            "do not match run settings:"
          )
          message("File setting:")
          sink(stderr())
          print(filepar)
          message("Run setting:")
          print(parameter_doc)
          sink()
          stop(
            "Change run settings or delete/rename existing files ",
            sQuote(lpjml_filename), " and ", sQuote(par_filename)
          )
        }
        stop(
          "File ", sQuote(lpjml_filename),
          " exists already with identical run settings.\n",
          "Please remove/rename file to force re-processing."
        )
      }
    }
  }
}
################################################################################


################################################################################
## Assign dams to grid cells in LPJmL grid file.                              ##
## This will be done for all combinations of parameters deviation_penalty,    ##
## distance_penalty, neg_penalty, pos_penalty.                                ##
## Grid cell assignment is model-independent.                                 ##
if (run_again) {
  cat(
    "Determining corresponding LPJmL cell for ",
    nrow(granddata), " dams and reservoirs for ",
    nrow(parameter_setting), " combinations of parameters ",
    toString(sQuote(dimnames(parameter_setting)[[2]])),
    ":\n",
    sep = ""
  )
  print(parameter_setting)
  for (r in seq_len(nrow(granddata))) {
    if (is.na(granddata[r, "CELL_ID_GRID"])) {
      message(
        "Skipping dam ", granddata[r, "GRAND_ID"],
        " because it is out of range of  grid file ", sQuote(gridname)
      )
      next
    }

    # Catchment area according to GRAND
    catch_grand <- granddata[r, "CATCH_SKM"]
    # Upstream area according to LPJmL grid file
    catch_lpj <- drainage_upstreamarea[granddata[r, "CELL_ID_GRID"]]
    granddata[r, "CATCH_AREA_LPJ_GRID"] <- catch_lpj
    if (granddata[r, "GRAND_ID"] %in% manual_assignment$GRAND_ID) {
      # Manual assignment
      rindex <- match(granddata[r, "GRAND_ID"], manual_assignment$GRAND_ID)
      cols1 <- paste0("CELL_ID_CATCH", seq_len(nrow(parameter_setting)))
      granddata[r, cols1] <- manual_assignment[rindex, "CELL_ID_CATCH"]
      cols2 <- paste0("CATCH_AREA_LPJ_BEST", seq_len(nrow(parameter_setting)))
      granddata[r, cols2] <-
        drainage_upstreamarea[as.integer(granddata[r, cols1])]
      cols3 <- paste0("DIST_LPJ_DAM", seq_len(nrow(parameter_setting)))
      granddata[r, cols3] <- distHaversine(
        griddata[as.integer(granddata[r, cols1]), ],
        cbind(x = granddata[r, "LONG_DD"], y = granddata[r, "LAT_DD"]),
        r = earthradius
      )
      message(
        "Assigning dam ", granddata[r, "DAM_NAME"],
        " (", toString(round(granddata[r, coordcols], 2)), ")",
        " to manually defined grid cell ",
        toString(
          format(griddata[granddata[r, "CELL_ID_CATCH1"], ], nsmall = 4)
        )
      )
      next
    }

    # Deviation between upstream area and catchment area
    catch_mismatch <- abs((catch_lpj - catch_grand))
    # Find cells within search_rad
    # Westside border
    lowlon <- (griddata[, "lon"] >=
      griddata[granddata[r, "CELL_ID_GRID"], "lon"] - search_rad
    )
    # Eastside border
    uplon <- (griddata[, "lon"] <=
      griddata[granddata[r, "CELL_ID_GRID"], "lon"] + search_rad
    )
    # Also cross 180Â°W/E line
    if (griddata[granddata[r, "CELL_ID_GRID"], "lon"] > 0) {
      lowlon2 <- (griddata[, "lon"] >=
        griddata[granddata[r, "CELL_ID_GRID"], "lon"] - search_rad - 360
      )
      uplon2 <- (griddata[, "lon"] <=
        griddata[granddata[r, "CELL_ID_GRID"], "lon"] + search_rad - 360
      )
    } else {
      lowlon2 <- (griddata[, "lon"] >=
        griddata[granddata[r, "CELL_ID_GRID"], "lon"] - search_rad + 360
      )
      uplon2 <- (griddata[, "lon"] <=
        griddata[granddata[r, "CELL_ID_GRID"], "lon"] + search_rad + 360
      )
    }
    # Southern border
    lowlat <- (griddata[, "lat"] >=
      griddata[granddata[r, "CELL_ID_GRID"], "lat"] - search_rad
    )
    # Northern border
    uplat <- (griddata[, "lat"] <=
      griddata[granddata[r, "CELL_ID_GRID"], "lat"] + search_rad
    )
    box_cells <- ((lowlon & uplon) | (lowlon2 & uplon2)) & lowlat & uplat
    # Search environment
    env <- which(box_cells)
    rm(lowlon, lowlon2, uplon, uplon2, lowlat, uplat, box_cells)
    if (length(env) > 1) {
      # To avoid an effect of the cell order in LPJmL grid file on selected cell
      # in case that several cells have identical distance and deviation weight
      # shuffle cells in env
      set.seed(granddata[r, "CELL_ID_GRID"])
      env <- sample(env)
    }
    # Distance between cells in search radius and dam
    catch_dist_env <- distHaversine(
      griddata[env, ],
      cbind(x = granddata[r, "LONG_DD"], y = granddata[r, "LAT_DD"]),
      r = earthradius
    )
    # Enforce maximum distance max_dist if set
    if (is.numeric(max_dist)) {
      env <- env[which(catch_dist_env <= max_dist)]
      catch_dist_env <- catch_dist_env[which(catch_dist_env <= max_dist)]
    }
    # Deviation between upstream areas in search environment and GRanD catchment
    # area
    catch_mismatch_env <- abs(drainage_upstreamarea[env] - catch_grand)

    # Compute weights based on distance_penalty, deviation_penalty, neg_penalty,
    # pos_penalty
    i <- 1
    for (dev in deviation_penalty) {
      for (dis in distance_penalty) {
        for (neg in neg_penalty) {
          for (pos in pos_penalty) {
            # Distance weigt
            dist_weight <- 1 / (catch_dist_env ^ dis)
            # pos_penalty or neg_penalty
            sign_pen <- ifelse(
              drainage_upstreamarea[env] < catch_grand,
              neg,
              pos
            )
            # Deviation weight
            dev_weight <- 1 / (catch_mismatch_env ^ (dev * sign_pen))
            weights_env <- dist_weight * dev_weight
            rm(dist_weight, sign_pen, dev_weight)

            # Select cell with highest weight (lowest combination of distance
            # penalty and deviation penalty)
            granddata[r, paste0("CELL_ID_CATCH", i)] <-
              env[which.max(weights_env)]
            granddata[r, paste0("CATCH_AREA_LPJ_BEST", i)] <-
              drainage_upstreamarea[granddata[r, paste0("CELL_ID_CATCH", i)]]
            granddata[r, paste0("DIST_LPJ_DAM", i)] <-
              catch_dist_env[which.max(weights_env)]
            i <- i + 1
            rm(weights_env)
          }
        }
      }
    }
    rm(env, catch_dist_env, catch_mismatch_env)

    # Status print message
    if (r %in% round(seq(0, nrow(granddata), length.out = 21))) {
      cat(round(r / nrow(granddata) * 100), "% finished\n", sep = "")
    }
  }
}
################################################################################


################################################################################
## Collect all data for LPJmL reservoir input. Assign reservoirs to LPJmL     ##
## grid cells. Since LPJmL only supports one dam/reservoir per grid cell      ##
## merge dams/reservoirs if there is more than one in the same cell.          ##
## This part is specific to the reservoir input format used by LPJmL.         ##
if (run_again) {
  cat(
    "Generating LPJmL input data for",
    nrow(granddata), "dams and reservoirs and",
    nrow(parameter_setting), "parameter combinations"
  )
  i <- 1
  for (dev in deviation_penalty) {
    for (dis in distance_penalty) {
      for (neg in neg_penalty) {
        for (pos in pos_penalty) {
          cat("Parameter combination:\n")
          print(parameter_setting[i, ])
          # Collect dams in list
          lpjdamsdata <- list()
          for (d in seq_len(gridheader$header["ncell"])) {
            # Pre-fill
            lpjdamsdata[[d]] <- FALSE
          }

          for (r in seq_len(nrow(granddata))) {
            if (!is.na(granddata$TIMELINE[r])) {
              if (granddata$TIMELINE[r] %in% names(timeline_action)) {
                if (timeline_action[granddata$TIMELINE[r]] == "drop") {
                  # These should have been removed above
                  warning(
                    "Dam ", granddata[r, "DAM_NAME"],
                    " (",
                    toString(round(granddata[r, coordcols], 2)),
                    ") has timeline attribute ",
                    sQuote(granddata$TIMELINE[r]),
                    " and will be dropped.",
                    " Review 'timeline_action' if necessary.",
                    call. = FALSE,
                    immediate. = TRUE
                  )
                  next
                } else if (timeline_action[granddata$TIMELINE[r]] == "keep") {
                  # no special treatment
                } else {
                  warning(
                    "Dam ", granddata[r, "DAM_NAME"],
                    " (",
                    toString(round(granddata[r, coordcols], 2)),
                    ") has timeline attribute ",
                    sQuote(granddata$TIMELINE[r]),
                    " but defined action ",
                    sQuote(timeline_action[granddata$TIMELINE[r]]),
                    " is not implemented.",
                    call. = FALSE,
                    immediate. = TRUE
                  )
                }
              } else {
                warning(
                  "Dam ", granddata[r, "DAM_NAME"],
                  " (",
                  toString(round(granddata[r, coordcols], 2)),
                  ") has timeline attribute ", sQuote(granddata$TIMELINE[r]),
                  " for which no action is defined in 'timeline_action'",
                  call. = FALSE,
                  immediate. = TRUE
                )
              }
            }
            if (is.na(granddata$CAP_MCM[r]) || granddata$CAP_MCM[r] <= 0) {
              message(
                "Skipping dam ", granddata[r, "DAM_NAME"],
                " (", toString(round(granddata[r, coordcols], 2)),
                ") because of missing capacity"
              )
              next
            }
            if (is.na(granddata$AREA_SKM[r]) || granddata$AREA_SKM[r] < 0) {
              warning(
                "Dam ", granddata[r, "DAM_NAME"],
                " (", toString(round(granddata[r, coordcols], 2)),
                ") has no reservoir area",
                ifelse(fix_area, " (fixing it)", ""),
                call. = FALSE,
                immediate. = TRUE
              )
            }
            lpjindex <- granddata[r, paste0("CELL_ID_CATCH", i)]
            # Dam container for single dam
            tmpdam <- double(11)
            names(tmpdam) <- c(
              "year",
              "capacity",
              "area",
              "inst_cap",
              "height",
              paste0("purpose", seq_len(5)),
              "GRAND_ID"
            )

            tmpdam["GRAND_ID"] <- granddata[r, "GRAND_ID"]
            tmpdam["year"] <- granddata[r, "YEAR"]
            if (is.na(tmpdam["year"]) || tmpdam["year"] < 0) {
              warning(
                "Dam ", granddata[r, "DAM_NAME"],
                " (", toString(round(granddata[r, coordcols], 2)),
                ") has no year information",
                call. = FALSE,
                immediate. = TRUE
              )
            } else if (tmpdam["year"] > last_includeyear) {
              message(
                "Note: reservoir in cell ",
                toString(round(granddata[r, c("LON", "LAT")], 2)),
                " is not included because it is built after ",
                "last_includeyear ", last_includeyear
              )
              next
            }
            tmpdam["capacity"] <- granddata[r, "CAP_MCM"] *
              conversion_factor_capacity
            tmpdam["area"] <- max(c(0, granddata[r, "AREA_SKM"]), na.rm = TRUE)
            # inst_cap is currently not used and contains dummy value
            tmpdam["inst_cap"] <- 0
            tmpdam["height"] <- max(
              c(0, granddata[r, "DAM_HGT_M"]),
              na.rm = TRUE
            )
            # main purpose
            tmpdam["purpose1"] <- switch(
              as.character(granddata[r, "MAIN_USE"]),
              "Hydroelectricity" = 2,
              "Irrigation" = 1,
              3
            )
            # secondary use for irrigation
            tmpdam["purpose2"] <- ifelse(is.na(granddata[r, "USE_IRRI"]), 0, 1)
            if (tmpdam["purpose1"] == 1)
              tmpdam["purpose2"] <- 1

            if (is.logical(lpjdamsdata[[lpjindex]])) {
              # No reservoir yet in that cell
              lpjdamsdata[[lpjindex]] <- tmpdam
            } else {
              # Append to existing reservoirs in that cell
              lpjdamsdata[[lpjindex]] <- cbind(lpjdamsdata[[lpjindex]], tmpdam)
            }
          }
          # Keep unmerged data for later
          assign(paste0("lpjdamsdata_unmerged", i), lpjdamsdata)

          # Merge reservoirs in case of multiple reservoirs within the same cell
          multiple <- which(sapply(lpjdamsdata, is.array))
          if (length(multiple) > 0)  {
            cat("Merging", length(multiple), "cells with multiple dams\n")
          }
          for (d in multiple) {
            tmpdam <- lpjdamsdata[[d]]
            tmpdam <- tmpdam[-grep("GRAND_ID", rownames(tmpdam)), ]
            message(
              "Merging ", ncol(tmpdam), " dams in cell ",
              toString(round(griddata[d, ], 4))
            )

            # Order dams by construction year
            tmpdam <- tmpdam[, order(tmpdam["year", ])]

            # Container for merged reservoir
            mergedam <- double(10)
            names(mergedam) <- c(
              "year",
              "capacity",
              "area",
              "inst_cap",
              "height",
              paste0("purpose", seq_len(5))
            )
            # Capacity, area and installed capacity are summed up
            cols <- c("capacity", "area", "inst_cap")
            mergedam[cols] <- apply(tmpdam[cols, ], 1, sum)
            # Height of largest dam
            largest <- which(tmpdam["capacity", ] == max(tmpdam["capacity", ]))
            mergedam["height"] <- max(tmpdam["height", largest])
            # Use for irrigation (purpose2), set true if at least 1 dam is true
            mergedam["purpose2"] <- max(tmpdam["purpose2", ])

            # Main use -> purpose that has the highest capacity in cell
            used_cap <- double(3)
            for (u in seq_len(3)) {
              cindex <- which(tmpdam["purpose1", ] == u)
              used_cap[u] <- sum(tmpdam["capacity", cindex])
              rm(cindex)
            }
            # Which purpose has maximum capacity; if several purposes with
            # identical capacity, use lowest purpose
            mergedam["purpose1"] <- min(which(used_cap == max(used_cap)))
            # Alternative method: use purpose of largest individual reservoir in
            # cell (this method is not used)
            # mergedam["purpose1"] <- min(tmpdam["purpose1", largest])
            rm(largest)

            # Year -> use year when at least half of final capacity is installed
            year_cap <- double(ncol(tmpdam))
            for (y in seq_along(year_cap)) {
              cindex <- which(tmpdam["year", ] <= tmpdam["year", y])
              year_cap[y] <- sum(tmpdam["capacity", cindex])
              rm(cindex)
            }
            cindex <- min(which(year_cap >= mergedam["capacity"] / 2))
            mergedam["year"] <- tmpdam["year", cindex]
            rm(cindex, year_cap)
            # Alternative method: Use year of largest individual reservoir
            # (this method is not used)
            # cindex <- which(tmpdam["capacity", ] == max(tmpdam["capacity", ]))
            # mergedam["year"] <- min(tmpdam["year", cindex])

            # If derived start year is missing value, use first year with value
            if (is.na(mergedam["year"]) || mergedam["year"] < 0) {
              if (any(tmpdam["year", ] >= 0, na.rm = TRUE)) {
                mergedam["year"] <-
                  min(tmpdam["year", which(tmpdam["year", ] >= 0)])
                message(
                  "Note: derived first year is missing value. ",
                  "Filling with earliest start year of all ",
                  ncol(tmpdam), " reservoirs in cell ",
                  toString(round(griddata[d, ], 4))
                )
              } else {
                warning(
                  "First year is missing for all ",
                  ncol(tmpdam), " reservoirs in cell ",
                  toString(round(griddata[d, ], 4)),
                  call. = FALSE,
                  immediate. = TRUE
                )
              }
            }
            # Write merged dam to list
            lpjdamsdata[[d]] <- mergedam
          }
          # Keep separate version for all parameter combinations
          assign(paste0("lpjdamsdata", i), lpjdamsdata)
          rm(lpjdamsdata)
          i <- i + 1
        }
      }
    }
  }
}
################################################################################


################################################################################
## Prepare to write to file                                                   ##
## This part is specific to the reservoir input format used by LPJmL.         ##
if (run_again) {
  output_array <- array(
    0,
    dim = c(gridheader$header["ncell"], 10, nrow(parameter_setting)),
    dimnames = list(
      NULL,
      c(
        "year",
        "capacity",
        "area",
        "inst_cap",
        "height",
        paste0("purpose", seq_len(5))
      ),
      NULL
    )
  )
  # Assign data from loops above
  for (i in seq_len(nrow(parameter_setting))) {
    lpjdamsdata <- get(paste0("lpjdamsdata", i))
    for (c in which(!sapply(lpjdamsdata, is.logical))) {
      if (any(grepl("GRAND_ID", names(lpjdamsdata[[c]])))) {
        idcol <- grep("GRAND_ID", names(lpjdamsdata[[c]]))
        output_array[c, , i] <- lpjdamsdata[[c]][-idcol]
      } else {
        output_array[c, , i] <- lpjdamsdata[[c]]
      }
    }
    rm(lpjdamsdata)
  }
}
# Correct for minimum_startyear
for (i in seq_len(nrow(parameter_setting))) {
  if (is.numeric(minimum_startyear)) {
    year_mismatch <- which(
      output_array[, "capacity", i] > 0 &
      output_array[, "year", i] < minimum_startyear
    )
    if (length(year_mismatch) > 0) {
      cat(
        "Resetting start year for", length(year_mismatch),
        "reservoirs to minimum_startyear", minimum_startyear,
        "for parameter combination:"
      )
      print(parameter_setting[i, ])
      output_array[year_mismatch, "year", i] <- minimum_startyear
      # If output_array is changed here make sure to write to file
      run_again <- TRUE
    }
  }
  # Check for negative start years in data
  year_neg <- which(
    output_array[, "capacity", i] > 0 & output_array[, "year", i] <= 0
  )
  if (length(year_neg) > 0) {
    warning(
      "There are ", length(year_neg), " cells with ",
      "negative start years in data to be written to LPJ input file.\n",
      "LPJmL expects all reservoirs to have positive start years.",
      call. = FALSE,
      immediate. = TRUE
    )
  }
}
################################################################################


################################################################################
## Write to LPJmL input file. Data for each parameter combination is saved    ##
## separately.                                                                ##
## This part is specific to the reservoir input format used by LPJmL.         ##
# Create file header in LPJmL input format
damheader <- create_header(
  name = headername,
  version = bintype,
  order = 0,
  firstyear = min(
    output_array[, "year", ][which(output_array[, "capacity", ] > 0)]
  ),
  nyear = 1,
  firstcell = gridheader$header["firstcell"],
  ncell = gridheader$header["ncell"],
  nbands = 10,
  cellsize_lon = gridheader$header["cellsize_lon"],
  cellsize_lat = gridheader$header["cellsize_lat"],
  datatype = 1
)
for (i in seq_len(nrow(parameter_setting))) {
  lpjml_filename <- paste0(
    "reservoir_",
    ifelse(nchar(version_string) > 0, paste0(version_string, "_"), ""),
    lpj_res_string,
    "_par", i,
    ".bin"
  )
  # Parameter documentation
  parameter_doc <- data.frame(
    Parameter = c(
      colnames(parameter_setting),
      "search_rad",
      "max_dist",
      "fix_area",
      "minimum_startyear",
      "last_includeyear"
    ),
    Value = c(
      parameter_setting[i, ],
      search_rad,
      max_dist,
      fix_area,
      minimum_startyear,
      last_includeyear
    )
  )
  if (run_again || !file.exists(lpjml_filename)) {
    write.csv(
      parameter_doc,
      file = sub(".bin", "_settings.csv", lpjml_filename, fixed = TRUE),
      row.names = FALSE
    )
    # Write header to file
    write_header(lpjml_filename, damheader, overwrite = TRUE)
    # Add data
    damfile <- file(lpjml_filename, "ab")
    for (c in seq_len(damheader$header["ncell"])) {
      # Reservoir input file uses mixed data type. Confirm in LPJmL code
      # (include/reservoir.h) that format written by this script still
      # conforms to format expected by LPJmL.
      # year as integer
      writeBin(
        as.integer(output_array[c, 1, i]),
        damfile,
        size = 4,
        endian = damheader$endian
      )
      # capacity, area as float
      writeBin(
        as.double(output_array[c, 2:3, i]),
        damfile,
        size = 4,
        endian = damheader$endian
      )
      # inst_cap, height, purpose as integer
      writeBin(
        as.integer(output_array[c, 4:10, i]),
        damfile,
        size = 4,
        endian = damheader$endian
      )
    }
    close(damfile)
    cat(
      "Data saved to", sQuote(lpjml_filename),
      "and corresponding parameter settings saved to",
      sQuote(sub(".bin", "_settings.csv", lpjml_filename, fixed = TRUE)), "\n"
    )
  } else {
    message(
      "File ", toString(sQuote(lpjml_filename)), " exists already and is not ",
      "generated again.\nDelete or rename to force recreation of file."
    )
  }
}
################################################################################


################################################################################
## Save diagnostics to RData file for further analysis                        ##
if (run_again) {
  diagnostics_table <- data.frame(
    GRAND_ID = granddata$GRAND_ID,
    # Distance between dam and its grid center point, comparable to
    # DIST_LPJ_DAM* columns but without relocation to better match upstream area
    dist_grid = distHaversine(
      granddata[, coordcols],
      griddata[granddata$CELL_ID_GRID, ],
      r = earthradius
    ),
    # Relative deviation between GRanD catchment area and DDM-derived upstream
    # area for grid cell in which dam coordinates are located
    deviation_grid = (granddata$CATCH_AREA_LPJ_GRID - granddata$CATCH_SKM) /
      granddata$CATCH_SKM,
    # Relative deviation between GRanD catchment area and DDM-derived upstream
    # area but use grid cell area if catchment area is smaller than 1 grid cell
    deviation_grid_cellsize = (
      granddata$CATCH_AREA_LPJ_GRID - granddata$CATCH_SKM
    ) / pmax(
      granddata$CATCH_SKM,
      cellarea(
        griddata[granddata$CELL_ID_GRID, "lat"],
        xres(gridraster),
        yres(gridraster)
      ) * conversion_factor_area
    )
  )
  # Add comparison for optimized positions
  for (i in seq_len(nrow(parameter_setting))) {
    diagnostics_table <- cbind(
      diagnostics_table,
      granddata[, paste0("DIST_LPJ_DAM", i)],
      (granddata[, paste0("CATCH_AREA_LPJ_BEST", i)] - granddata$CATCH_SKM) /
        granddata$CATCH_SKM,
      (granddata[, paste0("CATCH_AREA_LPJ_BEST", i)] - granddata$CATCH_SKM) /
        pmax(
          granddata$CATCH_SKM,
          cellarea(
            griddata[granddata$CELL_ID_GRID, "lat"],
            xres(gridraster),
            yres(gridraster)
          ) * conversion_factor_area
        )
    )
    ind <- seq(to = ncol(diagnostics_table), length.out = 3)
    colnames(diagnostics_table)[ind] <- c(
      paste0("dist_best", i),
      paste0("deviation_best", i),
      paste0("deviation_best", i, "_cellsize")
    )
  }
}
savevar <- c(
  "griddata",
  "granddata",
  "grand_name",
  "gridname",
  "upstreamarea_RData",
  "parameter_setting",
  "max_dist",
  "search_rad",
  "minimum_startyear",
  "last_includeyear",
  "timeline_action",
  "output_array",
  paste0("lpjdamsdata", seq_len(nrow(parameter_setting))),
  paste0("lpjdamsdata_unmerged", seq_len(nrow(parameter_setting))),
  "diagnostics_table"
)
cat("Saving run diagnostics to", sQuote(diagname), "\n")
save(list = savevar, file = diagname)
################################################################################

################################################################################
## Plot dam locations and reservoirs to allow visual inspection of cell       ##
## assignment.                                                                ##
## This part is model-independent.                                            ##
# PDF file with map plots for dam locations
pdfname <- sub(".RData", ".pdf", diagname, ignore.case = TRUE)
# If sf package supports s2 (which depends on package version) switch it off
if (exists("sf_use_s2")) {
  sf_use_s2(FALSE)
}
if (!file.exists(pdfname)) {
  # Color scale from RColorBrewer
  col_scale <- colorRampPalette(c("grey95", brewer.pal(9, "YlGnBu")))
  # Load polyon shapes of reservoirs
  grand_reservoir_shape <- st_read(
    sub(
      "_dams",
      "_reservoirs",
      sub(".dbf", ".shp", grand_name, ignore.case = TRUE),
      ignore.case = TRUE
    )
  )
  # Simplify shapes for plotting
  grand_reservoir_shape <- st_simplify(
    grand_reservoir_shape,
    preserveTopology = TRUE,
    dTolerance = 0.01
  )
  if (any(!st_is_valid(grand_reservoir_shape)))
    grand_reservoir_shape <- st_make_valid(grand_reservoir_shape)
  # Create raster of upstream areas
  upstreamarea <- raster(gridraster)
  upstreamarea[cellFromXY(upstreamarea, griddata)] <- drainage_upstreamarea
  # Function to retrieve attributes from lpjdamsdata list object
  return_att <- function(indata, att) {
    if (is.array(indata)) {
      return(indata[grep(att, rownames(indata)), ])
    } else {
      return(indata[att])
    }
  }
  # Set up individual plots.
  plots <- list()
  # Plot reservoirs by descending capacity
  sequence <- order(granddata$CAP_MCM, decreasing = TRUE)
  for (r in sequence) {
    # Find GRanD IDs closeby to combine dams that are located close together
    closeby <- which(
      abs(granddata$LONG_DD[r] - granddata$LONG_DD) < 1 &
      abs(granddata$LAT_DD[r] - granddata$LAT_DD) < 1
    )
    # Do not add IDs of reservoirs that are already in another plot
    neighbour_ids <- setdiff(granddata$GRAND_ID[closeby], unlist(plots))
    # Closest 5 if more than 5
    if (length(neighbour_ids) > 5) {
      neighbour_dist <- distHaversine(
        granddata[match(neighbour_ids, granddata$GRAND_ID), coordcols],
        granddata[r, coordcols],
        r = earthradius
      )
      neighbour_ids <- neighbour_ids[order(neighbour_dist)[1:5]]
    }
    if (length(neighbour_ids) > 0) {
      plots[[length(plots) + 1]] <- neighbour_ids
    }
  }
  cat("Plotting dam to cell assignments to", sQuote(pdfname), "\n")
  pdf(pdfname, width = 11, height = 7, pointsize = 10, compress = TRUE)
  par(
    mfrow = c(3, 4),
    mar = c(0.25, 0.25, 0.25, 6),
    oma = c(0, 0, ceiling(nrow(parameter_setting) / 2), 3)
  )
  for (p in seq_along(plots)) {
    # grid cells associated with GRanD IDs
    idcol <- paste0("CELL_ID_CATCH", seq_len(nrow(parameter_setting)))
    plot_cells <- unique(
      unlist(granddata[match(plots[[p]], granddata$GRAND_ID), idcol])
    )
    # Derive plot extent
    if (length(plot_cells) > 1) {
      plotcenter <- apply(
        griddata[plot_cells, ],
        2,
        function(indata) return(mean(range(indata)))
      )
    } else {
      plotcenter <- griddata[plot_cells, ]
    }
    plotextent <- extent(
      rep(plotcenter, each = 2) + c(-1.1 * search_rad, 1.1 * search_rad)
    )
    xmin(plotextent) <- min(
      xmin(plotextent),
      min(griddata[plot_cells, "lon"]) - xres(gridraster) / 2
    )
    xmax(plotextent) <- max(
      xmax(plotextent),
      max(griddata[plot_cells, "lon"]) + xres(gridraster) / 2
    )
    ymin(plotextent) <- min(
      ymin(plotextent),
      min(griddata[plot_cells, "lat"]) - yres(gridraster) / 2
    )
    ymax(plotextent) <- max(
      ymax(plotextent),
      max(griddata[plot_cells, "lat"]) + yres(gridraster) / 2
    )
    # Plot dam locations for each parameter combination (if different from the
    # other parameter combinations)
    for (i in seq_len(nrow(parameter_setting))) {
      # Not all cells in plot_cells may have dams for this parameter combination
      par_cells <- intersect(
        plot_cells,
        which(output_array[, "capacity", i] > 0)
      )
      lpjdamsdata_unmerged <- get(paste0("lpjdamsdata_unmerged", i))
      setting_identical <- integer(0)
      for (j in seq_len(nrow(parameter_setting))) {
        if (
          identical(lpjdamsdata_unmerged[plot_cells],
          get(paste0("lpjdamsdata_unmerged", j))[plot_cells])
        ) {
          setting_identical <- c(setting_identical, j)
        }
      }
      if (i != min(setting_identical)) {
        # identical plot has been done already
        next
      }
      par(mar = c(0.25, 0.25, 0.25, 6))
      # Plot basemap of upstream area
      plot(
        crop(upstreamarea, plotextent),
        axes = FALSE, col = col_scale(255), useRaster = TRUE,
        smallplot = c(0.775, 0.8, 0.4, 0.95), bigplot = c(0, 0.75, 0.01, 0.99),
        graphics.reset = FALSE
      )
      # Add reservoir shapes
      r <- match(plots[[p]], grand_reservoir_shape$GRAND_ID)
      plot(
        st_geometry(grand_reservoir_shape[r, "GRAND_ID"]),
        add = TRUE,
        lwd = 0.1,
        col = NA,
        border = "grey",
        axes = FALSE,
        reset = FALSE
      )
      # Add simple country borders from the R maps package. Note: These are less
      # accurate than GADM shapes used in the toolbox. They are used here to
      # reduce the size of the PDF file. Call may fail if no country borders are
      # in range.
      try(
        map(add = TRUE, col = "grey40", lty = 2, lwd = 0.5, resolution = 1,
            xlim = (plotextent + 2)[1:2], ylim = (plotextent + 2)[3:4]),
        silent = TRUE
      )
      # Add point symbols at dam coordinates from GRanD
      r <- match(plots[[p]], granddata$GRAND_ID)
      points(
        granddata[r, coordcols],
        col = "black", pch = 4, ps = 0.3
      )
      # Add any additional GRanD dams that may be within the plot extent
      points(
        granddata[-r, coordcols],
        col = "black", pch = 4, ps = 0.1, cex = 0.5
      )
      # Add point symbols in assigned grid cells
      points(
        x = griddata[par_cells, "lon"],
        y = griddata[par_cells, "lat"],
        col = "red", pch = 3, ps = 0.3
      )
      # Add list of dams grouped by grid cell and associated upstream area
      text(
        x = grconvertX(0, "npc", "user"),
        y = grconvertY(0.95, "npc", "user"),
        labels = "LPJmL",
        col = "red", pos = 4, cex = 0.85
      )
      text(
        x = grconvertX(0, "npc", "user"),
        y = grconvertY(
          seq(0.9, length.out = length(par_cells) * 2, by = -0.05),
          "npc",
          "user"
        ),
        labels = c(t(data.frame(
          ID = sapply(
            lpjdamsdata_unmerged[par_cells],
            function(indata, att) toString(return_att(indata, att)),
            att = "GRAND_ID"
          ),
          area = paste0(
            round(drainage_upstreamarea[par_cells], 1),
            grand_area_unit
          )
        ))),
        col = "red",
        pos = 4,
        cex = 0.75
      )
      # Add arrows from text labels to corresponding point symbols of assigned
      # grid cell
      arrows(
        x0 = grconvertX(0, "npc", "user") + strwidth(
          sapply(
            lpjdamsdata_unmerged[par_cells],
            function(indata, att) toString(return_att(indata, att)),
            att = "GRAND_ID"
          ),
          cex = 1
        ),
        y0 = grconvertY(
          seq(0.9, length.out = length(par_cells), by = -0.05 * 2),
          "npc",
          "user"
        ),
        x1 = griddata[par_cells, 1],
        y1 = griddata[par_cells, 2],
        length = 0, code = 3, col = "red", lwd = 0.5
      )
      # Add list of GRanD dam IDs and associated catchment area from GRanD
      text(
        x = grconvertX(1, "npc", "user"),
        y = grconvertY(0.95, "npc", "user"),
        labels = "GRanD",
        col = "black", pos = 2, cex = 0.85
      )
      text(
        x = grconvertX(1, "npc", "user"),
        y = grconvertY(
          seq(0.9, length.out = length(plots[[p]]) * 2, by = -0.05),
          "npc",
          "user"
        ),
        labels = c(t(data.frame(
          ID = plots[[p]],
          area = paste0(round(granddata[r, "CATCH_SKM"], 1), grand_area_unit)
        ))),
        col = "black", pos = 2, cex = 0.75
      )
      # Add arrows from text labels to GRanD coordinates
      arrows(
        x0 = grconvertX(1, "npc", "user") -
          strwidth(plots[[p]], cex = 1),
        y0 = grconvertY(
          seq(0.9, length.out = length(plots[[p]]), by = -0.05 * 2),
          "npc",
          "user"
        ),
        x1 = granddata[r, c("LONG_DD")],
        y1 = granddata[r, c("LAT_DD")],
        length = 0, code = 3, col = "black", lwd = 0.5
      )
      # Add country name from GRanD database
      if (par("fig")[1] == 0 && par("fig")[4] == 1) {
        line <- ceiling(nrow(parameter_setting) / 2) - 1
        for (j in seq_len(nrow(parameter_setting))) {
          mtext(
            text = paste0(
              "Combination ", j, ": ",
              toString(
                paste(
                  colnames(parameter_setting),
                  parameter_setting[j, ],
                  sep = ": "
                )
              )
            ),
            adj = ifelse(j %% 2 == 0, 1, 0),
            line = line, outer = TRUE, cex = 0.66
          )
          if ((j %% 2) == 0) {
            line <- line - 1
          }
        }
      }
      legend(
        "bottomleft",
        legend = c(
          toString(unique(granddata$COUNTRY[r])),
          paste("par. combinations:", toString(setting_identical))
        ),
        bty = "n",
        xpd = NA
      )
      # Reset margins temporarily for additional legend plot
      par(mar = c(0.25, 0.25, 0.25, 0), new = TRUE)
      plot.new()
      # Add legend with storage capacities
      legend(
        "bottomright",
        legend = paste0(
          plots[[p]], ": ",
          round(granddata[r, c("CAP_MCM")] * conversion_factor_capacity, 2),
          lpjml_capacity_unit
        ),
        cex = 0.75,
        xpd = NA,
        bg = "white",
        seg.len = 0,
        x.intersp = 0,
        pt.cex = 0,
        title = "Storage capacity"
      )
    }
  }
  dev.off()
} else {
  message(
    "Diagnostics plots exist already in ", sQuote(pdfname),
    ".\nSkipping file creation."
  )
}
################################################################################
